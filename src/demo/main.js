(() => { "use strict"; var wE = { 583: () => { !function (g) { const y = g.performance; function M(Ie) { y && y.mark && y.mark(Ie) } function v(Ie, z) { y && y.measure && y.measure(Ie, z) } M("Zone"); const x = g.__Zone_symbol_prefix || "__zone_symbol__"; function S(Ie) { return x + Ie } const G = !0 === g[S("forceDuplicateZoneCheck")]; if (g.Zone) { if (G || "function" != typeof g.Zone.__symbol__) throw new Error("Zone already loaded."); return g.Zone } let q = (() => { class Ie { constructor(p, _) { this._parent = p, this._name = _ ? _.name || "unnamed" : "<root>", this._properties = _ && _.properties || {}, this._zoneDelegate = new oe(this, this._parent && this._parent._zoneDelegate, _) } static assertZonePatched() { if (g.Promise !== Nt.ZoneAwarePromise) throw new Error("Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)") } static get root() { let p = Ie.current; for (; p.parent;)p = p.parent; return p } static get current() { return st.zone } static get currentTask() { return vn } static __load_patch(p, _, X = !1) { if (Nt.hasOwnProperty(p)) { if (!X && G) throw Error("Already loaded patch: " + p) } else if (!g["__Zone_disable_" + p]) { const ye = "Zone:" + p; M(ye), Nt[p] = _(g, Ie, Dt), v(ye, ye) } } get parent() { return this._parent } get name() { return this._name } get(p) { const _ = this.getZoneWith(p); if (_) return _._properties[p] } getZoneWith(p) { let _ = this; for (; _;) { if (_._properties.hasOwnProperty(p)) return _; _ = _._parent } return null } fork(p) { if (!p) throw new Error("ZoneSpec required!"); return this._zoneDelegate.fork(this, p) } wrap(p, _) { if ("function" != typeof p) throw new Error("Expecting function got: " + p); const X = this._zoneDelegate.intercept(this, p, _), ye = this; return function () { return ye.runGuarded(X, this, arguments, _) } } run(p, _, X, ye) { st = { parent: st, zone: this }; try { return this._zoneDelegate.invoke(this, p, _, X, ye) } finally { st = st.parent } } runGuarded(p, _ = null, X, ye) { st = { parent: st, zone: this }; try { try { return this._zoneDelegate.invoke(this, p, _, X, ye) } catch (kt) { if (this._zoneDelegate.handleError(this, kt)) throw kt } } finally { st = st.parent } } runTask(p, _, X) { if (p.zone != this) throw new Error("A task can only be run in the zone of creation! (Creation: " + (p.zone || Ft).name + "; Execution: " + this.name + ")"); if (p.state === ze && (p.type === Zt || p.type === ce)) return; const ye = p.state != W; ye && p._transitionTo(W, He), p.runCount++; const kt = vn; vn = p, st = { parent: st, zone: this }; try { p.type == ce && p.data && !p.data.isPeriodic && (p.cancelFn = void 0); try { return this._zoneDelegate.invokeTask(this, p, _, X) } catch (F) { if (this._zoneDelegate.handleError(this, F)) throw F } } finally { p.state !== ze && p.state !== j && (p.type == Zt || p.data && p.data.isPeriodic ? ye && p._transitionTo(He, W) : (p.runCount = 0, this._updateTaskCount(p, -1), ye && p._transitionTo(ze, W, ze))), st = st.parent, vn = kt } } scheduleTask(p) { if (p.zone && p.zone !== this) { let X = this; for (; X;) { if (X === p.zone) throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${p.zone.name}`); X = X.parent } } p._transitionTo(Ue, ze); const _ = []; p._zoneDelegates = _, p._zone = this; try { p = this._zoneDelegate.scheduleTask(this, p) } catch (X) { throw p._transitionTo(j, Ue, ze), this._zoneDelegate.handleError(this, X), X } return p._zoneDelegates === _ && this._updateTaskCount(p, 1), p.state == Ue && p._transitionTo(He, Ue), p } scheduleMicroTask(p, _, X, ye) { return this.scheduleTask(new Y(xe, p, _, X, ye, void 0)) } scheduleMacroTask(p, _, X, ye, kt) { return this.scheduleTask(new Y(ce, p, _, X, ye, kt)) } scheduleEventTask(p, _, X, ye, kt) { return this.scheduleTask(new Y(Zt, p, _, X, ye, kt)) } cancelTask(p) { if (p.zone != this) throw new Error("A task can only be cancelled in the zone of creation! (Creation: " + (p.zone || Ft).name + "; Execution: " + this.name + ")"); p._transitionTo(tt, He, W); try { this._zoneDelegate.cancelTask(this, p) } catch (_) { throw p._transitionTo(j, tt), this._zoneDelegate.handleError(this, _), _ } return this._updateTaskCount(p, -1), p._transitionTo(ze, tt), p.runCount = 0, p } _updateTaskCount(p, _) { const X = p._zoneDelegates; -1 == _ && (p._zoneDelegates = null); for (let ye = 0; ye < X.length; ye++)X[ye]._updateTaskCount(p.type, _) } } return Ie.__symbol__ = S, Ie })(); const de = { name: "", onHasTask: (Ie, z, p, _) => Ie.hasTask(p, _), onScheduleTask: (Ie, z, p, _) => Ie.scheduleTask(p, _), onInvokeTask: (Ie, z, p, _, X, ye) => Ie.invokeTask(p, _, X, ye), onCancelTask: (Ie, z, p, _) => Ie.cancelTask(p, _) }; class oe { constructor(z, p, _) { this._taskCounts = { microTask: 0, macroTask: 0, eventTask: 0 }, this.zone = z, this._parentDelegate = p, this._forkZS = _ && (_ && _.onFork ? _ : p._forkZS), this._forkDlgt = _ && (_.onFork ? p : p._forkDlgt), this._forkCurrZone = _ && (_.onFork ? this.zone : p._forkCurrZone), this._interceptZS = _ && (_.onIntercept ? _ : p._interceptZS), this._interceptDlgt = _ && (_.onIntercept ? p : p._interceptDlgt), this._interceptCurrZone = _ && (_.onIntercept ? this.zone : p._interceptCurrZone), this._invokeZS = _ && (_.onInvoke ? _ : p._invokeZS), this._invokeDlgt = _ && (_.onInvoke ? p : p._invokeDlgt), this._invokeCurrZone = _ && (_.onInvoke ? this.zone : p._invokeCurrZone), this._handleErrorZS = _ && (_.onHandleError ? _ : p._handleErrorZS), this._handleErrorDlgt = _ && (_.onHandleError ? p : p._handleErrorDlgt), this._handleErrorCurrZone = _ && (_.onHandleError ? this.zone : p._handleErrorCurrZone), this._scheduleTaskZS = _ && (_.onScheduleTask ? _ : p._scheduleTaskZS), this._scheduleTaskDlgt = _ && (_.onScheduleTask ? p : p._scheduleTaskDlgt), this._scheduleTaskCurrZone = _ && (_.onScheduleTask ? this.zone : p._scheduleTaskCurrZone), this._invokeTaskZS = _ && (_.onInvokeTask ? _ : p._invokeTaskZS), this._invokeTaskDlgt = _ && (_.onInvokeTask ? p : p._invokeTaskDlgt), this._invokeTaskCurrZone = _ && (_.onInvokeTask ? this.zone : p._invokeTaskCurrZone), this._cancelTaskZS = _ && (_.onCancelTask ? _ : p._cancelTaskZS), this._cancelTaskDlgt = _ && (_.onCancelTask ? p : p._cancelTaskDlgt), this._cancelTaskCurrZone = _ && (_.onCancelTask ? this.zone : p._cancelTaskCurrZone), this._hasTaskZS = null, this._hasTaskDlgt = null, this._hasTaskDlgtOwner = null, this._hasTaskCurrZone = null; const X = _ && _.onHasTask; (X || p && p._hasTaskZS) && (this._hasTaskZS = X ? _ : de, this._hasTaskDlgt = p, this._hasTaskDlgtOwner = this, this._hasTaskCurrZone = z, _.onScheduleTask || (this._scheduleTaskZS = de, this._scheduleTaskDlgt = p, this._scheduleTaskCurrZone = this.zone), _.onInvokeTask || (this._invokeTaskZS = de, this._invokeTaskDlgt = p, this._invokeTaskCurrZone = this.zone), _.onCancelTask || (this._cancelTaskZS = de, this._cancelTaskDlgt = p, this._cancelTaskCurrZone = this.zone)) } fork(z, p) { return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, z, p) : new q(z, p) } intercept(z, p, _) { return this._interceptZS ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, z, p, _) : p } invoke(z, p, _, X, ye) { return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, z, p, _, X, ye) : p.apply(_, X) } handleError(z, p) { return !this._handleErrorZS || this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, z, p) } scheduleTask(z, p) { let _ = p; if (this._scheduleTaskZS) this._hasTaskZS && _._zoneDelegates.push(this._hasTaskDlgtOwner), _ = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, z, p), _ || (_ = p); else if (p.scheduleFn) p.scheduleFn(p); else { if (p.type != xe) throw new Error("Task is missing scheduleFn."); fe(p) } return _ } invokeTask(z, p, _, X) { return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, z, p, _, X) : p.callback.apply(_, X) } cancelTask(z, p) { let _; if (this._cancelTaskZS) _ = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, z, p); else { if (!p.cancelFn) throw Error("Task is not cancelable"); _ = p.cancelFn(p) } return _ } hasTask(z, p) { try { this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, z, p) } catch (_) { this.handleError(z, _) } } _updateTaskCount(z, p) { const _ = this._taskCounts, X = _[z], ye = _[z] = X + p; if (ye < 0) throw new Error("More tasks executed then were scheduled."); 0 != X && 0 != ye || this.hasTask(this.zone, { microTask: _.microTask > 0, macroTask: _.macroTask > 0, eventTask: _.eventTask > 0, change: z }) } } class Y { constructor(z, p, _, X, ye, kt) { if (this._zone = null, this.runCount = 0, this._zoneDelegates = null, this._state = "notScheduled", this.type = z, this.source = p, this.data = X, this.scheduleFn = ye, this.cancelFn = kt, !_) throw new Error("callback is not defined"); this.callback = _; const F = this; this.invoke = z === Zt && X && X.useG ? Y.invokeTask : function () { return Y.invokeTask.call(g, F, this, arguments) } } static invokeTask(z, p, _) { z || (z = this), xt++; try { return z.runCount++, z.zone.runTask(z, p, _) } finally { 1 == xt && $(), xt-- } } get zone() { return this._zone } get state() { return this._state } cancelScheduleRequest() { this._transitionTo(ze, Ue) } _transitionTo(z, p, _) { if (this._state !== p && this._state !== _) throw new Error(`${this.type} '${this.source}': can not transition to '${z}', expecting state '${p}'${_ ? " or '" + _ + "'" : ""}, was '${this._state}'.`); this._state = z, z == ze && (this._zoneDelegates = null) } toString() { return this.data && typeof this.data.handleId < "u" ? this.data.handleId.toString() : Object.prototype.toString.call(this) } toJSON() { return { type: this.type, state: this.state, source: this.source, zone: this.zone.name, runCount: this.runCount } } } const Re = S("setTimeout"), we = S("Promise"), Te = S("then"); let Bt, ot = [], Be = !1; function gt(Ie) { if (Bt || g[we] && (Bt = g[we].resolve(0)), Bt) { let z = Bt[Te]; z || (z = Bt.then), z.call(Bt, Ie) } else g[Re](Ie, 0) } function fe(Ie) { 0 === xt && 0 === ot.length && gt($), Ie && ot.push(Ie) } function $() { if (!Be) { for (Be = !0; ot.length;) { const Ie = ot; ot = []; for (let z = 0; z < Ie.length; z++) { const p = Ie[z]; try { p.zone.runTask(p, null, null) } catch (_) { Dt.onUnhandledError(_) } } } Dt.microtaskDrainDone(), Be = !1 } } const Ft = { name: "NO ZONE" }, ze = "notScheduled", Ue = "scheduling", He = "scheduled", W = "running", tt = "canceling", j = "unknown", xe = "microTask", ce = "macroTask", Zt = "eventTask", Nt = {}, Dt = { symbol: S, currentZoneFrame: () => st, onUnhandledError: bt, microtaskDrainDone: bt, scheduleMicroTask: fe, showUncaughtError: () => !q[S("ignoreConsoleErrorUncaughtError")], patchEventTarget: () => [], patchOnProperties: bt, patchMethod: () => bt, bindArguments: () => [], patchThen: () => bt, patchMacroTask: () => bt, patchEventPrototype: () => bt, isIEOrEdge: () => !1, getGlobalObjects: () => { }, ObjectDefineProperty: () => bt, ObjectGetOwnPropertyDescriptor: () => { }, ObjectCreate: () => { }, ArraySlice: () => [], patchClass: () => bt, wrapWithCurrentZone: () => bt, filterProperties: () => [], attachOriginToPatched: () => bt, _redefineProperty: () => bt, patchCallbacks: () => bt, nativeScheduleMicroTask: gt }; let st = { parent: null, zone: new q(null, null) }, vn = null, xt = 0; function bt() { } v("Zone", "Zone"), g.Zone = q }(typeof window < "u" && window || typeof self < "u" && self || global); const Ce = Object.getOwnPropertyDescriptor, Rr = Object.defineProperty, Jn = Object.getPrototypeOf, to = Object.create, ln = Array.prototype.slice, no = "addEventListener", ro = "removeEventListener", io = Zone.__symbol__(no), er = Zone.__symbol__(ro), yn = "true", jn = "false", Pr = Zone.__symbol__(""); function us(g, y) { return Zone.current.wrap(g, y) } function ds(g, y, M, v, x) { return Zone.current.scheduleMacroTask(g, y, M, v, x) } const $e = Zone.__symbol__, ei = typeof window < "u", _n = ei ? window : void 0, pt = ei && _n || "object" == typeof self && self || global; function Ei(g, y) { for (let M = g.length - 1; M >= 0; M--)"function" == typeof g[M] && (g[M] = us(g[M], y + "_" + M)); return g } function oo(g) { return !g || !1 !== g.writable && !("function" == typeof g.get && typeof g.set > "u") } const Ra = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope, Lr = !("nw" in pt) && typeof pt.process < "u" && "[object process]" === {}.toString.call(pt.process), ti = !Lr && !Ra && !(!ei || !_n.HTMLElement), Pa = typeof pt.process < "u" && "[object process]" === {}.toString.call(pt.process) && !Ra && !(!ei || !_n.HTMLElement), ni = {}, La = function (g) { if (!(g = g || pt.event)) return; let y = ni[g.type]; y || (y = ni[g.type] = $e("ON_PROPERTY" + g.type)); const M = this || g.target || pt, v = M[y]; let x; if (ti && M === _n && "error" === g.type) { const S = g; x = v && v.call(this, S.message, S.filename, S.lineno, S.colno, S.error), !0 === x && g.preventDefault() } else x = v && v.apply(this, arguments), null != x && !x && g.preventDefault(); return x }; function so(g, y, M) { let v = Ce(g, y); if (!v && M && Ce(M, y) && (v = { enumerable: !0, configurable: !0 }), !v || !v.configurable) return; const x = $e("on" + y + "patched"); if (g.hasOwnProperty(x) && g[x]) return; delete v.writable, delete v.value; const S = v.get, G = v.set, q = y.slice(2); let de = ni[q]; de || (de = ni[q] = $e("ON_PROPERTY" + q)), v.set = function (oe) { let Y = this; !Y && g === pt && (Y = pt), Y && ("function" == typeof Y[de] && Y.removeEventListener(q, La), G && G.call(Y, null), Y[de] = oe, "function" == typeof oe && Y.addEventListener(q, La, !1)) }, v.get = function () { let oe = this; if (!oe && g === pt && (oe = pt), !oe) return null; const Y = oe[de]; if (Y) return Y; if (S) { let Re = S.call(this); if (Re) return v.set.call(this, Re), "function" == typeof oe.removeAttribute && oe.removeAttribute(y), Re } return null }, Rr(g, y, v), g[x] = !0 } function Vr(g, y, M) { if (y) for (let v = 0; v < y.length; v++)so(g, "on" + y[v], M); else { const v = []; for (const x in g) "on" == x.slice(0, 2) && v.push(x); for (let x = 0; x < v.length; x++)so(g, v[x], M) } } const $n = $e("originalInstance"); function ri(g) { const y = pt[g]; if (!y) return; pt[$e(g)] = y, pt[g] = function () { const x = Ei(arguments, g); switch (x.length) { case 0: this[$n] = new y; break; case 1: this[$n] = new y(x[0]); break; case 2: this[$n] = new y(x[0], x[1]); break; case 3: this[$n] = new y(x[0], x[1], x[2]); break; case 4: this[$n] = new y(x[0], x[1], x[2], x[3]); break; default: throw new Error("Arg list too long.") } }, tr(pt[g], y); const M = new y(function () { }); let v; for (v in M) "XMLHttpRequest" === g && "responseBlob" === v || function (x) { "function" == typeof M[x] ? pt[g].prototype[x] = function () { return this[$n][x].apply(this[$n], arguments) } : Rr(pt[g].prototype, x, { set: function (S) { "function" == typeof S ? (this[$n][x] = us(S, g + "." + x), tr(this[$n][x], S)) : this[$n][x] = S }, get: function () { return this[$n][x] } }) }(v); for (v in y) "prototype" !== v && y.hasOwnProperty(v) && (pt[g][v] = y[v]) } function qe(g, y, M) { let v = g; for (; v && !v.hasOwnProperty(y);)v = Jn(v); !v && g[y] && (v = g); const x = $e(y); let S = null; if (v && (!(S = v[x]) || !v.hasOwnProperty(x)) && (S = v[x] = v[y], oo(v && Ce(v, y)))) { const q = M(S, x, y); v[y] = function () { return q(this, arguments) }, tr(v[y], S) } return S } function Va(g, y, M) { let v = null; function x(S) { const G = S.data; return G.args[G.cbIdx] = function () { S.invoke.apply(this, arguments) }, v.apply(G.target, G.args), S } v = qe(g, y, S => function (G, q) { const de = M(G, q); return de.cbIdx >= 0 && "function" == typeof q[de.cbIdx] ? ds(de.name, q[de.cbIdx], de, x) : S.apply(G, q) }) } function tr(g, y) { g[$e("OriginalDelegate")] = y } let Ba = !1, fs = !1; function Ha() { if (Ba) return fs; Ba = !0; try { const g = _n.navigator.userAgent; (-1 !== g.indexOf("MSIE ") || -1 !== g.indexOf("Trident/") || -1 !== g.indexOf("Edge/")) && (fs = !0) } catch { } return fs } Zone.__load_patch("ZoneAwarePromise", (g, y, M) => { const v = Object.getOwnPropertyDescriptor, x = Object.defineProperty, G = M.symbol, q = [], de = !0 === g[G("DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION")], oe = G("Promise"), Y = G("then"); M.onUnhandledError = F => { if (M.showUncaughtError()) { const N = F && F.rejection; N ? console.error("Unhandled Promise rejection:", N instanceof Error ? N.message : N, "; Zone:", F.zone.name, "; Task:", F.task && F.task.source, "; Value:", N, N instanceof Error ? N.stack : void 0) : console.error(F) } }, M.microtaskDrainDone = () => { for (; q.length;) { const F = q.shift(); try { F.zone.runGuarded(() => { throw F.throwOriginal ? F.rejection : F }) } catch (N) { Te(N) } } }; const we = G("unhandledPromiseRejectionHandler"); function Te(F) { M.onUnhandledError(F); try { const N = y[we]; "function" == typeof N && N.call(this, F) } catch { } } function ot(F) { return F && F.then } function Be(F) { return F } function Bt(F) { return p.reject(F) } const gt = G("state"), fe = G("value"), $ = G("finally"), Ft = G("parentPromiseValue"), ze = G("parentPromiseState"), He = null, W = !0, tt = !1; function xe(F, N) { return D => { try { Dt(F, N, D) } catch (O) { Dt(F, !1, O) } } } const ce = function () { let F = !1; return function (D) { return function () { F || (F = !0, D.apply(null, arguments)) } } }, Nt = G("currentTaskTrace"); function Dt(F, N, D) { const O = ce(); if (F === D) throw new TypeError("Promise resolved with itself"); if (F[gt] === He) { let Q = null; try { ("object" == typeof D || "function" == typeof D) && (Q = D && D.then) } catch (ne) { return O(() => { Dt(F, !1, ne) })(), F } if (N !== tt && D instanceof p && D.hasOwnProperty(gt) && D.hasOwnProperty(fe) && D[gt] !== He) vn(D), Dt(F, D[gt], D[fe]); else if (N !== tt && "function" == typeof Q) try { Q.call(D, O(xe(F, N)), O(xe(F, !1))) } catch (ne) { O(() => { Dt(F, !1, ne) })() } else { F[gt] = N; const ne = F[fe]; if (F[fe] = D, F[$] === $ && N === W && (F[gt] = F[ze], F[fe] = F[Ft]), N === tt && D instanceof Error) { const U = y.currentTask && y.currentTask.data && y.currentTask.data.__creationTrace__; U && x(D, Nt, { configurable: !0, enumerable: !1, writable: !0, value: U }) } for (let U = 0; U < ne.length;)xt(F, ne[U++], ne[U++], ne[U++], ne[U++]); if (0 == ne.length && N == tt) { F[gt] = 0; let U = D; try { throw new Error("Uncaught (in promise): " + function S(F) { return F && F.toString === Object.prototype.toString ? (F.constructor && F.constructor.name || "") + ": " + JSON.stringify(F) : F ? F.toString() : Object.prototype.toString.call(F) }(D) + (D && D.stack ? "\n" + D.stack : "")) } catch (_e) { U = _e } de && (U.throwOriginal = !0), U.rejection = D, U.promise = F, U.zone = y.current, U.task = y.currentTask, q.push(U), M.scheduleMicroTask() } } } return F } const st = G("rejectionHandledHandler"); function vn(F) { if (0 === F[gt]) { try { const N = y[st]; N && "function" == typeof N && N.call(this, { rejection: F[fe], promise: F }) } catch { } F[gt] = tt; for (let N = 0; N < q.length; N++)F === q[N].promise && q.splice(N, 1) } } function xt(F, N, D, O, Q) { vn(F); const ne = F[gt], U = ne ? "function" == typeof O ? O : Be : "function" == typeof Q ? Q : Bt; N.scheduleMicroTask("Promise.then", () => { try { const _e = F[fe], le = !!D && $ === D[$]; le && (D[Ft] = _e, D[ze] = ne); const me = N.run(U, void 0, le && U !== Bt && U !== Be ? [] : [_e]); Dt(D, !0, me) } catch (_e) { Dt(D, !1, _e) } }, D) } const Ie = function () { }, z = g.AggregateError; class p { static toString() { return "function ZoneAwarePromise() { [native code] }" } static resolve(N) { return Dt(new this(null), W, N) } static reject(N) { return Dt(new this(null), tt, N) } static any(N) { if (!N || "function" != typeof N[Symbol.iterator]) return Promise.reject(new z([], "All promises were rejected")); const D = []; let O = 0; try { for (let U of N) O++, D.push(p.resolve(U)) } catch { return Promise.reject(new z([], "All promises were rejected")) } if (0 === O) return Promise.reject(new z([], "All promises were rejected")); let Q = !1; const ne = []; return new p((U, _e) => { for (let le = 0; le < D.length; le++)D[le].then(me => { Q || (Q = !0, U(me)) }, me => { ne.push(me), O--, 0 === O && (Q = !0, _e(new z(ne, "All promises were rejected"))) }) }) } static race(N) { let D, O, Q = new this((_e, le) => { D = _e, O = le }); function ne(_e) { D(_e) } function U(_e) { O(_e) } for (let _e of N) ot(_e) || (_e = this.resolve(_e)), _e.then(ne, U); return Q } static all(N) { return p.allWithCallback(N) } static allSettled(N) { return (this && this.prototype instanceof p ? this : p).allWithCallback(N, { thenCallback: O => ({ status: "fulfilled", value: O }), errorCallback: O => ({ status: "rejected", reason: O }) }) } static allWithCallback(N, D) { let O, Q, ne = new this((me, We) => { O = me, Q = We }), U = 2, _e = 0; const le = []; for (let me of N) { ot(me) || (me = this.resolve(me)); const We = _e; try { me.then(nt => { le[We] = D ? D.thenCallback(nt) : nt, U--, 0 === U && O(le) }, nt => { D ? (le[We] = D.errorCallback(nt), U--, 0 === U && O(le)) : Q(nt) }) } catch (nt) { Q(nt) } U++, _e++ } return U -= 2, 0 === U && O(le), ne } constructor(N) { const D = this; if (!(D instanceof p)) throw new Error("Must be an instanceof Promise."); D[gt] = He, D[fe] = []; try { const O = ce(); N && N(O(xe(D, W)), O(xe(D, tt))) } catch (O) { Dt(D, !1, O) } } get [Symbol.toStringTag]() { return "Promise" } get [Symbol.species]() { return p } then(N, D) { var O; let Q = null === (O = this.constructor) || void 0 === O ? void 0 : O[Symbol.species]; (!Q || "function" != typeof Q) && (Q = this.constructor || p); const ne = new Q(Ie), U = y.current; return this[gt] == He ? this[fe].push(U, ne, N, D) : xt(this, U, ne, N, D), ne } catch(N) { return this.then(null, N) } finally(N) { var D; let O = null === (D = this.constructor) || void 0 === D ? void 0 : D[Symbol.species]; (!O || "function" != typeof O) && (O = p); const Q = new O(Ie); Q[$] = $; const ne = y.current; return this[gt] == He ? this[fe].push(ne, Q, N, N) : xt(this, ne, Q, N, N), Q } } p.resolve = p.resolve, p.reject = p.reject, p.race = p.race, p.all = p.all; const _ = g[oe] = g.Promise; g.Promise = p; const X = G("thenPatched"); function ye(F) { const N = F.prototype, D = v(N, "then"); if (D && (!1 === D.writable || !D.configurable)) return; const O = N.then; N[Y] = O, F.prototype.then = function (Q, ne) { return new p((_e, le) => { O.call(this, _e, le) }).then(Q, ne) }, F[X] = !0 } return M.patchThen = ye, _ && (ye(_), qe(g, "fetch", F => function kt(F) { return function (N, D) { let O = F.apply(N, D); if (O instanceof p) return O; let Q = O.constructor; return Q[X] || ye(Q), O } }(F))), Promise[y.__symbol__("uncaughtPromiseErrors")] = q, p }), Zone.__load_patch("toString", g => { const y = Function.prototype.toString, M = $e("OriginalDelegate"), v = $e("Promise"), x = $e("Error"), S = function () { if ("function" == typeof this) { const oe = this[M]; if (oe) return "function" == typeof oe ? y.call(oe) : Object.prototype.toString.call(oe); if (this === Promise) { const Y = g[v]; if (Y) return y.call(Y) } if (this === Error) { const Y = g[x]; if (Y) return y.call(Y) } } return y.call(this) }; S[M] = y, Function.prototype.toString = S; const G = Object.prototype.toString; Object.prototype.toString = function () { return "function" == typeof Promise && this instanceof Promise ? "[object Promise]" : G.call(this) } }); let ii = !1; if (typeof window < "u") try { const g = Object.defineProperty({}, "passive", { get: function () { ii = !0 } }); window.addEventListener("test", g, g), window.removeEventListener("test", g, g) } catch { ii = !1 } const Wt = { useG: !0 }, et = {}, ja = {}, Br = new RegExp("^" + Pr + "(\\w+)(true|false)$"), ao = $e("propagationStopped"); function wu(g, y) { const M = (y ? y(g) : g) + jn, v = (y ? y(g) : g) + yn, x = Pr + M, S = Pr + v; et[g] = {}, et[g][jn] = x, et[g][yn] = S } function $a(g, y, M, v) { const x = v && v.add || no, S = v && v.rm || ro, G = v && v.listeners || "eventListeners", q = v && v.rmAll || "removeAllListeners", de = $e(x), oe = "." + x + ":", we = function (fe, $, Ft) { if (fe.isRemoved) return; const ze = fe.callback; let Ue; "object" == typeof ze && ze.handleEvent && (fe.callback = W => ze.handleEvent(W), fe.originalDelegate = ze); try { fe.invoke(fe, $, [Ft]) } catch (W) { Ue = W } const He = fe.options; return He && "object" == typeof He && He.once && $[S].call($, Ft.type, fe.originalDelegate ? fe.originalDelegate : fe.callback, He), Ue }; function Te(fe, $, Ft) { if (!($ = $ || g.event)) return; const ze = fe || $.target || g, Ue = ze[et[$.type][Ft ? yn : jn]]; if (Ue) { const He = []; if (1 === Ue.length) { const W = we(Ue[0], ze, $); W && He.push(W) } else { const W = Ue.slice(); for (let tt = 0; tt < W.length && (!$ || !0 !== $[ao]); tt++) { const j = we(W[tt], ze, $); j && He.push(j) } } if (1 === He.length) throw He[0]; for (let W = 0; W < He.length; W++) { const tt = He[W]; y.nativeScheduleMicroTask(() => { throw tt }) } } } const ot = function (fe) { return Te(this, fe, !1) }, Be = function (fe) { return Te(this, fe, !0) }; function Bt(fe, $) { if (!fe) return !1; let Ft = !0; $ && void 0 !== $.useG && (Ft = $.useG); const ze = $ && $.vh; let Ue = !0; $ && void 0 !== $.chkDup && (Ue = $.chkDup); let He = !1; $ && void 0 !== $.rt && (He = $.rt); let W = fe; for (; W && !W.hasOwnProperty(x);)W = Jn(W); if (!W && fe[x] && (W = fe), !W || W[de]) return !1; const tt = $ && $.eventNameToString, j = {}, xe = W[de] = W[x], ce = W[$e(S)] = W[S], Zt = W[$e(G)] = W[G], Nt = W[$e(q)] = W[q]; let Dt; function st(D, O) { return !ii && "object" == typeof D && D ? !!D.capture : ii && O ? "boolean" == typeof D ? { capture: D, passive: !0 } : D ? "object" == typeof D && !1 !== D.passive ? Object.assign(Object.assign({}, D), { passive: !0 }) : D : { passive: !0 } : D } $ && $.prepend && (Dt = W[$e($.prepend)] = W[$.prepend]); const p = Ft ? function (D) { if (!j.isExisting) return xe.call(j.target, j.eventName, j.capture ? Be : ot, j.options) } : function (D) { return xe.call(j.target, j.eventName, D.invoke, j.options) }, _ = Ft ? function (D) { if (!D.isRemoved) { const O = et[D.eventName]; let Q; O && (Q = O[D.capture ? yn : jn]); const ne = Q && D.target[Q]; if (ne) for (let U = 0; U < ne.length; U++)if (ne[U] === D) { ne.splice(U, 1), D.isRemoved = !0, 0 === ne.length && (D.allRemoved = !0, D.target[Q] = null); break } } if (D.allRemoved) return ce.call(D.target, D.eventName, D.capture ? Be : ot, D.options) } : function (D) { return ce.call(D.target, D.eventName, D.invoke, D.options) }, ye = $ && $.diff ? $.diff : function (D, O) { const Q = typeof O; return "function" === Q && D.callback === O || "object" === Q && D.originalDelegate === O }, kt = Zone[$e("UNPATCHED_EVENTS")], F = g[$e("PASSIVE_EVENTS")], N = function (D, O, Q, ne, U = !1, _e = !1) { return function () { const le = this || g; let me = arguments[0]; $ && $.transferEventName && (me = $.transferEventName(me)); let We = arguments[1]; if (!We) return D.apply(this, arguments); if (Lr && "uncaughtException" === me) return D.apply(this, arguments); let nt = !1; if ("function" != typeof We) { if (!We.handleEvent) return D.apply(this, arguments); nt = !0 } if (ze && !ze(D, We, le, arguments)) return; const zn = ii && !!F && -1 !== F.indexOf(me), ke = st(arguments[2], zn); if (kt) for (let jr = 0; jr < kt.length; jr++)if (me === kt[jr]) return zn ? D.call(le, me, We, ke) : D.apply(this, arguments); const Ci = !!ke && ("boolean" == typeof ke || ke.capture), Ze = !(!ke || "object" != typeof ke) && ke.once, ms = Zone.current; let ps = et[me]; ps || (wu(me, tt), ps = et[me]); const Je = ps[Ci ? yn : jn]; let gs, J = le[Je], lo = !1; if (J) { if (lo = !0, Ue) for (let jr = 0; jr < J.length; jr++)if (ye(J[jr], We)) return } else J = le[Je] = []; const P = le.constructor.name, Mi = ja[P]; Mi && (gs = Mi[me]), gs || (gs = P + O + (tt ? tt(me) : me)), j.options = ke, Ze && (j.options.once = !1), j.target = le, j.capture = Ci, j.eventName = me, j.isExisting = lo; const ie = Ft ? Wt : void 0; ie && (ie.taskData = j); const Me = ms.scheduleEventTask(gs, We, ie, Q, ne); return j.target = null, ie && (ie.taskData = null), Ze && (ke.once = !0), !ii && "boolean" == typeof Me.options || (Me.options = ke), Me.target = le, Me.capture = Ci, Me.eventName = me, nt && (Me.originalDelegate = We), _e ? J.unshift(Me) : J.push(Me), U ? le : void 0 } }; return W[x] = N(xe, oe, p, _, He), Dt && (W.prependListener = N(Dt, ".prependListener:", function (D) { return Dt.call(j.target, j.eventName, D.invoke, j.options) }, _, He, !0)), W[S] = function () { const D = this || g; let O = arguments[0]; $ && $.transferEventName && (O = $.transferEventName(O)); const Q = arguments[2], ne = !!Q && ("boolean" == typeof Q || Q.capture), U = arguments[1]; if (!U) return ce.apply(this, arguments); if (ze && !ze(ce, U, D, arguments)) return; const _e = et[O]; let le; _e && (le = _e[ne ? yn : jn]); const me = le && D[le]; if (me) for (let We = 0; We < me.length; We++) { const nt = me[We]; if (ye(nt, U)) return me.splice(We, 1), nt.isRemoved = !0, 0 === me.length && (nt.allRemoved = !0, D[le] = null, "string" == typeof O) && (D[Pr + "ON_PROPERTY" + O] = null), nt.zone.cancelTask(nt), He ? D : void 0 } return ce.apply(this, arguments) }, W[G] = function () { const D = this || g; let O = arguments[0]; $ && $.transferEventName && (O = $.transferEventName(O)); const Q = [], ne = Du(D, tt ? tt(O) : O); for (let U = 0; U < ne.length; U++) { const _e = ne[U]; Q.push(_e.originalDelegate ? _e.originalDelegate : _e.callback) } return Q }, W[q] = function () { const D = this || g; let O = arguments[0]; if (O) { $ && $.transferEventName && (O = $.transferEventName(O)); const Q = et[O]; if (Q) { const _e = D[Q[jn]], le = D[Q[yn]]; if (_e) { const me = _e.slice(); for (let We = 0; We < me.length; We++) { const nt = me[We]; this[S].call(this, O, nt.originalDelegate ? nt.originalDelegate : nt.callback, nt.options) } } if (le) { const me = le.slice(); for (let We = 0; We < me.length; We++) { const nt = me[We]; this[S].call(this, O, nt.originalDelegate ? nt.originalDelegate : nt.callback, nt.options) } } } } else { const Q = Object.keys(D); for (let ne = 0; ne < Q.length; ne++) { const _e = Br.exec(Q[ne]); let le = _e && _e[1]; le && "removeListener" !== le && this[q].call(this, le) } this[q].call(this, "removeListener") } if (He) return this }, tr(W[x], xe), tr(W[S], ce), Nt && tr(W[q], Nt), Zt && tr(W[G], Zt), !0 } let gt = []; for (let fe = 0; fe < M.length; fe++)gt[fe] = Bt(M[fe], v); return gt } function Du(g, y) { if (!y) { const S = []; for (let G in g) { const q = Br.exec(G); let de = q && q[1]; if (de && (!y || de === y)) { const oe = g[G]; if (oe) for (let Y = 0; Y < oe.length; Y++)S.push(oe[Y]) } } return S } let M = et[y]; M || (wu(y), M = et[y]); const v = g[M[jn]], x = g[M[yn]]; return v ? x ? v.concat(x) : v.slice() : x ? x.slice() : [] } function Bm(g, y) { const M = g.Event; M && M.prototype && y.patchMethod(M.prototype, "stopImmediatePropagation", v => function (x, S) { x[ao] = !0, v && v.apply(x, S) }) } function Hm(g, y, M, v, x) { const S = Zone.__symbol__(v); if (y[S]) return; const G = y[S] = y[v]; y[v] = function (q, de, oe) { return de && de.prototype && x.forEach(function (Y) { const Re = `${M}.${v}::` + Y, we = de.prototype; try { if (we.hasOwnProperty(Y)) { const Te = g.ObjectGetOwnPropertyDescriptor(we, Y); Te && Te.value ? (Te.value = g.wrapWithCurrentZone(Te.value, Re), g._redefineProperty(de.prototype, Y, Te)) : we[Y] && (we[Y] = g.wrapWithCurrentZone(we[Y], Re)) } else we[Y] && (we[Y] = g.wrapWithCurrentZone(we[Y], Re)) } catch { } }), G.call(y, q, de, oe) }, g.attachOriginToPatched(y[v], G) } function Eu(g, y, M) { if (!M || 0 === M.length) return y; const v = M.filter(S => S.target === g); if (!v || 0 === v.length) return y; const x = v[0].ignoreProperties; return y.filter(S => -1 === x.indexOf(S)) } function za(g, y, M, v) { g && Vr(g, Eu(g, y, M), v) } function Ua(g) { return Object.getOwnPropertyNames(g).filter(y => y.startsWith("on") && y.length > 2).map(y => y.substring(2)) } Zone.__load_patch("util", (g, y, M) => { const v = Ua(g); M.patchOnProperties = Vr, M.patchMethod = qe, M.bindArguments = Ei, M.patchMacroTask = Va; const x = y.__symbol__("BLACK_LISTED_EVENTS"), S = y.__symbol__("UNPATCHED_EVENTS"); g[S] && (g[x] = g[S]), g[x] && (y[x] = y[S] = g[x]), M.patchEventPrototype = Bm, M.patchEventTarget = $a, M.isIEOrEdge = Ha, M.ObjectDefineProperty = Rr, M.ObjectGetOwnPropertyDescriptor = Ce, M.ObjectCreate = to, M.ArraySlice = ln, M.patchClass = ri, M.wrapWithCurrentZone = us, M.filterProperties = Eu, M.attachOriginToPatched = tr, M._redefineProperty = Object.defineProperty, M.patchCallbacks = Hm, M.getGlobalObjects = () => ({ globalSources: ja, zoneSymbolEventNames: et, eventNames: v, isBrowser: ti, isMix: Pa, isNode: Lr, TRUE_STR: yn, FALSE_STR: jn, ZONE_SYMBOL_PREFIX: Pr, ADD_EVENT_LISTENER_STR: no, REMOVE_EVENT_LISTENER_STR: ro }) }); const hs = $e("zoneTask"); function Hr(g, y, M, v) { let x = null, S = null; M += v; const G = {}; function q(oe) { const Y = oe.data; return Y.args[0] = function () { return oe.invoke.apply(this, arguments) }, Y.handleId = x.apply(g, Y.args), oe } function de(oe) { return S.call(g, oe.data.handleId) } x = qe(g, y += v, oe => function (Y, Re) { if ("function" == typeof Re[0]) { const we = { isPeriodic: "Interval" === v, delay: "Timeout" === v || "Interval" === v ? Re[1] || 0 : void 0, args: Re }, Te = Re[0]; Re[0] = function () { try { return Te.apply(this, arguments) } finally { we.isPeriodic || ("number" == typeof we.handleId ? delete G[we.handleId] : we.handleId && (we.handleId[hs] = null)) } }; const ot = ds(y, Re[0], we, q, de); if (!ot) return ot; const Be = ot.data.handleId; return "number" == typeof Be ? G[Be] = ot : Be && (Be[hs] = ot), Be && Be.ref && Be.unref && "function" == typeof Be.ref && "function" == typeof Be.unref && (ot.ref = Be.ref.bind(Be), ot.unref = Be.unref.bind(Be)), "number" == typeof Be || Be ? Be : ot } return oe.apply(g, Re) }), S = qe(g, M, oe => function (Y, Re) { const we = Re[0]; let Te; "number" == typeof we ? Te = G[we] : (Te = we && we[hs], Te || (Te = we)), Te && "string" == typeof Te.type ? "notScheduled" !== Te.state && (Te.cancelFn && Te.data.isPeriodic || 0 === Te.runCount) && ("number" == typeof we ? delete G[we] : we && (we[hs] = null), Te.zone.cancelTask(Te)) : oe.apply(g, Re) }) } Zone.__load_patch("legacy", g => { const y = g[Zone.__symbol__("legacyPatch")]; y && y() }), Zone.__load_patch("queueMicrotask", (g, y, M) => { M.patchMethod(g, "queueMicrotask", v => function (x, S) { y.current.scheduleMicroTask("queueMicrotask", S[0]) }) }), Zone.__load_patch("timers", g => { const y = "set", M = "clear"; Hr(g, y, M, "Timeout"), Hr(g, y, M, "Interval"), Hr(g, y, M, "Immediate") }), Zone.__load_patch("requestAnimationFrame", g => { Hr(g, "request", "cancel", "AnimationFrame"), Hr(g, "mozRequest", "mozCancel", "AnimationFrame"), Hr(g, "webkitRequest", "webkitCancel", "AnimationFrame") }), Zone.__load_patch("blocking", (g, y) => { const M = ["alert", "prompt", "confirm"]; for (let v = 0; v < M.length; v++)qe(g, M[v], (S, G, q) => function (de, oe) { return y.current.run(S, g, oe, q) }) }), Zone.__load_patch("EventTarget", (g, y, M) => { (function $m(g, y) { y.patchEventPrototype(g, y) })(g, M), function jm(g, y) { if (Zone[y.symbol("patchEventTarget")]) return; const { eventNames: M, zoneSymbolEventNames: v, TRUE_STR: x, FALSE_STR: S, ZONE_SYMBOL_PREFIX: G } = y.getGlobalObjects(); for (let de = 0; de < M.length; de++) { const oe = M[de], we = G + (oe + S), Te = G + (oe + x); v[oe] = {}, v[oe][S] = we, v[oe][x] = Te } const q = g.EventTarget; q && q.prototype && y.patchEventTarget(g, y, [q && q.prototype]) }(g, M); const v = g.XMLHttpRequestEventTarget; v && v.prototype && M.patchEventTarget(g, M, [v.prototype]) }), Zone.__load_patch("MutationObserver", (g, y, M) => { ri("MutationObserver"), ri("WebKitMutationObserver") }), Zone.__load_patch("IntersectionObserver", (g, y, M) => { ri("IntersectionObserver") }), Zone.__load_patch("FileReader", (g, y, M) => { ri("FileReader") }), Zone.__load_patch("on_property", (g, y, M) => { !function Ga(g, y) { if (Lr && !Pa || Zone[g.symbol("patchEvents")]) return; const M = y.__Zone_ignore_on_properties; let v = []; if (ti) { const x = window; v = v.concat(["Document", "SVGElement", "Element", "HTMLElement", "HTMLBodyElement", "HTMLMediaElement", "HTMLFrameSetElement", "HTMLFrameElement", "HTMLIFrameElement", "HTMLMarqueeElement", "Worker"]); const S = function Qt() { try { const g = _n.navigator.userAgent; if (-1 !== g.indexOf("MSIE ") || -1 !== g.indexOf("Trident/")) return !0 } catch { } return !1 }() ? [{ target: x, ignoreProperties: ["error"] }] : []; za(x, Ua(x), M && M.concat(S), Jn(x)) } v = v.concat(["XMLHttpRequest", "XMLHttpRequestEventTarget", "IDBIndex", "IDBRequest", "IDBOpenDBRequest", "IDBDatabase", "IDBTransaction", "IDBCursor", "WebSocket"]); for (let x = 0; x < v.length; x++) { const S = y[v[x]]; S && S.prototype && za(S.prototype, Ua(S.prototype), M) } }(M, g) }), Zone.__load_patch("customElements", (g, y, M) => { !function Cu(g, y) { const { isBrowser: M, isMix: v } = y.getGlobalObjects(); (M || v) && g.customElements && "customElements" in g && y.patchCallbacks(y, g.customElements, "customElements", "define", ["connectedCallback", "disconnectedCallback", "adoptedCallback", "attributeChangedCallback"]) }(g, M) }), Zone.__load_patch("XHR", (g, y) => { !function de(oe) { const Y = oe.XMLHttpRequest; if (!Y) return; const Re = Y.prototype; let Te = Re[io], ot = Re[er]; if (!Te) { const j = oe.XMLHttpRequestEventTarget; if (j) { const xe = j.prototype; Te = xe[io], ot = xe[er] } } const Be = "readystatechange", Bt = "scheduled"; function gt(j) { const xe = j.data, ce = xe.target; ce[S] = !1, ce[q] = !1; const Zt = ce[x]; Te || (Te = ce[io], ot = ce[er]), Zt && ot.call(ce, Be, Zt); const Nt = ce[x] = () => { if (ce.readyState === ce.DONE) if (!xe.aborted && ce[S] && j.state === Bt) { const st = ce[y.__symbol__("loadfalse")]; if (0 !== ce.status && st && st.length > 0) { const vn = j.invoke; j.invoke = function () { const xt = ce[y.__symbol__("loadfalse")]; for (let bt = 0; bt < xt.length; bt++)xt[bt] === j && xt.splice(bt, 1); !xe.aborted && j.state === Bt && vn.call(j) }, st.push(j) } else j.invoke() } else !xe.aborted && !1 === ce[S] && (ce[q] = !0) }; return Te.call(ce, Be, Nt), ce[M] || (ce[M] = j), W.apply(ce, xe.args), ce[S] = !0, j } function fe() { } function $(j) { const xe = j.data; return xe.aborted = !0, tt.apply(xe.target, xe.args) } const Ft = qe(Re, "open", () => function (j, xe) { return j[v] = 0 == xe[2], j[G] = xe[1], Ft.apply(j, xe) }), Ue = $e("fetchTaskAborting"), He = $e("fetchTaskScheduling"), W = qe(Re, "send", () => function (j, xe) { if (!0 === y.current[He] || j[v]) return W.apply(j, xe); { const ce = { target: j, url: j[G], isPeriodic: !1, args: xe, aborted: !1 }, Zt = ds("XMLHttpRequest.send", fe, ce, gt, $); j && !0 === j[q] && !ce.aborted && Zt.state === Bt && Zt.invoke() } }), tt = qe(Re, "abort", () => function (j, xe) { const ce = function we(j) { return j[M] }(j); if (ce && "string" == typeof ce.type) { if (null == ce.cancelFn || ce.data && ce.data.aborted) return; ce.zone.cancelTask(ce) } else if (!0 === y.current[Ue]) return tt.apply(j, xe) }) }(g); const M = $e("xhrTask"), v = $e("xhrSync"), x = $e("xhrListener"), S = $e("xhrScheduled"), G = $e("xhrURL"), q = $e("xhrErrorBeforeScheduled") }), Zone.__load_patch("geolocation", g => { g.navigator && g.navigator.geolocation && function vu(g, y) { const M = g.constructor.name; for (let v = 0; v < y.length; v++) { const x = y[v], S = g[x]; if (S) { if (!oo(Ce(g, x))) continue; g[x] = (q => { const de = function () { return q.apply(this, Ei(arguments, M + "." + x)) }; return tr(de, q), de })(S) } } }(g.navigator.geolocation, ["getCurrentPosition", "watchPosition"]) }), Zone.__load_patch("PromiseRejectionEvent", (g, y) => { function M(v) { return function (x) { Du(g, v).forEach(G => { const q = g.PromiseRejectionEvent; if (q) { const de = new q(v, { promise: x.promise, reason: x.rejection }); G.invoke(de) } }) } } g.PromiseRejectionEvent && (y[$e("unhandledPromiseRejectionHandler")] = M("unhandledrejection"), y[$e("rejectionHandledHandler")] = M("rejectionhandled")) }) } }, Lm = {}; function Vm(Ce) { var Rr = Lm[Ce]; if (void 0 !== Rr) return Rr.exports; var Jn = Lm[Ce] = { exports: {} }; return wE[Ce](Jn, Jn.exports, Vm), Jn.exports } (() => { function Ce(t) { return "function" == typeof t } function Rr(t) { const n = t(r => { Error.call(r), r.stack = (new Error).stack }); return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n } const Jn = Rr(t => function (n) { t(this), this.message = n ? `${n.length} errors occurred during unsubscription:\n${n.map((r, i) => `${i + 1}) ${r.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = n }); function to(t, e) { if (t) { const n = t.indexOf(e); 0 <= n && t.splice(n, 1) } } class ln { constructor(e) { this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let e; if (!this.closed) { this.closed = !0; const { _parentage: n } = this; if (n) if (this._parentage = null, Array.isArray(n)) for (const o of n) o.remove(this); else n.remove(this); const { initialTeardown: r } = this; if (Ce(r)) try { r() } catch (o) { e = o instanceof Jn ? o.errors : [o] } const { _finalizers: i } = this; if (i) { this._finalizers = null; for (const o of i) try { io(o) } catch (s) { e = e ?? [], s instanceof Jn ? e = [...e, ...s.errors] : e.push(s) } } if (e) throw new Jn(e) } } add(e) { var n; if (e && e !== this) if (this.closed) io(e); else { if (e instanceof ln) { if (e.closed || e._hasParent(this)) return; e._addParent(this) } (this._finalizers = null !== (n = this._finalizers) && void 0 !== n ? n : []).push(e) } } _hasParent(e) { const { _parentage: n } = this; return n === e || Array.isArray(n) && n.includes(e) } _addParent(e) { const { _parentage: n } = this; this._parentage = Array.isArray(n) ? (n.push(e), n) : n ? [n, e] : e } _removeParent(e) { const { _parentage: n } = this; n === e ? this._parentage = null : Array.isArray(n) && to(n, e) } remove(e) { const { _finalizers: n } = this; n && to(n, e), e instanceof ln && e._removeParent(this) } } ln.EMPTY = (() => { const t = new ln; return t.closed = !0, t })(); const no = ln.EMPTY; function ro(t) { return t instanceof ln || t && "closed" in t && Ce(t.remove) && Ce(t.add) && Ce(t.unsubscribe) } function io(t) { Ce(t) ? t() : t.unsubscribe() } const er = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, yn = { setTimeout(t, e, ...n) { const { delegate: r } = yn; return r?.setTimeout ? r.setTimeout(t, e, ...n) : setTimeout(t, e, ...n) }, clearTimeout(t) { const { delegate: e } = yn; return (e?.clearTimeout || clearTimeout)(t) }, delegate: void 0 }; function jn(t) { yn.setTimeout(() => { const { onUnhandledError: e } = er; if (!e) throw t; e(t) }) } function Pr() { } const us = ei("C", void 0, void 0); function ei(t, e, n) { return { kind: t, value: e, error: n } } let _n = null; function pt(t) { if (er.useDeprecatedSynchronousErrorHandling) { const e = !_n; if (e && (_n = { errorThrown: !1, error: null }), t(), e) { const { errorThrown: n, error: r } = _n; if (_n = null, n) throw r } } else t() } class Ei extends ln { constructor(e) { super(), this.isStopped = !1, e ? (this.destination = e, ro(e) && e.add(this)) : this.destination = La } static create(e, n, r) { return new Lr(e, n, r) } next(e) { this.isStopped ? ni(function $e(t) { return ei("N", t, void 0) }(e), this) : this._next(e) } error(e) { this.isStopped ? ni(function ds(t) { return ei("E", void 0, t) }(e), this) : (this.isStopped = !0, this._error(e)) } complete() { this.isStopped ? ni(us, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(e) { this.destination.next(e) } _error(e) { try { this.destination.error(e) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const vu = Function.prototype.bind; function oo(t, e) { return vu.call(t, e) } class Ra { constructor(e) { this.partialObserver = e } next(e) { const { partialObserver: n } = this; if (n.next) try { n.next(e) } catch (r) { ti(r) } } error(e) { const { partialObserver: n } = this; if (n.error) try { n.error(e) } catch (r) { ti(r) } else ti(e) } complete() { const { partialObserver: e } = this; if (e.complete) try { e.complete() } catch (n) { ti(n) } } } class Lr extends Ei { constructor(e, n, r) { let i; if (super(), Ce(e) || !e) i = { next: e ?? void 0, error: n ?? void 0, complete: r ?? void 0 }; else { let o; this && er.useDeprecatedNextContext ? (o = Object.create(e), o.unsubscribe = () => this.unsubscribe(), i = { next: e.next && oo(e.next, o), error: e.error && oo(e.error, o), complete: e.complete && oo(e.complete, o) }) : i = e } this.destination = new Ra(i) } } function ti(t) { er.useDeprecatedSynchronousErrorHandling ? function _u(t) { er.useDeprecatedSynchronousErrorHandling && _n && (_n.errorThrown = !0, _n.error = t) }(t) : jn(t) } function ni(t, e) { const { onStoppedNotification: n } = er; n && yn.setTimeout(() => n(t, e)) } const La = { closed: !0, next: Pr, error: function Pa(t) { throw t }, complete: Pr }, so = "function" == typeof Symbol && Symbol.observable || "@@observable"; function Vr(t) { return t } let qe = (() => { class t { constructor(n) { n && (this._subscribe = n) } lift(n) { const r = new t; return r.source = this, r.operator = n, r } subscribe(n, r, i) { const o = function Ba(t) { return t && t instanceof Ei || function tr(t) { return t && Ce(t.next) && Ce(t.error) && Ce(t.complete) }(t) && ro(t) }(n) ? n : new Lr(n, r, i); return pt(() => { const { operator: s, source: a } = this; o.add(s ? s.call(o, a) : a ? this._subscribe(o) : this._trySubscribe(o)) }), o } _trySubscribe(n) { try { return this._subscribe(n) } catch (r) { n.error(r) } } forEach(n, r) { return new (r = Va(r))((i, o) => { const s = new Lr({ next: a => { try { n(a) } catch (l) { o(l), s.unsubscribe() } }, error: o, complete: i }); this.subscribe(s) }) } _subscribe(n) { var r; return null === (r = this.source) || void 0 === r ? void 0 : r.subscribe(n) } [so]() { return this } pipe(...n) { return function ri(t) { return 0 === t.length ? Vr : 1 === t.length ? t[0] : function (n) { return t.reduce((r, i) => i(r), n) } }(n)(this) } toPromise(n) { return new (n = Va(n))((r, i) => { let o; this.subscribe(s => o = s, s => i(s), () => r(o)) }) } } return t.create = e => new t(e), t })(); function Va(t) { var e; return null !== (e = t ?? er.Promise) && void 0 !== e ? e : Promise } const fs = Rr(t => function () { t(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let Qt = (() => { class t extends qe { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(n) { const r = new Ha(this, this); return r.operator = n, r } _throwIfClosed() { if (this.closed) throw new fs } next(n) { pt(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (const r of this.currentObservers) r.next(n) } }) } error(n) { pt(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = n; const { observers: r } = this; for (; r.length;)r.shift().error(n) } }) } complete() { pt(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: n } = this; for (; n.length;)n.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var n; return (null === (n = this.observers) || void 0 === n ? void 0 : n.length) > 0 } _trySubscribe(n) { return this._throwIfClosed(), super._trySubscribe(n) } _subscribe(n) { return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n) } _innerSubscribe(n) { const { hasError: r, isStopped: i, observers: o } = this; return r || i ? no : (this.currentObservers = null, o.push(n), new ln(() => { this.currentObservers = null, to(o, n) })) } _checkFinalizedStatuses(n) { const { hasError: r, thrownError: i, isStopped: o } = this; r ? n.error(i) : o && n.complete() } asObservable() { const n = new qe; return n.source = this, n } } return t.create = (e, n) => new Ha(e, n), t })(); class Ha extends Qt { constructor(e, n) { super(), this.destination = e, this.source = n } next(e) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.next) || void 0 === r || r.call(n, e) } error(e) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.error) || void 0 === r || r.call(n, e) } complete() { var e, n; null === (n = null === (e = this.destination) || void 0 === e ? void 0 : e.complete) || void 0 === n || n.call(e) } _subscribe(e) { var n, r; return null !== (r = null === (n = this.source) || void 0 === n ? void 0 : n.subscribe(e)) && void 0 !== r ? r : no } } function Wt(t) { return e => { if (function ii(t) { return Ce(t?.lift) }(e)) return e.lift(function (n) { try { return t(n, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } function et(t, e, n, r, i) { return new ja(t, e, n, r, i) } class ja extends Ei { constructor(e, n, r, i, o, s) { super(e), this.onFinalize = o, this.shouldUnsubscribe = s, this._next = n ? function (a) { try { n(a) } catch (l) { e.error(l) } } : super._next, this._error = i ? function (a) { try { i(a) } catch (l) { e.error(l) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (a) { e.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var e; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: n } = this; super.unsubscribe(), !n && (null === (e = this.onFinalize) || void 0 === e || e.call(this)) } } } function Br(t, e) { return Wt((n, r) => { let i = 0; n.subscribe(et(r, o => { r.next(t.call(e, o, i++)) })) }) } function y(t) { return this instanceof y ? (this.v = t, this) : new y(t) } function M(t, e, n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var i, r = n.apply(t, e || []), o = []; return i = {}, s("next"), s("throw"), s("return"), i[Symbol.asyncIterator] = function () { return this }, i; function s(f) { r[f] && (i[f] = function (h) { return new Promise(function (m, b) { o.push([f, h, m, b]) > 1 || a(f, h) }) }) } function a(f, h) { try { !function l(f) { f.value instanceof y ? Promise.resolve(f.value.v).then(c, u) : d(o[0][2], f) }(r[f](h)) } catch (m) { d(o[0][3], m) } } function c(f) { a("next", f) } function u(f) { a("throw", f) } function d(f, h) { f(h), o.shift(), o.length && a(o[0][0], o[0][1]) } } function x(t) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var n, e = t[Symbol.asyncIterator]; return e ? e.call(t) : (t = function Hr(t) { var e = "function" == typeof Symbol && Symbol.iterator, n = e && t[e], r = 0; if (n) return n.call(t); if (t && "number" == typeof t.length) return { next: function () { return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t } } }; throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.") }(t), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function () { return this }, n); function r(o) { n[o] = t[o] && function (s) { return new Promise(function (a, l) { !function i(o, s, a, l) { Promise.resolve(l).then(function (c) { o({ value: c, done: a }) }, s) }(a, l, (s = t[o](s)).done, s.value) }) } } } const we = t => t && "number" == typeof t.length && "function" != typeof t; function Te(t) { return Ce(t?.then) } function ot(t) { return Ce(t[so]) } function Be(t) { return Symbol.asyncIterator && Ce(t?.[Symbol.asyncIterator]) } function Bt(t) { return new TypeError(`You provided ${null !== t && "object" == typeof t ? "an invalid object" : `'${t}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const fe = function gt() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }(); function $(t) { return Ce(t?.[fe]) } function Ft(t) { return M(this, arguments, function* () { const n = t.getReader(); try { for (; ;) { const { value: r, done: i } = yield y(n.read()); if (i) return yield y(void 0); yield yield y(r) } } finally { n.releaseLock() } }) } function ze(t) { return Ce(t?.getReader) } function Ue(t) { if (t instanceof qe) return t; if (null != t) { if (ot(t)) return function He(t) { return new qe(e => { const n = t[so](); if (Ce(n.subscribe)) return n.subscribe(e); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(t); if (we(t)) return function W(t) { return new qe(e => { for (let n = 0; n < t.length && !e.closed; n++)e.next(t[n]); e.complete() }) }(t); if (Te(t)) return function tt(t) { return new qe(e => { t.then(n => { e.closed || (e.next(n), e.complete()) }, n => e.error(n)).then(null, jn) }) }(t); if (Be(t)) return xe(t); if ($(t)) return function j(t) { return new qe(e => { for (const n of t) if (e.next(n), e.closed) return; e.complete() }) }(t); if (ze(t)) return function ce(t) { return xe(Ft(t)) }(t) } throw Bt(t) } function xe(t) { return new qe(e => { (function Zt(t, e) { var n, r, i, o; return function za(t, e, n, r) { return new (n || (n = Promise))(function (o, s) { function a(u) { try { c(r.next(u)) } catch (d) { s(d) } } function l(u) { try { c(r.throw(u)) } catch (d) { s(d) } } function c(u) { u.done ? o(u.value) : function i(o) { return o instanceof n ? o : new n(function (s) { s(o) }) }(u.value).then(a, l) } c((r = r.apply(t, e || [])).next()) }) }(this, void 0, void 0, function* () { try { for (n = x(t); !(r = yield n.next()).done;)if (e.next(r.value), e.closed) return } catch (s) { i = { error: s } } finally { try { r && !r.done && (o = n.return) && (yield o.call(n)) } finally { if (i) throw i.error } } e.complete() }) })(t, e).catch(n => e.error(n)) }) } function Nt(t, e, n, r = 0, i = !1) { const o = e.schedule(function () { n(), i ? t.add(this.schedule(null, r)) : this.unsubscribe() }, r); if (t.add(o), !i) return o } function st(t, e, n = 1 / 0) { return Ce(e) ? st((r, i) => Br((o, s) => e(r, o, i, s))(Ue(t(r, i))), n) : ("number" == typeof e && (n = e), Wt((r, i) => function Dt(t, e, n, r, i, o, s, a) { const l = []; let c = 0, u = 0, d = !1; const f = () => { d && !l.length && !c && e.complete() }, h = b => c < r ? m(b) : l.push(b), m = b => { o && e.next(b), c++; let w = !1; Ue(n(b, u++)).subscribe(et(e, C => { i?.(C), o ? h(C) : e.next(C) }, () => { w = !0 }, void 0, () => { if (w) try { for (c--; l.length && c < r;) { const C = l.shift(); s ? Nt(e, s, () => m(C)) : m(C) } f() } catch (C) { e.error(C) } })) }; return t.subscribe(et(e, h, () => { d = !0, f() })), () => { a?.() } }(r, i, t, n))) } function vn(t = 1 / 0) { return st(Vr, t) } const xt = new qe(t => t.complete()); function p(t) { return t[t.length - 1] } function _(t) { return Ce(p(t)) ? t.pop() : void 0 } function X(t) { return function z(t) { return t && Ce(t.schedule) }(p(t)) ? t.pop() : void 0 } function kt(t, e = 0) { return Wt((n, r) => { n.subscribe(et(r, i => Nt(r, t, () => r.next(i), e), () => Nt(r, t, () => r.complete(), e), i => Nt(r, t, () => r.error(i), e))) }) } function F(t, e = 0) { return Wt((n, r) => { r.add(t.schedule(() => n.subscribe(r), e)) }) } function ne(t, e) { if (!t) throw new Error("Iterable cannot be null"); return new qe(n => { Nt(n, e, () => { const r = t[Symbol.asyncIterator](); Nt(n, e, () => { r.next().then(i => { i.done ? n.complete() : n.next(i.value) }) }, 0, !0) }) }) } function le(t, e) { return e ? function _e(t, e) { if (null != t) { if (ot(t)) return function N(t, e) { return Ue(t).pipe(F(e), kt(e)) }(t, e); if (we(t)) return function O(t, e) { return new qe(n => { let r = 0; return e.schedule(function () { r === t.length ? n.complete() : (n.next(t[r++]), n.closed || this.schedule()) }) }) }(t, e); if (Te(t)) return function D(t, e) { return Ue(t).pipe(F(e), kt(e)) }(t, e); if (Be(t)) return ne(t, e); if ($(t)) return function Q(t, e) { return new qe(n => { let r; return Nt(n, e, () => { r = t[fe](), Nt(n, e, () => { let i, o; try { ({ value: i, done: o } = r.next()) } catch (s) { return void n.error(s) } o ? n.complete() : n.next(i) }, 0, !0) }), () => Ce(r?.return) && r.return() }) }(t, e); if (ze(t)) return function U(t, e) { return ne(Ft(t), e) }(t, e) } throw Bt(t) }(t, e) : Ue(t) } function me(...t) { const e = X(t), n = function ye(t, e) { return "number" == typeof p(t) ? t.pop() : e }(t, 1 / 0), r = t; return r.length ? 1 === r.length ? Ue(r[0]) : vn(n)(le(r, e)) : xt } function We(t) { return t <= 0 ? () => xt : Wt((e, n) => { let r = 0; e.subscribe(et(n, i => { ++r <= t && (n.next(i), t <= r && n.complete()) })) }) } function zn(t, e, ...n) { return !0 === e ? (t(), null) : !1 === e ? null : e(...n).pipe(We(1)).subscribe(() => t()) } function ke(t) { for (let e in t) if (t[e] === ke) return e; throw Error("Could not find renamed property on target object.") } function Ci(t, e) { for (const n in e) e.hasOwnProperty(n) && !t.hasOwnProperty(n) && (t[n] = e[n]) } function Ze(t) { if ("string" == typeof t) return t; if (Array.isArray(t)) return "[" + t.map(Ze).join(", ") + "]"; if (null == t) return "" + t; if (t.overriddenName) return `${t.overriddenName}`; if (t.name) return `${t.name}`; const e = t.toString(); if (null == e) return "" + e; const n = e.indexOf("\n"); return -1 === n ? e : e.substring(0, n) } function ms(t, e) { return null == t || "" === t ? null === e ? "" : e : null == e || "" === e ? t : t + " " + e } const ps = ke({ __forward_ref__: ke }); function Je(t) { return t.__forward_ref__ = Je, t.toString = function () { return Ze(this()) }, t } function J(t) { return lo(t) ? t() : t } function lo(t) { return "function" == typeof t && t.hasOwnProperty(ps) && t.__forward_ref__ === Je } class P extends Error { constructor(e, n) { super(function Mi(t, e) { return `NG0${Math.abs(t)}${e ? ": " + e.trim() : ""}` }(e, n)), this.code = e } } function ie(t) { return "string" == typeof t ? t : null == t ? "" : String(t) } function qa(t, e) { throw new P(-201, !1) } function Tn(t, e) { null == t && function Ke(t, e, n, r) { throw new Error(`ASSERTION ERROR: ${t}` + (null == r ? "" : ` [Expected=> ${n} ${r} ${e} <=Actual]`)) }(e, t, null, "!=") } function pe(t) { return { token: t.token, providedIn: t.providedIn || null, factory: t.factory, value: void 0 } } function At(t) { return { providers: t.providers || [], imports: t.imports || [] } } function Mu(t) { return zm(t, Wa) || zm(t, Gm) } function zm(t, e) { return t.hasOwnProperty(e) ? t[e] : null } function Um(t) { return t && (t.hasOwnProperty(Tu) || t.hasOwnProperty(kE)) ? t[Tu] : null } const Wa = ke({ \u0275prov: ke }), Tu = ke({ \u0275inj: ke }), Gm = ke({ ngInjectableDef: ke }), kE = ke({ ngInjectorDef: ke }); var ue = (() => ((ue = ue || {})[ue.Default = 0] = "Default", ue[ue.Host = 1] = "Host", ue[ue.Self = 2] = "Self", ue[ue.SkipSelf = 4] = "SkipSelf", ue[ue.Optional = 8] = "Optional", ue))(); let xu; function br(t) { const e = xu; return xu = t, e } function qm(t, e, n) { const r = Mu(t); return r && "root" == r.providedIn ? void 0 === r.value ? r.value = r.factory() : r.value : n & ue.Optional ? null : void 0 !== e ? e : void qa(Ze(t)) } function oi(t) { return { toString: t }.toString() } var nr = (() => ((nr = nr || {})[nr.OnPush = 0] = "OnPush", nr[nr.Default = 1] = "Default", nr))(), rr = (() => { return (t = rr || (rr = {}))[t.Emulated = 0] = "Emulated", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom", rr; var t })(); const rt = (() => typeof globalThis < "u" && globalThis || typeof global < "u" && global || typeof window < "u" && window || typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self)(), co = {}, Ge = [], Za = ke({ \u0275cmp: ke }), ku = ke({ \u0275dir: ke }), Au = ke({ \u0275pipe: ke }), Wm = ke({ \u0275mod: ke }), zr = ke({ \u0275fac: ke }), bs = ke({ __NG_ELEMENT_ID__: ke }); let SE = 0; function uo(t) { return oi(() => { const n = !0 === t.standalone, r = {}, i = { type: t.type, providersResolver: null, decls: t.decls, vars: t.vars, factory: null, template: t.template || null, consts: t.consts || null, ngContentSelectors: t.ngContentSelectors, hostBindings: t.hostBindings || null, hostVars: t.hostVars || 0, hostAttrs: t.hostAttrs || null, contentQueries: t.contentQueries || null, declaredInputs: r, inputs: null, outputs: null, exportAs: t.exportAs || null, onPush: t.changeDetection === nr.OnPush, directiveDefs: null, pipeDefs: null, standalone: n, dependencies: n && t.dependencies || null, getStandaloneInjector: null, selectors: t.selectors || Ge, viewQuery: t.viewQuery || null, features: t.features || null, data: t.data || {}, encapsulation: t.encapsulation || rr.Emulated, id: "c" + SE++, styles: t.styles || Ge, _: null, setInput: null, schemas: t.schemas || null, tView: null }, o = t.dependencies, s = t.features; return i.inputs = Qm(t.inputs, r), i.outputs = Qm(t.outputs), s && s.forEach(a => a(i)), i.directiveDefs = o ? () => ("function" == typeof o ? o() : o).map(Zm).filter(Km) : null, i.pipeDefs = o ? () => ("function" == typeof o ? o() : o).map(un).filter(Km) : null, i }) } function Zm(t) { return at(t) || cn(t) } function Km(t) { return null !== t } const FE = {}; function Ot(t) { return oi(() => { const e = { type: t.type, bootstrap: t.bootstrap || Ge, declarations: t.declarations || Ge, imports: t.imports || Ge, exports: t.exports || Ge, transitiveCompileScopes: null, schemas: t.schemas || null, id: t.id || null }; return null != t.id && (FE[t.id] = t.type), e }) } function Qm(t, e) { if (null == t) return co; const n = {}; for (const r in t) if (t.hasOwnProperty(r)) { let i = t[r], o = i; Array.isArray(i) && (o = i[1], i = i[0]), n[i] = r, e && (e[i] = o) } return n } const te = uo; function at(t) { return t[Za] || null } function cn(t) { return t[ku] || null } function un(t) { return t[Au] || null } function Dn(t) { return Array.isArray(t) && "object" == typeof t[1] } function or(t) { return Array.isArray(t) && !0 === t[1] } function Fu(t) { return 0 != (8 & t.flags) } function Xa(t) { return 2 == (2 & t.flags) } function Ja(t) { return 1 == (1 & t.flags) } function sr(t) { return null !== t.template } function LE(t) { return 0 != (256 & t[2]) } function Si(t, e) { return t.hasOwnProperty(zr) ? t[zr] : null } class Jm { constructor(e, n, r) { this.previousValue = e, this.currentValue = n, this.firstChange = r } isFirstChange() { return this.firstChange } } function yr() { return ep } function ep(t) { return t.type.prototype.ngOnChanges && (t.setInput = jE), HE } function HE() { const t = np(this), e = t?.current; if (e) { const n = t.previous; if (n === co) t.previous = e; else for (let r in e) n[r] = e[r]; t.current = null, this.ngOnChanges(e) } } function jE(t, e, n, r) { const i = np(t) || function $E(t, e) { return t[tp] = e }(t, { previous: co, current: null }), o = i.current || (i.current = {}), s = i.previous, a = this.declaredInputs[n], l = s[a]; o[a] = new Jm(l && l.currentValue, e, s === co), t[r] = e } yr.ngInherit = !0; const tp = "__ngSimpleChanges__"; function np(t) { return t[tp] || null } let Lu; function Vu() { return void 0 !== Lu ? Lu : typeof document < "u" ? document : void 0 } function Et(t) { return !!t.listen } const rp = { createRenderer: (t, e) => Vu() }; function Rt(t) { for (; Array.isArray(t);)t = t[0]; return t } function el(t, e) { return Rt(e[t]) } function qn(t, e) { return Rt(e[t.index]) } function Bu(t, e) { return t.data[e] } function An(t, e) { const n = e[t]; return Dn(n) ? n : n[0] } function ip(t) { return 4 == (4 & t[2]) } function Hu(t) { return 64 == (64 & t[2]) } function si(t, e) { return null == e ? null : t[e] } function op(t) { t[18] = 0 } function ju(t, e) { t[5] += e; let n = t, r = t[3]; for (; null !== r && (1 === e && 1 === n[5] || -1 === e && 0 === n[5]);)r[5] += e, n = r, r = r[3] } const he = { lFrame: mp(null), bindingsEnabled: !0 }; function ap() { return he.bindingsEnabled } function k() { return he.lFrame.lView } function Pe() { return he.lFrame.tView } function Ii(t) { return he.lFrame.contextLView = t, t[8] } function Fi(t) { return he.lFrame.contextLView = null, t } function Ht() { let t = lp(); for (; null !== t && 64 === t.type;)t = t.parent; return t } function lp() { return he.lFrame.currentTNode } function _r(t, e) { const n = he.lFrame; n.currentTNode = t, n.isParent = e } function $u() { return he.lFrame.isParent } function zu() { he.lFrame.isParent = !1 } function bo() { return he.lFrame.bindingIndex++ } function oC(t, e) { const n = he.lFrame; n.bindingIndex = n.bindingRootIndex = t, Uu(e) } function Uu(t) { he.lFrame.currentDirectiveIndex = t } function dp() { return he.lFrame.currentQueryIndex } function qu(t) { he.lFrame.currentQueryIndex = t } function aC(t) { const e = t[1]; return 2 === e.type ? e.declTNode : 1 === e.type ? t[6] : null } function fp(t, e, n) { if (n & ue.SkipSelf) { let i = e, o = t; for (; !(i = i.parent, null !== i || n & ue.Host || (i = aC(o), null === i || (o = o[15], 10 & i.type)));); if (null === i) return !1; e = i, t = o } const r = he.lFrame = hp(); return r.currentTNode = e, r.lView = t, !0 } function nl(t) { const e = hp(), n = t[1]; he.lFrame = e, e.currentTNode = n.firstChild, e.lView = t, e.tView = n, e.contextLView = t, e.bindingIndex = n.bindingStartIndex, e.inI18n = !1 } function hp() { const t = he.lFrame, e = null === t ? null : t.child; return null === e ? mp(t) : e } function mp(t) { const e = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: t, child: null, inI18n: !1 }; return null !== t && (t.child = e), e } function pp() { const t = he.lFrame; return he.lFrame = t.parent, t.currentTNode = null, t.lView = null, t } const gp = pp; function rl() { const t = pp(); t.isParent = !0, t.tView = null, t.selectedIndex = -1, t.contextLView = null, t.elementDepthCount = 0, t.currentDirectiveIndex = -1, t.currentNamespace = null, t.bindingRootIndex = -1, t.bindingIndex = -1, t.currentQueryIndex = 0 } function fn() { return he.lFrame.selectedIndex } function ai(t) { he.lFrame.selectedIndex = t } function Ct() { const t = he.lFrame; return Bu(t.tView, t.selectedIndex) } function il(t, e) { for (let n = e.directiveStart, r = e.directiveEnd; n < r; n++) { const o = t.data[n].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: l, ngAfterViewChecked: c, ngOnDestroy: u } = o; s && (t.contentHooks || (t.contentHooks = [])).push(-n, s), a && ((t.contentHooks || (t.contentHooks = [])).push(n, a), (t.contentCheckHooks || (t.contentCheckHooks = [])).push(n, a)), l && (t.viewHooks || (t.viewHooks = [])).push(-n, l), c && ((t.viewHooks || (t.viewHooks = [])).push(n, c), (t.viewCheckHooks || (t.viewCheckHooks = [])).push(n, c)), null != u && (t.destroyHooks || (t.destroyHooks = [])).push(n, u) } } function ol(t, e, n) { bp(t, e, 3, n) } function sl(t, e, n, r) { (3 & t[2]) === n && bp(t, e, n, r) } function Wu(t, e) { let n = t[2]; (3 & n) === e && (n &= 2047, n += 1, t[2] = n) } function bp(t, e, n, r) { const o = r ?? -1, s = e.length - 1; let a = 0; for (let l = void 0 !== r ? 65535 & t[18] : 0; l < s; l++)if ("number" == typeof e[l + 1]) { if (a = e[l], null != r && a >= r) break } else e[l] < 0 && (t[18] += 65536), (a < o || -1 == o) && (gC(t, n, e, l), t[18] = (4294901760 & t[18]) + l + 2), l++ } function gC(t, e, n, r) { const i = n[r] < 0, o = n[r + 1], a = t[i ? -n[r] : n[r]]; if (i) { if (t[2] >> 11 < t[18] >> 16 && (3 & t[2]) === e) { t[2] += 2048; try { o.call(a) } finally { } } } else try { o.call(a) } finally { } } class Ds { constructor(e, n, r) { this.factory = e, this.resolving = !1, this.canSeeViewProviders = n, this.injectImpl = r } } function al(t, e, n) { const r = Et(t); let i = 0; for (; i < n.length;) { const o = n[i]; if ("number" == typeof o) { if (0 !== o) break; i++; const s = n[i++], a = n[i++], l = n[i++]; r ? t.setAttribute(e, a, l, s) : e.setAttributeNS(s, a, l) } else { const s = o, a = n[++i]; Ku(s) ? r && t.setProperty(e, s, a) : r ? t.setAttribute(e, s, a) : e.setAttribute(s, a), i++ } } return i } function yp(t) { return 3 === t || 4 === t || 6 === t } function Ku(t) { return 64 === t.charCodeAt(0) } function ll(t, e) { if (null !== e && 0 !== e.length) if (null === t || 0 === t.length) t = e.slice(); else { let n = -1; for (let r = 0; r < e.length; r++) { const i = e[r]; "number" == typeof i ? n = i : 0 === n || _p(t, n, i, null, -1 === n || 2 === n ? e[++r] : null) } } return t } function _p(t, e, n, r, i) { let o = 0, s = t.length; if (-1 === e) s = -1; else for (; o < t.length;) { const a = t[o++]; if ("number" == typeof a) { if (a === e) { s = -1; break } if (a > e) { s = o - 1; break } } } for (; o < t.length;) { const a = t[o]; if ("number" == typeof a) break; if (a === n) { if (null === r) return void (null !== i && (t[o + 1] = i)); if (r === t[o + 1]) return void (t[o + 2] = i) } o++, null !== r && o++, null !== i && o++ } -1 !== s && (t.splice(s, 0, e), o = s + 1), t.splice(o++, 0, n), null !== r && t.splice(o++, 0, r), null !== i && t.splice(o++, 0, i) } function vp(t) { return -1 !== t } function yo(t) { return 32767 & t } function _o(t, e) { let n = function wC(t) { return t >> 16 }(t), r = e; for (; n > 0;)r = r[15], n--; return r } let Qu = !0; function cl(t) { const e = Qu; return Qu = t, e } let DC = 0; const vr = {}; function Cs(t, e) { const n = Xu(t, e); if (-1 !== n) return n; const r = e[1]; r.firstCreatePass && (t.injectorIndex = e.length, Yu(r.data, t), Yu(e, null), Yu(r.blueprint, null)); const i = ul(t, e), o = t.injectorIndex; if (vp(i)) { const s = yo(i), a = _o(i, e), l = a[1].data; for (let c = 0; c < 8; c++)e[o + c] = a[s + c] | l[s + c] } return e[o + 8] = i, o } function Yu(t, e) { t.push(0, 0, 0, 0, 0, 0, 0, 0, e) } function Xu(t, e) { return -1 === t.injectorIndex || t.parent && t.parent.injectorIndex === t.injectorIndex || null === e[t.injectorIndex + 8] ? -1 : t.injectorIndex } function ul(t, e) { if (t.parent && -1 !== t.parent.injectorIndex) return t.parent.injectorIndex; let n = 0, r = null, i = e; for (; null !== i;) { if (r = Ap(i), null === r) return -1; if (n++, i = i[15], -1 !== r.injectorIndex) return r.injectorIndex | n << 16 } return -1 } function dl(t, e, n) { !function EC(t, e, n) { let r; "string" == typeof n ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(bs) && (r = n[bs]), null == r && (r = n[bs] = DC++); const i = 255 & r; e.data[t + (i >> 5)] |= 1 << i }(t, e, n) } function Ep(t, e, n) { if (n & ue.Optional) return t; qa() } function Cp(t, e, n, r) { if (n & ue.Optional && void 0 === r && (r = null), 0 == (n & (ue.Self | ue.Host))) { const i = t[9], o = br(void 0); try { return i ? i.get(e, r, n & ue.Optional) : qm(e, r, n & ue.Optional) } finally { br(o) } } return Ep(r, 0, n) } function Mp(t, e, n, r = ue.Default, i) { if (null !== t) { if (1024 & e[2]) { const s = function kC(t, e, n, r, i) { let o = t, s = e; for (; null !== o && null !== s && 1024 & s[2] && !(256 & s[2]);) { const a = Tp(o, s, n, r | ue.Self, vr); if (a !== vr) return a; let l = o.parent; if (!l) { const c = s[21]; if (c) { const u = c.get(n, vr, r); if (u !== vr) return u } l = Ap(s), s = s[15] } o = l } return i }(t, e, n, r, vr); if (s !== vr) return s } const o = Tp(t, e, n, r, vr); if (o !== vr) return o } return Cp(e, n, r, i) } function Tp(t, e, n, r, i) { const o = function TC(t) { if ("string" == typeof t) return t.charCodeAt(0) || 0; const e = t.hasOwnProperty(bs) ? t[bs] : void 0; return "number" == typeof e ? e >= 0 ? 255 & e : xC : e }(n); if ("function" == typeof o) { if (!fp(e, t, r)) return r & ue.Host ? Ep(i, 0, r) : Cp(e, n, r, i); try { const s = o(r); if (null != s || r & ue.Optional) return s; qa() } finally { gp() } } else if ("number" == typeof o) { let s = null, a = Xu(t, e), l = -1, c = r & ue.Host ? e[16][6] : null; for ((-1 === a || r & ue.SkipSelf) && (l = -1 === a ? ul(t, e) : e[a + 8], -1 !== l && kp(r, !1) ? (s = e[1], a = yo(l), e = _o(l, e)) : a = -1); -1 !== a;) { const u = e[1]; if (xp(o, a, u.data)) { const d = MC(a, e, n, s, r, c); if (d !== vr) return d } l = e[a + 8], -1 !== l && kp(r, e[1].data[a + 8] === c) && xp(o, a, e) ? (s = u, a = yo(l), e = _o(l, e)) : a = -1 } } return i } function MC(t, e, n, r, i, o) { const s = e[1], a = s.data[t + 8], u = fl(a, s, n, null == r ? Xa(a) && Qu : r != s && 0 != (3 & a.type), i & ue.Host && o === a); return null !== u ? Ms(e, s, u, a) : vr } function fl(t, e, n, r, i) { const o = t.providerIndexes, s = e.data, a = 1048575 & o, l = t.directiveStart, u = o >> 20, f = i ? a + u : t.directiveEnd; for (let h = r ? a : a + u; h < f; h++) { const m = s[h]; if (h < l && n === m || h >= l && m.type === n) return h } if (i) { const h = s[l]; if (h && sr(h) && h.type === n) return l } return null } function Ms(t, e, n, r) { let i = t[n]; const o = e.data; if (function bC(t) { return t instanceof Ds }(i)) { const s = i; s.resolving && function jr(t, e) { const n = e ? `. Dependency path: ${e.join(" > ")} > ${t}` : ""; throw new P(-200, `Circular dependency in DI detected for ${t}${n}`) }(function Me(t) { return "function" == typeof t ? t.name || t.toString() : "object" == typeof t && null != t && "function" == typeof t.type ? t.type.name || t.type.toString() : ie(t) }(o[n])); const a = cl(s.canSeeViewProviders); s.resolving = !0; const l = s.injectImpl ? br(s.injectImpl) : null; fp(t, r, ue.Default); try { i = t[n] = s.factory(void 0, o, t, r), e.firstCreatePass && n >= r.directiveStart && function pC(t, e, n) { const { ngOnChanges: r, ngOnInit: i, ngDoCheck: o } = e.type.prototype; if (r) { const s = ep(e); (n.preOrderHooks || (n.preOrderHooks = [])).push(t, s), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(t, s) } i && (n.preOrderHooks || (n.preOrderHooks = [])).push(0 - t, i), o && ((n.preOrderHooks || (n.preOrderHooks = [])).push(t, o), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(t, o)) }(n, o[n], e) } finally { null !== l && br(l), cl(a), s.resolving = !1, gp() } } return i } function xp(t, e, n) { return !!(n[e + (t >> 5)] & 1 << t) } function kp(t, e) { return !(t & ue.Self || t & ue.Host && e) } class vo { constructor(e, n) { this._tNode = e, this._lView = n } get(e, n, r) { return Mp(this._tNode, this._lView, e, r, n) } } function xC() { return new vo(Ht(), k()) } function Ju(t) { return lo(t) ? () => { const e = Ju(J(t)); return e && e() } : Si(t) } function Ap(t) { const e = t[1], n = e.type; return 2 === n ? e.declTNode : 1 === n ? t[6] : null } const Do = "__parameters__"; function Co(t, e, n) { return oi(() => { const r = function ed(t) { return function (...n) { if (t) { const r = t(...n); for (const i in r) this[i] = r[i] } } }(e); function i(...o) { if (this instanceof i) return r.apply(this, o), this; const s = new i(...o); return a.annotation = s, a; function a(l, c, u) { const d = l.hasOwnProperty(Do) ? l[Do] : Object.defineProperty(l, Do, { value: [] })[Do]; for (; d.length <= u;)d.push(null); return (d[u] = d[u] || []).push(s), l } } return n && (i.prototype = Object.create(n.prototype)), i.prototype.ngMetadataName = t, i.annotationCls = i, i }) } class K { constructor(e, n) { this._desc = e, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof n ? this.__NG_ELEMENT_ID__ = n : void 0 !== n && (this.\u0275prov = pe({ token: this, providedIn: n.providedIn || "root", factory: n.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } } function Sn(t, e) { void 0 === e && (e = t); for (let n = 0; n < t.length; n++) { let r = t[n]; Array.isArray(r) ? (e === t && (e = t.slice(0, n)), Sn(r, e)) : e !== t && e.push(r) } return e } function qr(t, e) { t.forEach(n => Array.isArray(n) ? qr(n, e) : e(n)) } function Ip(t, e, n) { e >= t.length ? t.push(n) : t.splice(e, 0, n) } function ml(t, e) { return e >= t.length - 1 ? t.pop() : t.splice(e, 1)[0] } function ks(t, e) { const n = []; for (let r = 0; r < t; r++)n.push(e); return n } function In(t, e, n) { let r = Mo(t, e); return r >= 0 ? t[1 | r] = n : (r = ~r, function FC(t, e, n, r) { let i = t.length; if (i == e) t.push(n, r); else if (1 === i) t.push(r, t[0]), t[0] = n; else { for (i--, t.push(t[i - 1], t[i]); i > e;)t[i] = t[i - 2], i--; t[e] = n, t[e + 1] = r } }(t, r, e, n)), r } function nd(t, e) { const n = Mo(t, e); if (n >= 0) return t[1 | n] } function Mo(t, e) { return function Op(t, e, n) { let r = 0, i = t.length >> n; for (; i !== r;) { const o = r + (i - r >> 1), s = t[o << n]; if (e === s) return o << n; s > e ? i = o : r = o + 1 } return ~(i << n) }(t, e, 1) } const As = {}, id = "__NG_DI_FLAG__", gl = "ngTempTokenPath", HC = /\n/gm, Rp = "__source"; let Ss; function bl(t) { const e = Ss; return Ss = t, e } function $C(t, e = ue.Default) { if (void 0 === Ss) throw new P(-203, ""); return null === Ss ? qm(t, void 0, e) : Ss.get(t, e & ue.Optional ? null : void 0, e) } function B(t, e = ue.Default) { return (function AE() { return xu }() || $C)(J(t), e) } function yl(t, e = ue.Default) { return B(t, e) } function od(t) { const e = []; for (let n = 0; n < t.length; n++) { const r = J(t[n]); if (Array.isArray(r)) { if (0 === r.length) throw new P(900, ""); let i, o = ue.Default; for (let s = 0; s < r.length; s++) { const a = r[s], l = zC(a); "number" == typeof l ? -1 === l ? i = a.token : o |= l : i = a } e.push(B(i, o)) } else e.push(B(r)) } return e } function Is(t, e) { return t[id] = e, t.prototype[id] = e, t } function zC(t) { return t[id] } const _l = Is(Co("Optional"), 8), vl = Is(Co("SkipSelf"), 4); let El, Cl; function xo(t) { return function ad() { if (void 0 === El && (El = null, rt.trustedTypes)) try { El = rt.trustedTypes.createPolicy("angular", { createHTML: t => t, createScript: t => t, createScriptURL: t => t }) } catch { } return El }()?.createHTML(t) || t } function Up(t) { return function ld() { if (void 0 === Cl && (Cl = null, rt.trustedTypes)) try { Cl = rt.trustedTypes.createPolicy("angular#unsafe-bypass", { createHTML: t => t, createScript: t => t, createScriptURL: t => t }) } catch { } return Cl }()?.createHTML(t) || t } class Wp { constructor(e) { this.changingThisBreaksApplicationSecurity = e } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)` } } function ci(t) { return t instanceof Wp ? t.changingThisBreaksApplicationSecurity : t } class cM { constructor(e) { this.inertDocumentHelper = e } getInertBodyElement(e) { e = "<body><remove></remove>" + e; try { const n = (new window.DOMParser).parseFromString(xo(e), "text/html").body; return null === n ? this.inertDocumentHelper.getInertBodyElement(e) : (n.removeChild(n.firstChild), n) } catch { return null } } } class uM { constructor(e) { if (this.defaultDoc = e, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), null == this.inertDocument.body) { const n = this.inertDocument.createElement("html"); this.inertDocument.appendChild(n); const r = this.inertDocument.createElement("body"); n.appendChild(r) } } getInertBodyElement(e) { const n = this.inertDocument.createElement("template"); if ("content" in n) return n.innerHTML = xo(e), n; const r = this.inertDocument.createElement("body"); return r.innerHTML = xo(e), this.defaultDoc.documentMode && this.stripCustomNsAttrs(r), r } stripCustomNsAttrs(e) { const n = e.attributes; for (let i = n.length - 1; 0 < i; i--) { const s = n.item(i).name; ("xmlns:ns1" === s || 0 === s.indexOf("ns1:")) && e.removeAttribute(s) } let r = e.firstChild; for (; r;)r.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(r), r = r.nextSibling } } const fM = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi, hM = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i; function Ml(t) { return (t = String(t)).match(fM) || t.match(hM) ? t : "unsafe:" + t } function wr(t) { const e = {}; for (const n of t.split(",")) e[n] = !0; return e } function Rs(...t) { const e = {}; for (const n of t) for (const r in n) n.hasOwnProperty(r) && (e[r] = !0); return e } const Qp = wr("area,br,col,hr,img,wbr"), Yp = wr("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), Xp = wr("rp,rt"), cd = Rs(Qp, Rs(Yp, wr("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), Rs(Xp, wr("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), Rs(Xp, Yp)), ud = wr("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), dd = wr("srcset"), Jp = Rs(ud, dd, wr("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), wr("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")), mM = wr("script,style,template"); class pM { constructor() { this.sanitizedSomething = !1, this.buf = [] } sanitizeChildren(e) { let n = e.firstChild, r = !0; for (; n;)if (n.nodeType === Node.ELEMENT_NODE ? r = this.startElement(n) : n.nodeType === Node.TEXT_NODE ? this.chars(n.nodeValue) : this.sanitizedSomething = !0, r && n.firstChild) n = n.firstChild; else for (; n;) { n.nodeType === Node.ELEMENT_NODE && this.endElement(n); let i = this.checkClobberedElement(n, n.nextSibling); if (i) { n = i; break } n = this.checkClobberedElement(n, n.parentNode) } return this.buf.join("") } startElement(e) { const n = e.nodeName.toLowerCase(); if (!cd.hasOwnProperty(n)) return this.sanitizedSomething = !0, !mM.hasOwnProperty(n); this.buf.push("<"), this.buf.push(n); const r = e.attributes; for (let i = 0; i < r.length; i++) { const o = r.item(i), s = o.name, a = s.toLowerCase(); if (!Jp.hasOwnProperty(a)) { this.sanitizedSomething = !0; continue } let l = o.value; ud[a] && (l = Ml(l)), dd[a] && (t = l, l = (t = String(t)).split(",").map(e => Ml(e.trim())).join(", ")), this.buf.push(" ", s, '="', eg(l), '"') } var t; return this.buf.push(">"), !0 } endElement(e) { const n = e.nodeName.toLowerCase(); cd.hasOwnProperty(n) && !Qp.hasOwnProperty(n) && (this.buf.push("</"), this.buf.push(n), this.buf.push(">")) } chars(e) { this.buf.push(eg(e)) } checkClobberedElement(e, n) { if (n && (e.compareDocumentPosition(n) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${e.outerHTML}`); return n } } const gM = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, bM = /([^\#-~ |!])/g; function eg(t) { return t.replace(/&/g, "&amp;").replace(gM, function (e) { return "&#" + (1024 * (e.charCodeAt(0) - 55296) + (e.charCodeAt(1) - 56320) + 65536) + ";" }).replace(bM, function (e) { return "&#" + e.charCodeAt(0) + ";" }).replace(/</g, "&lt;").replace(/>/g, "&gt;") } let Tl; function fd(t) { return "content" in t && function _M(t) { return t.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === t.nodeName }(t) ? t.content : null } var Pt = (() => ((Pt = Pt || {})[Pt.NONE = 0] = "NONE", Pt[Pt.HTML = 1] = "HTML", Pt[Pt.STYLE = 2] = "STYLE", Pt[Pt.SCRIPT = 3] = "SCRIPT", Pt[Pt.URL = 4] = "URL", Pt[Pt.RESOURCE_URL = 5] = "RESOURCE_URL", Pt))(); function tg(t) { const e = function Ps() { const t = k(); return t && t[12] }(); return e ? Up(e.sanitize(Pt.HTML, t) || "") : function Os(t, e) { const n = function lM(t) { return t instanceof Wp && t.getTypeName() || null }(t); if (null != n && n !== e) { if ("ResourceURL" === n && "URL" === e) return !0; throw new Error(`Required a safe ${e}, got a ${n} (see https://g.co/ng/security#xss)`) } return n === e }(t, "HTML") ? Up(ci(t)) : function yM(t, e) { let n = null; try { Tl = Tl || function Zp(t) { const e = new uM(t); return function dM() { try { return !!(new window.DOMParser).parseFromString(xo(""), "text/html") } catch { return !1 } }() ? new cM(e) : e }(t); let r = e ? String(e) : ""; n = Tl.getInertBodyElement(r); let i = 5, o = r; do { if (0 === i) throw new Error("Failed to sanitize html because the input is unstable"); i--, r = o, o = n.innerHTML, n = Tl.getInertBodyElement(r) } while (r !== o); return xo((new pM).sanitizeChildren(fd(n) || n)) } finally { if (n) { const r = fd(n) || n; for (; r.firstChild;)r.removeChild(r.firstChild) } } }(Vu(), ie(t)) } function md(t) { return t.ngOriginalError } class ko { constructor() { this._console = console } handleError(e) { const n = this._findOriginalError(e); this._console.error("ERROR", e), n && this._console.error("ORIGINAL ERROR", n) } _findOriginalError(e) { let n = e && md(e); for (; n && md(n);)n = md(n); return n || null } } const pd = new Map; let OM = 0; const bd = "__ngContext__"; function en(t, e) { Dn(e) ? (t[bd] = e[20], function PM(t) { pd.set(t[20], t) }(e)) : t[bd] = e } function Ls(t) { const e = t[bd]; return "number" == typeof e ? function og(t) { return pd.get(t) || null }(e) : e || null } function yd(t) { const e = Ls(t); return e ? Dn(e) ? e : e.lView : null } const GM = (() => (typeof requestAnimationFrame < "u" && requestAnimationFrame || setTimeout).bind(rt))(); var Fn = (() => ((Fn = Fn || {})[Fn.Important = 1] = "Important", Fn[Fn.DashCase = 2] = "DashCase", Fn))(); function vd(t, e) { return undefined(t, e) } function Vs(t) { const e = t[3]; return or(e) ? e[3] : e } function wd(t) { return mg(t[13]) } function Dd(t) { return mg(t[4]) } function mg(t) { for (; null !== t && !or(t);)t = t[4]; return t } function So(t, e, n, r, i) { if (null != r) { let o, s = !1; or(r) ? o = r : Dn(r) && (s = !0, r = r[0]); const a = Rt(r); 0 === t && null !== n ? null == i ? vg(e, n, a) : Ni(e, n, a, i || null, !0) : 1 === t && null !== n ? Ni(e, n, a, i || null, !0) : 2 === t ? function kg(t, e, n) { const r = xl(t, e); r && function sT(t, e, n, r) { Et(t) ? t.removeChild(e, n, r) : e.removeChild(n) }(t, r, e, n) }(e, a, s) : 3 === t && e.destroyNode(a), null != o && function cT(t, e, n, r, i) { const o = n[7]; o !== Rt(n) && So(e, t, r, o, i); for (let a = 10; a < n.length; a++) { const l = n[a]; Bs(l[1], l, t, e, r, o) } }(e, t, o, n, i) } } function Cd(t, e, n) { if (Et(t)) return t.createElement(e, n); { const r = null !== n ? function qE(t) { const e = t.toLowerCase(); return "svg" === e ? "http://www.w3.org/2000/svg" : "math" === e ? "http://www.w3.org/1998/MathML/" : null }(n) : null; return null === r ? t.createElement(e) : t.createElementNS(r, e) } } function gg(t, e) { const n = t[9], r = n.indexOf(e), i = e[3]; 512 & e[2] && (e[2] &= -513, ju(i, -1)), n.splice(r, 1) } function Md(t, e) { if (t.length <= 10) return; const n = 10 + e, r = t[n]; if (r) { const i = r[17]; null !== i && i !== t && gg(i, r), e > 0 && (t[n - 1][4] = r[4]); const o = ml(t, 10 + e); !function XM(t, e) { Bs(t, e, e[11], 2, null, null), e[0] = null, e[6] = null }(r[1], r); const s = o[19]; null !== s && s.detachView(o[1]), r[3] = null, r[4] = null, r[2] &= -65 } return r } function bg(t, e) { if (!(128 & e[2])) { const n = e[11]; Et(n) && n.destroyNode && Bs(t, e, n, 3, null, null), function tT(t) { let e = t[13]; if (!e) return Td(t[1], t); for (; e;) { let n = null; if (Dn(e)) n = e[13]; else { const r = e[10]; r && (n = r) } if (!n) { for (; e && !e[4] && e !== t;)Dn(e) && Td(e[1], e), e = e[3]; null === e && (e = t), Dn(e) && Td(e[1], e), n = e && e[4] } e = n } }(e) } } function Td(t, e) { if (!(128 & e[2])) { e[2] &= -65, e[2] |= 128, function oT(t, e) { let n; if (null != t && null != (n = t.destroyHooks)) for (let r = 0; r < n.length; r += 2) { const i = e[n[r]]; if (!(i instanceof Ds)) { const o = n[r + 1]; if (Array.isArray(o)) for (let s = 0; s < o.length; s += 2) { const a = i[o[s]], l = o[s + 1]; try { l.call(a) } finally { } } else try { o.call(i) } finally { } } } }(t, e), function iT(t, e) { const n = t.cleanup, r = e[7]; let i = -1; if (null !== n) for (let o = 0; o < n.length - 1; o += 2)if ("string" == typeof n[o]) { const s = n[o + 1], a = "function" == typeof s ? s(e) : Rt(e[s]), l = r[i = n[o + 2]], c = n[o + 3]; "boolean" == typeof c ? a.removeEventListener(n[o], l, c) : c >= 0 ? r[i = c]() : r[i = -c].unsubscribe(), o += 2 } else { const s = r[i = n[o + 1]]; n[o].call(s) } if (null !== r) { for (let o = i + 1; o < r.length; o++)r[o](); e[7] = null } }(t, e), 1 === e[1].type && Et(e[11]) && e[11].destroy(); const n = e[17]; if (null !== n && or(e[3])) { n !== e[3] && gg(n, e); const r = e[19]; null !== r && r.detachView(t) } !function LM(t) { pd.delete(t[20]) }(e) } } function yg(t, e, n) { return function _g(t, e, n) { let r = e; for (; null !== r && 40 & r.type;)r = (e = r).parent; if (null === r) return n[0]; if (2 & r.flags) { const i = t.data[r.directiveStart].encapsulation; if (i === rr.None || i === rr.Emulated) return null } return qn(r, n) }(t, e.parent, n) } function Ni(t, e, n, r, i) { Et(t) ? t.insertBefore(e, n, r, i) : (Dg(e) ? e.content : e).insertBefore(n, r, i) } function vg(t, e, n) { Et(t) ? t.appendChild(e, n) : (Dg(e) ? e.content : e).appendChild(n) } function wg(t, e, n, r, i) { null !== r ? Ni(t, e, n, r, i) : vg(t, e, n) } function Dg(t) { return "TEMPLATE" === t.tagName && void 0 !== t.content } function xl(t, e) { return Et(t) ? t.parentNode(e) : e.parentNode } function Eg(t, e, n) { return Mg(t, e, n) } let Mg = function Cg(t, e, n) { return 40 & t.type ? qn(t, n) : null }; function kl(t, e, n, r) { const i = yg(t, r, e), o = e[11], a = Eg(r.parent || e[6], r, e); if (null != i) if (Array.isArray(n)) for (let l = 0; l < n.length; l++)wg(o, i, n[l], a, !1); else wg(o, i, n, a, !1) } function Al(t, e) { if (null !== e) { const n = e.type; if (3 & n) return qn(e, t); if (4 & n) return kd(-1, t[e.index]); if (8 & n) { const r = e.child; if (null !== r) return Al(t, r); { const i = t[e.index]; return or(i) ? kd(-1, i) : Rt(i) } } if (32 & n) return vd(e, t)() || Rt(t[e.index]); { const r = xg(t, e); return null !== r ? Array.isArray(r) ? r[0] : Al(Vs(t[16]), r) : Al(t, e.next) } } return null } function xg(t, e) { return null !== e ? t[16][6].projection[e.projection] : null } function kd(t, e) { const n = 10 + t + 1; if (n < e.length) { const r = e[n], i = r[1].firstChild; if (null !== i) return Al(r, i) } return e[7] } function Ad(t, e, n, r, i, o, s) { for (; null != n;) { const a = r[n.index], l = n.type; if (s && 0 === e && (a && en(Rt(a), r), n.flags |= 4), 64 != (64 & n.flags)) if (8 & l) Ad(t, e, n.child, r, i, o, !1), So(e, t, i, a, o); else if (32 & l) { const c = vd(n, r); let u; for (; u = c();)So(e, t, i, u, o); So(e, t, i, a, o) } else 16 & l ? Ag(t, e, r, n, i, o) : So(e, t, i, a, o); n = s ? n.projectionNext : n.next } } function Bs(t, e, n, r, i, o) { Ad(n, r, t.firstChild, e, i, o, !1) } function Ag(t, e, n, r, i, o) { const s = n[16], l = s[6].projection[r.projection]; if (Array.isArray(l)) for (let c = 0; c < l.length; c++)So(e, t, i, l[c], o); else Ad(t, e, l, s[3], i, o, !0) } function Sg(t, e, n) { Et(t) ? t.setAttribute(e, "style", n) : e.style.cssText = n } function Sd(t, e, n) { Et(t) ? "" === n ? t.removeAttribute(e, "class") : t.setAttribute(e, "class", n) : e.className = n } function Ig(t, e, n) { let r = t.length; for (; ;) { const i = t.indexOf(e, n); if (-1 === i) return i; if (0 === i || t.charCodeAt(i - 1) <= 32) { const o = e.length; if (i + o === r || t.charCodeAt(i + o) <= 32) return i } n = i + 1 } } const Fg = "ng-template"; function dT(t, e, n) { let r = 0; for (; r < t.length;) { let i = t[r++]; if (n && "class" === i) { if (i = t[r], -1 !== Ig(i.toLowerCase(), e, 0)) return !0 } else if (1 === i) { for (; r < t.length && "string" == typeof (i = t[r++]);)if (i.toLowerCase() === e) return !0; return !1 } } return !1 } function Ng(t) { return 4 === t.type && t.value !== Fg } function fT(t, e, n) { return e === (4 !== t.type || n ? t.value : Fg) } function hT(t, e, n) { let r = 4; const i = t.attrs || [], o = function gT(t) { for (let e = 0; e < t.length; e++)if (yp(t[e])) return e; return t.length }(i); let s = !1; for (let a = 0; a < e.length; a++) { const l = e[a]; if ("number" != typeof l) { if (!s) if (4 & r) { if (r = 2 | 1 & r, "" !== l && !fT(t, l, n) || "" === l && 1 === e.length) { if (ar(r)) return !1; s = !0 } } else { const c = 8 & r ? l : e[++a]; if (8 & r && null !== t.attrs) { if (!dT(t.attrs, c, n)) { if (ar(r)) return !1; s = !0 } continue } const d = mT(8 & r ? "class" : l, i, Ng(t), n); if (-1 === d) { if (ar(r)) return !1; s = !0; continue } if ("" !== c) { let f; f = d > o ? "" : i[d + 1].toLowerCase(); const h = 8 & r ? f : null; if (h && -1 !== Ig(h, c, 0) || 2 & r && c !== f) { if (ar(r)) return !1; s = !0 } } } } else { if (!s && !ar(r) && !ar(l)) return !1; if (s && ar(l)) continue; s = !1, r = l | 1 & r } } return ar(r) || s } function ar(t) { return 0 == (1 & t) } function mT(t, e, n, r) { if (null === e) return -1; let i = 0; if (r || !n) { let o = !1; for (; i < e.length;) { const s = e[i]; if (s === t) return i; if (3 === s || 6 === s) o = !0; else { if (1 === s || 2 === s) { let a = e[++i]; for (; "string" == typeof a;)a = e[++i]; continue } if (4 === s) break; if (0 === s) { i += 4; continue } } i += o ? 1 : 2 } return -1 } return function bT(t, e) { let n = t.indexOf(4); if (n > -1) for (n++; n < t.length;) { const r = t[n]; if ("number" == typeof r) return -1; if (r === e) return n; n++ } return -1 }(e, t) } function Og(t, e, n = !1) { for (let r = 0; r < e.length; r++)if (hT(t, e[r], n)) return !0; return !1 } function yT(t, e) { e: for (let n = 0; n < e.length; n++) { const r = e[n]; if (t.length === r.length) { for (let i = 0; i < t.length; i++)if (t[i] !== r[i]) continue e; return !0 } } return !1 } function Rg(t, e) { return t ? ":not(" + e.trim() + ")" : e } function _T(t) { let e = t[0], n = 1, r = 2, i = "", o = !1; for (; n < t.length;) { let s = t[n]; if ("string" == typeof s) if (2 & r) { const a = t[++n]; i += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & r ? i += "." + s : 4 & r && (i += " " + s); else "" !== i && !ar(s) && (e += Rg(o, i), i = ""), r = s, o = o || !ar(r); n++ } return "" !== i && (e += Rg(o, i)), e } const ge = {}; function Qe(t) { Pg(Pe(), k(), fn() + t, !1) } function Pg(t, e, n, r) { if (!r) if (3 == (3 & e[2])) { const o = t.preOrderCheckHooks; null !== o && ol(e, o, n) } else { const o = t.preOrderHooks; null !== o && sl(e, o, 0, n) } ai(n) } const Hg = new K("ENVIRONMENT_INITIALIZER"), jg = new K("INJECTOR_DEF_TYPES"); function xT(...t) { return { \u0275providers: $g(0, t) } } function $g(t, ...e) { const n = [], r = new Set; let i; return qr(e, o => { const s = o; Id(s, n, [], r) && (i || (i = []), i.push(s)) }), void 0 !== i && zg(i, n), n } function zg(t, e) { for (let n = 0; n < t.length; n++) { const { providers: i } = t[n]; qr(i, o => { e.push(o) }) } } function Id(t, e, n, r) { if (!(t = J(t))) return !1; let i = null, o = Um(t); const s = !o && at(t); if (o || s) { if (s && !s.standalone) return !1; i = t } else { const l = t.ngModule; if (o = Um(l), !o) return !1; i = l } const a = r.has(i); if (s) { if (a) return !1; if (r.add(i), s.dependencies) { const l = "function" == typeof s.dependencies ? s.dependencies() : s.dependencies; for (const c of l) Id(c, e, n, r) } } else { if (!o) return !1; { if (null != o.imports && !a) { let c; r.add(i); try { qr(o.imports, u => { Id(u, e, n, r) && (c || (c = []), c.push(u)) }) } finally { } void 0 !== c && zg(c, e) } if (!a) { const c = Si(i) || (() => new i); e.push({ provide: i, useFactory: c, deps: Ge }, { provide: jg, useValue: i, multi: !0 }, { provide: Hg, useValue: () => B(i), multi: !0 }) } const l = o.providers; null == l || a || qr(l, u => { e.push(u) }) } } return i !== t && void 0 !== t.providers } const kT = ke({ provide: String, useValue: ke }); function Fd(t) { return null !== t && "object" == typeof t && kT in t } function Oi(t) { return "function" == typeof t } const Nd = new K("INJECTOR", -1); class qg { get(e, n = As) { if (n === As) { const r = new Error(`NullInjectorError: No provider for ${Ze(e)}!`); throw r.name = "NullInjectorError", r } return n } } const Od = new K("Set Injector scope."), Sl = {}, ST = {}; let Rd; function Pd() { return void 0 === Rd && (Rd = new qg), Rd } class Hs { } class Wg extends Hs { constructor(e, n, r, i) { super(), this.parent = n, this.source = r, this.scopes = i, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, Vd(e, s => this.processProvider(s)), this.records.set(Nd, Io(void 0, this)), i.has("environment") && this.records.set(Hs, Io(void 0, this)); const o = this.records.get(Od); null != o && "string" == typeof o.value && this.scopes.add(o.value), this.injectorDefTypes = new Set(this.get(jg.multi, Ge, ue.Self)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { for (const e of this._ngOnDestroyHooks) e.ngOnDestroy(); for (const e of this._onDestroyHooks) e() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear(), this._onDestroyHooks.length = 0 } } onDestroy(e) { this._onDestroyHooks.push(e) } get(e, n = As, r = ue.Default) { this.assertNotDestroyed(); const i = bl(this), o = br(void 0); try { if (!(r & ue.SkipSelf)) { let a = this.records.get(e); if (void 0 === a) { const l = function RT(t) { return "function" == typeof t || "object" == typeof t && t instanceof K }(e) && Mu(e); a = l && this.injectableDefInScope(l) ? Io(Ld(e), Sl) : null, this.records.set(e, a) } if (null != a) return this.hydrate(e, a) } return (r & ue.Self ? Pd() : this.parent).get(e, n = r & ue.Optional && n === As ? null : n) } catch (s) { if ("NullInjectorError" === s.name) { if ((s[gl] = s[gl] || []).unshift(Ze(e)), i) throw s; return function UC(t, e, n, r) { const i = t[gl]; throw e[Rp] && i.unshift(e[Rp]), t.message = function GC(t, e, n, r = null) { t = t && "\n" === t.charAt(0) && "\u0275" == t.charAt(1) ? t.slice(2) : t; let i = Ze(e); if (Array.isArray(e)) i = e.map(Ze).join(" -> "); else if ("object" == typeof e) { let o = []; for (let s in e) if (e.hasOwnProperty(s)) { let a = e[s]; o.push(s + ":" + ("string" == typeof a ? JSON.stringify(a) : Ze(a))) } i = `{${o.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${i}]: ${t.replace(HC, "\n  ")}` }("\n" + t.message, i, n, r), t.ngTokenPath = i, t[gl] = null, t }(s, e, "R3InjectorError", this.source) } throw s } finally { br(o), bl(i) } } resolveInjectorInitializers() { const e = bl(this), n = br(void 0); try { const r = this.get(Hg.multi, Ge, ue.Self); for (const i of r) i() } finally { bl(e), br(n) } } toString() { const e = [], n = this.records; for (const r of n.keys()) e.push(Ze(r)); return `R3Injector[${e.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new P(205, !1) } processProvider(e) { let n = Oi(e = J(e)) ? e : J(e && e.provide); const r = function FT(t) { return Fd(t) ? Io(void 0, t.useValue) : Io(Zg(t), Sl) }(e); if (Oi(e) || !0 !== e.multi) this.records.get(n); else { let i = this.records.get(n); i || (i = Io(void 0, Sl, !0), i.factory = () => od(i.multi), this.records.set(n, i)), n = e, i.multi.push(e) } this.records.set(n, r) } hydrate(e, n) { return n.value === Sl && (n.value = ST, n.value = n.factory()), "object" == typeof n.value && n.value && function OT(t) { return null !== t && "object" == typeof t && "function" == typeof t.ngOnDestroy }(n.value) && this._ngOnDestroyHooks.add(n.value), n.value } injectableDefInScope(e) { if (!e.providedIn) return !1; const n = J(e.providedIn); return "string" == typeof n ? "any" === n || this.scopes.has(n) : this.injectorDefTypes.has(n) } } function Ld(t) { const e = Mu(t), n = null !== e ? e.factory : Si(t); if (null !== n) return n; if (t instanceof K) throw new P(204, !1); if (t instanceof Function) return function IT(t) { const e = t.length; if (e > 0) throw ks(e, "?"), new P(204, !1); const n = function TE(t) { const e = t && (t[Wa] || t[Gm]); if (e) { const n = function xE(t) { if (t.hasOwnProperty("name")) return t.name; const e = ("" + t).match(/^function\s*([^\s(]+)/); return null === e ? "" : e[1] }(t); return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`), e } return null }(t); return null !== n ? () => n.factory(t) : () => new t }(t); throw new P(204, !1) } function Zg(t, e, n) { let r; if (Oi(t)) { const i = J(t); return Si(i) || Ld(i) } if (Fd(t)) r = () => J(t.useValue); else if (function Gg(t) { return !(!t || !t.useFactory) }(t)) r = () => t.useFactory(...od(t.deps || [])); else if (function Ug(t) { return !(!t || !t.useExisting) }(t)) r = () => B(J(t.useExisting)); else { const i = J(t && (t.useClass || t.provide)); if (!function NT(t) { return !!t.deps }(t)) return Si(i) || Ld(i); r = () => new i(...od(t.deps)) } return r } function Io(t, e, n = !1) { return { factory: t, value: e, multi: n ? [] : void 0 } } function PT(t) { return !!t.\u0275providers } function Vd(t, e) { for (const n of t) Array.isArray(n) ? Vd(n, e) : PT(n) ? Vd(n.\u0275providers, e) : e(n) } function Kg(t, e = null, n = null, r) { const i = Qg(t, e, n, r); return i.resolveInjectorInitializers(), i } function Qg(t, e = null, n = null, r, i = new Set) { const o = [n || Ge, xT(t)]; return r = r || ("object" == typeof t ? void 0 : Ze(t)), new Wg(o, e || Pd(), r || null, i) } let tn = (() => { class t { static create(n, r) { if (Array.isArray(n)) return Kg({ name: "" }, r, n, ""); { const i = n.name ?? ""; return Kg({ name: i }, n.parent, n.providers, i) } } } return t.THROW_IF_NOT_FOUND = As, t.NULL = new qg, t.\u0275prov = pe({ token: t, providedIn: "any", factory: () => B(Nd) }), t.__NG_ELEMENT_ID__ = -1, t })(); function T(t, e = ue.Default) { const n = k(); return null === n ? B(t, e) : Mp(Ht(), n, J(t), e) } function Fl(t, e) { return t << 17 | e << 2 } function lr(t) { return t >> 17 & 32767 } function qd(t) { return 2 | t } function Zr(t) { return (131068 & t) >> 2 } function Wd(t, e) { return -131069 & t | e << 2 } function Zd(t) { return 1 | t } function gb(t, e) { const n = t.contentQueries; if (null !== n) for (let r = 0; r < n.length; r += 2) { const i = n[r], o = n[r + 1]; if (-1 !== o) { const s = t.data[o]; qu(i), s.contentQueries(2, e[o], o) } } } function js(t, e, n, r, i, o, s, a, l, c, u) { const d = e.blueprint.slice(); return d[0] = i, d[2] = 76 | r, (null !== u || t && 1024 & t[2]) && (d[2] |= 1024), op(d), d[3] = d[15] = t, d[8] = n, d[10] = s || t && t[10], d[11] = a || t && t[11], d[12] = l || t && t[12] || null, d[9] = c || t && t[9] || null, d[6] = o, d[20] = function RM() { return OM++ }(), d[21] = u, d[16] = 2 == e.type ? t[16] : d, d } function No(t, e, n, r, i) { let o = t.data[e]; if (null === o) o = function rf(t, e, n, r, i) { const o = lp(), s = $u(), l = t.data[e] = function px(t, e, n, r, i, o) { return { type: n, index: r, insertBeforeIndex: null, injectorIndex: e ? e.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: i, attrs: o, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: e, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, s ? o : o && o.parent, n, e, r, i); return null === t.firstChild && (t.firstChild = l), null !== o && (s ? null == o.child && null !== l.parent && (o.child = l) : null === o.next && (o.next = l)), l }(t, e, n, r, i), function iC() { return he.lFrame.inI18n }() && (o.flags |= 64); else if (64 & o.type) { o.type = n, o.value = r, o.attrs = i; const s = function ws() { const t = he.lFrame, e = t.currentTNode; return t.isParent ? e : e.parent }(); o.injectorIndex = null === s ? -1 : s.injectorIndex } return _r(o, !0), o } function Oo(t, e, n, r) { if (0 === n) return -1; const i = e.length; for (let o = 0; o < n; o++)e.push(r), t.blueprint.push(r), t.data.push(null); return i } function $s(t, e, n) { nl(e); try { const r = t.viewQuery; null !== r && hf(1, r, n); const i = t.template; null !== i && bb(t, e, i, 1, n), t.firstCreatePass && (t.firstCreatePass = !1), t.staticContentQueries && gb(t, e), t.staticViewQueries && hf(2, t.viewQuery, n); const o = t.components; null !== o && function fx(t, e) { for (let n = 0; n < e.length; n++)Nx(t, e[n]) }(e, o) } catch (r) { throw t.firstCreatePass && (t.incompleteFirstPass = !0, t.firstCreatePass = !1), r } finally { e[2] &= -5, rl() } } function Ro(t, e, n, r) { const i = e[2]; if (128 != (128 & i)) { nl(e); try { op(e), function cp(t) { return he.lFrame.bindingIndex = t }(t.bindingStartIndex), null !== n && bb(t, e, n, 2, r); const s = 3 == (3 & i); if (s) { const c = t.preOrderCheckHooks; null !== c && ol(e, c, null) } else { const c = t.preOrderHooks; null !== c && sl(e, c, 0, null), Wu(e, 0) } if (function Ix(t) { for (let e = wd(t); null !== e; e = Dd(e)) { if (!e[2]) continue; const n = e[9]; for (let r = 0; r < n.length; r++) { const i = n[r], o = i[3]; 0 == (512 & i[2]) && ju(o, 1), i[2] |= 512 } } }(e), function Sx(t) { for (let e = wd(t); null !== e; e = Dd(e))for (let n = 10; n < e.length; n++) { const r = e[n], i = r[1]; Hu(r) && Ro(i, r, i.template, r[8]) } }(e), null !== t.contentQueries && gb(t, e), s) { const c = t.contentCheckHooks; null !== c && ol(e, c) } else { const c = t.contentHooks; null !== c && sl(e, c, 1), Wu(e, 1) } !function ux(t, e) { const n = t.hostBindingOpCodes; if (null !== n) try { for (let r = 0; r < n.length; r++) { const i = n[r]; if (i < 0) ai(~i); else { const o = i, s = n[++r], a = n[++r]; oC(s, o), a(2, e[o]) } } } finally { ai(-1) } }(t, e); const a = t.components; null !== a && function dx(t, e) { for (let n = 0; n < e.length; n++)Fx(t, e[n]) }(e, a); const l = t.viewQuery; if (null !== l && hf(2, l, r), s) { const c = t.viewCheckHooks; null !== c && ol(e, c) } else { const c = t.viewHooks; null !== c && sl(e, c, 2), Wu(e, 2) } !0 === t.firstUpdatePass && (t.firstUpdatePass = !1), e[2] &= -41, 512 & e[2] && (e[2] &= -513, ju(e[3], -1)) } finally { rl() } } } function hx(t, e, n, r) { const i = e[10], s = ip(e); try { !s && i.begin && i.begin(), s && $s(t, e, r), Ro(t, e, n, r) } finally { !s && i.end && i.end() } } function bb(t, e, n, r, i) { const o = fn(), s = 2 & r; try { ai(-1), s && e.length > 22 && Pg(t, e, 22, !1), n(r, i) } finally { ai(o) } } function yb(t, e, n) { if (Fu(e)) { const i = e.directiveEnd; for (let o = e.directiveStart; o < i; o++) { const s = t.data[o]; s.contentQueries && s.contentQueries(1, n[o], o) } } } function of(t, e, n) { !ap() || (function Dx(t, e, n, r) { const i = n.directiveStart, o = n.directiveEnd; t.firstCreatePass || Cs(n, e), en(r, e); const s = n.initialInputs; for (let a = i; a < o; a++) { const l = t.data[a], c = sr(l); c && xx(e, n, l); const u = Ms(e, t, a, n); en(u, e), null !== s && kx(0, a - i, u, l, 0, s), c && (An(n.index, e)[8] = u) } }(t, e, n, qn(n, e)), 128 == (128 & n.flags) && function Ex(t, e, n) { const r = n.directiveStart, i = n.directiveEnd, o = n.index, s = function sC() { return he.lFrame.currentDirectiveIndex }(); try { ai(o); for (let a = r; a < i; a++) { const l = t.data[a], c = e[a]; Uu(a), (null !== l.hostBindings || 0 !== l.hostVars || null !== l.hostAttrs) && Mb(l, c) } } finally { ai(-1), Uu(s) } }(t, e, n)) } function sf(t, e, n = qn) { const r = e.localNames; if (null !== r) { let i = e.index + 1; for (let o = 0; o < r.length; o += 2) { const s = r[o + 1], a = -1 === s ? n(e, t) : t[s]; t[i++] = a } } } function _b(t) { const e = t.tView; return null === e || e.incompleteFirstPass ? t.tView = Rl(1, null, t.template, t.decls, t.vars, t.directiveDefs, t.pipeDefs, t.viewQuery, t.schemas, t.consts) : e } function Rl(t, e, n, r, i, o, s, a, l, c) { const u = 22 + r, d = u + i, f = function mx(t, e) { const n = []; for (let r = 0; r < e; r++)n.push(r < t ? null : ge); return n }(u, d), h = "function" == typeof c ? c() : c; return f[1] = { type: t, blueprint: f, template: n, queries: null, viewQuery: a, declTNode: e, data: f.slice().fill(null, u), bindingStartIndex: u, expandoStartIndex: d, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof o ? o() : o, pipeRegistry: "function" == typeof s ? s() : s, firstChild: null, schemas: l, consts: h, incompleteFirstPass: !1 } } function Db(t, e, n, r) { const i = Ib(e); null === n ? i.push(r) : (i.push(n), t.firstCreatePass && Fb(t).push(r, i.length - 1)) } function Eb(t, e, n) { for (let r in t) if (t.hasOwnProperty(r)) { const i = t[r]; (n = null === n ? {} : n).hasOwnProperty(r) ? n[r].push(e, i) : n[r] = [e, i] } return n } function Nn(t, e, n, r, i, o, s, a) { const l = qn(e, n); let u, c = e.inputs; !a && null != c && (u = c[r]) ? (Rb(t, n, u, r, i), Xa(e) && function yx(t, e) { const n = An(e, t); 16 & n[2] || (n[2] |= 32) }(n, e.index)) : 3 & e.type && (r = function bx(t) { return "class" === t ? "className" : "for" === t ? "htmlFor" : "formaction" === t ? "formAction" : "innerHtml" === t ? "innerHTML" : "readonly" === t ? "readOnly" : "tabindex" === t ? "tabIndex" : t }(r), i = null != s ? s(i, e.value || "", r) : i, Et(o) ? o.setProperty(l, r, i) : Ku(r) || (l.setProperty ? l.setProperty(r, i) : l[r] = i)) } function af(t, e, n, r) { let i = !1; if (ap()) { const o = function Cx(t, e, n) { const r = t.directiveRegistry; let i = null; if (r) for (let o = 0; o < r.length; o++) { const s = r[o]; Og(n, s.selectors, !1) && (i || (i = []), dl(Cs(n, e), t, s.type), sr(s) ? (Tb(t, n), i.unshift(s)) : i.push(s)) } return i }(t, e, n), s = null === r ? null : { "": -1 }; if (null !== o) { i = !0, xb(n, t.data.length, o.length); for (let u = 0; u < o.length; u++) { const d = o[u]; d.providersResolver && d.providersResolver(d) } let a = !1, l = !1, c = Oo(t, e, o.length, null); for (let u = 0; u < o.length; u++) { const d = o[u]; n.mergedAttrs = ll(n.mergedAttrs, d.hostAttrs), kb(t, n, e, c, d), Tx(c, d, s), null !== d.contentQueries && (n.flags |= 8), (null !== d.hostBindings || null !== d.hostAttrs || 0 !== d.hostVars) && (n.flags |= 128); const f = d.type.prototype; !a && (f.ngOnChanges || f.ngOnInit || f.ngDoCheck) && ((t.preOrderHooks || (t.preOrderHooks = [])).push(n.index), a = !0), !l && (f.ngOnChanges || f.ngDoCheck) && ((t.preOrderCheckHooks || (t.preOrderCheckHooks = [])).push(n.index), l = !0), c++ } !function gx(t, e) { const r = e.directiveEnd, i = t.data, o = e.attrs, s = []; let a = null, l = null; for (let c = e.directiveStart; c < r; c++) { const u = i[c], d = u.inputs, f = null === o || Ng(e) ? null : Ax(d, o); s.push(f), a = Eb(d, c, a), l = Eb(u.outputs, c, l) } null !== a && (a.hasOwnProperty("class") && (e.flags |= 16), a.hasOwnProperty("style") && (e.flags |= 32)), e.initialInputs = s, e.inputs = a, e.outputs = l }(t, n) } s && function Mx(t, e, n) { if (e) { const r = t.localNames = []; for (let i = 0; i < e.length; i += 2) { const o = n[e[i + 1]]; if (null == o) throw new P(-301, !1); r.push(e[i], o) } } }(n, r, s) } return n.mergedAttrs = ll(n.mergedAttrs, n.attrs), i } function Cb(t, e, n, r, i, o) { const s = o.hostBindings; if (s) { let a = t.hostBindingOpCodes; null === a && (a = t.hostBindingOpCodes = []); const l = ~e.index; (function wx(t) { let e = t.length; for (; e > 0;) { const n = t[--e]; if ("number" == typeof n && n < 0) return n } return 0 })(a) != l && a.push(l), a.push(r, i, s) } } function Mb(t, e) { null !== t.hostBindings && t.hostBindings(1, e) } function Tb(t, e) { e.flags |= 2, (t.components || (t.components = [])).push(e.index) } function Tx(t, e, n) { if (n) { if (e.exportAs) for (let r = 0; r < e.exportAs.length; r++)n[e.exportAs[r]] = t; sr(e) && (n[""] = t) } } function xb(t, e, n) { t.flags |= 1, t.directiveStart = e, t.directiveEnd = e + n, t.providerIndexes = e } function kb(t, e, n, r, i) { t.data[r] = i; const o = i.factory || (i.factory = Si(i.type)), s = new Ds(o, sr(i), T); t.blueprint[r] = s, n[r] = s, Cb(t, e, 0, r, Oo(t, n, i.hostVars, ge), i) } function xx(t, e, n) { const r = qn(e, t), i = _b(n), o = t[10], s = Pl(t, js(t, i, null, n.onPush ? 32 : 16, r, e, o, o.createRenderer(r, n), null, null, null)); t[e.index] = s } function Dr(t, e, n, r, i, o) { const s = qn(t, e); !function lf(t, e, n, r, i, o, s) { if (null == o) Et(t) ? t.removeAttribute(e, i, n) : e.removeAttribute(i); else { const a = null == s ? ie(o) : s(o, r || "", i); Et(t) ? t.setAttribute(e, i, a, n) : n ? e.setAttributeNS(n, i, a) : e.setAttribute(i, a) } }(e[11], s, o, t.value, n, r, i) } function kx(t, e, n, r, i, o) { const s = o[e]; if (null !== s) { const a = r.setInput; for (let l = 0; l < s.length;) { const c = s[l++], u = s[l++], d = s[l++]; null !== a ? r.setInput(n, d, c, u) : n[u] = d } } } function Ax(t, e) { let n = null, r = 0; for (; r < e.length;) { const i = e[r]; if (0 !== i) if (5 !== i) { if ("number" == typeof i) break; t.hasOwnProperty(i) && (null === n && (n = []), n.push(i, t[i], e[r + 1])), r += 2 } else r += 2; else r += 4 } return n } function Ab(t, e, n, r) { return new Array(t, !0, !1, e, null, 0, r, n, null, null) } function Fx(t, e) { const n = An(e, t); if (Hu(n)) { const r = n[1]; 48 & n[2] ? Ro(r, n, r.template, n[8]) : n[5] > 0 && cf(n) } } function cf(t) { for (let r = wd(t); null !== r; r = Dd(r))for (let i = 10; i < r.length; i++) { const o = r[i]; if (512 & o[2]) { const s = o[1]; Ro(s, o, s.template, o[8]) } else o[5] > 0 && cf(o) } const n = t[1].components; if (null !== n) for (let r = 0; r < n.length; r++) { const i = An(n[r], t); Hu(i) && i[5] > 0 && cf(i) } } function Nx(t, e) { const n = An(e, t), r = n[1]; (function Ox(t, e) { for (let n = e.length; n < t.blueprint.length; n++)e.push(t.blueprint[n]) })(r, n), $s(r, n, n[8]) } function Pl(t, e) { return t[13] ? t[14][4] = e : t[13] = e, t[14] = e, e } function uf(t) { for (; t;) { t[2] |= 32; const e = Vs(t); if (LE(t) && !e) return t; t = e } return null } function Sb(t) { !function df(t) { for (let e = 0; e < t.components.length; e++) { const n = t.components[e], r = yd(n); if (null !== r) { const i = r[1]; hx(i, r, i.template, n) } } }(t[8]) } function hf(t, e, n) { qu(0), e(t, n) } const Px = (() => Promise.resolve(null))(); function Ib(t) { return t[7] || (t[7] = []) } function Fb(t) { return t.cleanup || (t.cleanup = []) } function Ob(t, e) { const n = t[9], r = n ? n.get(ko, null) : null; r && r.handleError(e) } function Rb(t, e, n, r, i) { for (let o = 0; o < n.length;) { const s = n[o++], a = n[o++], l = e[s], c = t.data[s]; null !== c.setInput ? c.setInput(l, i, r, a) : l[a] = i } } function Kr(t, e, n) { const r = el(e, t); !function pg(t, e, n) { Et(t) ? t.setValue(e, n) : e.textContent = n }(t[11], r, n) } function Ll(t, e, n) { let r = n ? t.styles : null, i = n ? t.classes : null, o = 0; if (null !== e) for (let s = 0; s < e.length; s++) { const a = e[s]; "number" == typeof a ? o = a : 1 == o ? i = ms(i, a) : 2 == o && (r = ms(r, a + ": " + e[++s] + ";")) } n ? t.styles = r : t.stylesWithoutHost = r, n ? t.classes = i : t.classesWithoutHost = i } function Wx() { const t = Ht(); il(k()[1], t) } function je(t) { let e = function Wb(t) { return Object.getPrototypeOf(t.prototype).constructor }(t.type), n = !0; const r = [t]; for (; e;) { let i; if (sr(t)) i = e.\u0275cmp || e.\u0275dir; else { if (e.\u0275cmp) throw new P(903, ""); i = e.\u0275dir } if (i) { if (n) { r.push(i); const s = t; s.inputs = pf(t.inputs), s.declaredInputs = pf(t.declaredInputs), s.outputs = pf(t.outputs); const a = i.hostBindings; a && Yx(t, a); const l = i.viewQuery, c = i.contentQueries; if (l && Kx(t, l), c && Qx(t, c), Ci(t.inputs, i.inputs), Ci(t.declaredInputs, i.declaredInputs), Ci(t.outputs, i.outputs), sr(i) && i.data.animation) { const u = t.data; u.animation = (u.animation || []).concat(i.data.animation) } } const o = i.features; if (o) for (let s = 0; s < o.length; s++) { const a = o[s]; a && a.ngInherit && a(t), a === je && (n = !1) } } e = Object.getPrototypeOf(e) } !function Zx(t) { let e = 0, n = null; for (let r = t.length - 1; r >= 0; r--) { const i = t[r]; i.hostVars = e += i.hostVars, i.hostAttrs = ll(i.hostAttrs, n = ll(n, i.hostAttrs)) } }(r) } function pf(t) { return t === co ? {} : t === Ge ? [] : t } function Kx(t, e) { const n = t.viewQuery; t.viewQuery = n ? (r, i) => { e(r, i), n(r, i) } : e } function Qx(t, e) { const n = t.contentQueries; t.contentQueries = n ? (r, i, o) => { e(r, i, o), n(r, i, o) } : e } function Yx(t, e) { const n = t.hostBindings; t.hostBindings = n ? (r, i) => { e(r, i), n(r, i) } : e } let Vl = null; function Ri() { if (!Vl) { const t = rt.Symbol; if (t && t.iterator) Vl = t.iterator; else { const e = Object.getOwnPropertyNames(Map.prototype); for (let n = 0; n < e.length; ++n) { const r = e[n]; "entries" !== r && "size" !== r && Map.prototype[r] === Map.prototype.entries && (Vl = r) } } } return Vl } function zs(t) { return !!function gf(t) { return null !== t && ("function" == typeof t || "object" == typeof t) }(t) && (Array.isArray(t) || !(t instanceof Map) && Ri() in t) } function nn(t, e, n) { return !Object.is(t[e], n) && (t[e] = n, !0) } function Pi(t, e, n, r) { const i = nn(t, e, n); return nn(t, e + 1, r) || i } function mn(t, e, n, r) { const i = k(); return nn(i, bo(), e) && (Pe(), Dr(Ct(), i, t, e, n, r)), mn } function it(t, e, n, r, i, o, s, a) { const l = k(), c = Pe(), u = t + 22, d = c.firstCreatePass ? function ik(t, e, n, r, i, o, s, a, l) { const c = e.consts, u = No(e, t, 4, s || null, si(c, a)); af(e, n, u, si(c, l)), il(e, u); const d = u.tViews = Rl(2, u, r, i, o, e.directiveRegistry, e.pipeRegistry, null, e.schemas, c); return null !== e.queries && (e.queries.template(e, u), d.queries = e.queries.embeddedTView(u)), u }(u, c, l, e, n, r, i, o, s) : c.data[u]; _r(d, !1); const f = l[11].createComment(""); kl(c, l, f, d), en(f, l), Pl(l, l[u] = Ab(f, l, f, d)), Ja(d) && of(c, l, d), null != s && sf(l, d, a) } function Go(t) { return function go(t, e) { return t[e] }(function rC() { return he.lFrame.contextLView }(), 22 + t) } function Ae(t, e, n) { const r = k(); return nn(r, bo(), e) && Nn(Pe(), Ct(), r, t, e, r[11], n, !1), Ae } function bf(t, e, n, r, i) { const s = i ? "class" : "style"; Rb(t, n, e.inputs[s], s, r) } function Fe(t, e, n, r) { const i = k(), o = Pe(), s = 22 + t, a = i[11], l = i[s] = Cd(a, e, function mC() { return he.lFrame.currentNamespace }()), c = o.firstCreatePass ? function sk(t, e, n, r, i, o, s) { const a = e.consts, c = No(e, t, 2, i, si(a, o)); return af(e, n, c, si(a, s)), null !== c.attrs && Ll(c, c.attrs, !1), null !== c.mergedAttrs && Ll(c, c.mergedAttrs, !0), null !== e.queries && e.queries.elementStart(e, c), c }(s, o, i, 0, e, n, r) : o.data[s]; _r(c, !0); const u = c.mergedAttrs; null !== u && al(a, l, u); const d = c.classes; null !== d && Sd(a, l, d); const f = c.styles; return null !== f && Sg(a, l, f), 64 != (64 & c.flags) && kl(o, i, l, c), 0 === function XE() { return he.lFrame.elementDepthCount }() && en(l, i), function JE() { he.lFrame.elementDepthCount++ }(), Ja(c) && (of(o, i, c), yb(o, c, i)), null !== r && sf(i, c), Fe } function Le() { let t = Ht(); $u() ? zu() : (t = t.parent, _r(t, !1)); const e = t; !function eC() { he.lFrame.elementDepthCount-- }(); const n = Pe(); return n.firstCreatePass && (il(n, t), Fu(t) && n.queries.elementEnd(t)), null != e.classesWithoutHost && function _C(t) { return 0 != (16 & t.flags) }(e) && bf(n, e, k(), e.classesWithoutHost, !0), null != e.stylesWithoutHost && function vC(t) { return 0 != (32 & t.flags) }(e) && bf(n, e, k(), e.stylesWithoutHost, !1), Le } function ur(t, e, n, r) { return Fe(t, e, n, r), Le(), ur } function Gs(t, e, n) { const r = k(), i = Pe(), o = t + 22, s = i.firstCreatePass ? function ak(t, e, n, r, i) { const o = e.consts, s = si(o, r), a = No(e, t, 8, "ng-container", s); return null !== s && Ll(a, s, !0), af(e, n, a, si(o, i)), null !== e.queries && e.queries.elementStart(e, a), a }(o, i, r, e, n) : i.data[o]; _r(s, !0); const a = r[o] = r[11].createComment(""); return kl(i, r, a, s), en(a, r), Ja(s) && (of(i, r, s), yb(i, s, r)), null != n && sf(r, s), Gs } function qs() { let t = Ht(); const e = Pe(); return $u() ? zu() : (t = t.parent, _r(t, !1)), e.firstCreatePass && (il(e, t), Fu(t) && e.queries.elementEnd(t)), qs } function Ws() { return k() } function Hl(t) { return !!t && "function" == typeof t.then } const oy = function iy(t) { return !!t && "function" == typeof t.subscribe }; function St(t, e, n, r) { const i = k(), o = Pe(), s = Ht(); return function ay(t, e, n, r, i, o, s, a) { const l = Ja(r), u = t.firstCreatePass && Fb(t), d = e[8], f = Ib(e); let h = !0; if (3 & r.type || a) { const w = qn(r, e), C = a ? a(w) : w, I = f.length, E = a ? R => a(Rt(R[r.index])) : r.index; if (Et(n)) { let R = null; if (!a && l && (R = function lk(t, e, n, r) { const i = t.cleanup; if (null != i) for (let o = 0; o < i.length - 1; o += 2) { const s = i[o]; if (s === n && i[o + 1] === r) { const a = e[7], l = i[o + 2]; return a.length > l ? a[l] : null } "string" == typeof s && (o += 2) } return null }(t, e, i, r.index)), null !== R) (R.__ngLastListenerFn__ || R).__ngNextListenerFn__ = o, R.__ngLastListenerFn__ = o, h = !1; else { o = yf(r, e, d, o, !1); const be = n.listen(C, i, o); f.push(o, be), u && u.push(i, E, I, I + 1) } } else o = yf(r, e, d, o, !0), C.addEventListener(i, o, s), f.push(o), u && u.push(i, E, I, s) } else o = yf(r, e, d, o, !1); const m = r.outputs; let b; if (h && null !== m && (b = m[i])) { const w = b.length; if (w) for (let C = 0; C < w; C += 2) { const Oe = e[b[C]][b[C + 1]].subscribe(o), vt = f.length; f.push(o, Oe), u && u.push(i, r.index, vt, -(vt + 1)) } } }(o, i, i[11], s, t, e, !!n, r), St } function ly(t, e, n, r) { try { return !1 !== n(r) } catch (i) { return Ob(t, i), !1 } } function yf(t, e, n, r, i) { return function o(s) { if (s === Function) return r; uf(2 & t.flags ? An(t.index, e) : e); let l = ly(e, 0, r, s), c = o.__ngNextListenerFn__; for (; c;)l = ly(e, 0, c, s) && l, c = c.__ngNextListenerFn__; return i && !1 === l && (s.preventDefault(), s.returnValue = !1), l } } function lt(t = 1) { return function lC(t) { return (he.lFrame.contextLView = function cC(t, e) { for (; t > 0;)e = e[15], t--; return e }(t, he.lFrame.contextLView))[8] }(t) } function ck(t, e) { let n = null; const r = function pT(t) { const e = t.attrs; if (null != e) { const n = e.indexOf(5); if (0 == (1 & n)) return e[n + 1] } return null }(t); for (let i = 0; i < e.length; i++) { const o = e[i]; if ("*" !== o) { if (null === r ? Og(t, o, !0) : yT(r, o)) return i } else n = i } return n } function _f(t) { const e = k()[16][6]; if (!e.projection) { const r = e.projection = ks(t ? t.length : 1, null), i = r.slice(); let o = e.child; for (; null !== o;) { const s = t ? ck(o, t) : 0; null !== s && (i[s] ? i[s].projectionNext = o : r[s] = o, i[s] = o), o = o.next } } } function Cr(t, e = 0, n) { const r = k(), i = Pe(), o = No(i, 22 + t, 16, null, n || null); null === o.projection && (o.projection = e), zu(), 64 != (64 & o.flags) && function lT(t, e, n) { Ag(e[11], 0, e, n, yg(t, n, e), Eg(n.parent || e[6], n, e)) }(i, r, o) } function yy(t, e, n, r, i) { const o = t[n + 1], s = null === e; let a = r ? lr(o) : Zr(o), l = !1; for (; 0 !== a && (!1 === l || s);) { const u = t[a + 1]; fk(t[a], e) && (l = !0, t[a + 1] = r ? Zd(u) : qd(u)), a = r ? lr(u) : Zr(u) } l && (t[n + 1] = r ? qd(o) : Zd(o)) } function fk(t, e) { return null === t || null == e || (Array.isArray(t) ? t[1] : t) === e || !(!Array.isArray(t) || "string" != typeof e) && Mo(t, e) >= 0 } function Zs(t, e, n) { return dr(t, e, n, !1), Zs } function En(t, e) { return dr(t, e, null, !0), En } function dr(t, e, n, r) { const i = k(), o = Pe(), s = function Gr(t) { const e = he.lFrame, n = e.bindingIndex; return e.bindingIndex = e.bindingIndex + t, n }(2); o.firstUpdatePass && function Ty(t, e, n, r) { const i = t.data; if (null === i[n + 1]) { const o = i[fn()], s = function My(t, e) { return e >= t.expandoStartIndex }(t, n); (function Sy(t, e) { return 0 != (t.flags & (e ? 16 : 32)) })(o, r) && null === e && !s && (e = !1), e = function wk(t, e, n, r) { const i = function Gu(t) { const e = he.lFrame.currentDirectiveIndex; return -1 === e ? null : t[e] }(t); let o = r ? e.residualClasses : e.residualStyles; if (null === i) 0 === (r ? e.classBindings : e.styleBindings) && (n = Ks(n = wf(null, t, e, n, r), e.attrs, r), o = null); else { const s = e.directiveStylingLast; if (-1 === s || t[s] !== i) if (n = wf(i, t, e, n, r), null === o) { let l = function Dk(t, e, n) { const r = n ? e.classBindings : e.styleBindings; if (0 !== Zr(r)) return t[lr(r)] }(t, e, r); void 0 !== l && Array.isArray(l) && (l = wf(null, t, e, l[1], r), l = Ks(l, e.attrs, r), function Ek(t, e, n, r) { t[lr(n ? e.classBindings : e.styleBindings)] = r }(t, e, r, l)) } else o = function Ck(t, e, n) { let r; const i = e.directiveEnd; for (let o = 1 + e.directiveStylingLast; o < i; o++)r = Ks(r, t[o].hostAttrs, n); return Ks(r, e.attrs, n) }(t, e, r) } return void 0 !== o && (r ? e.residualClasses = o : e.residualStyles = o), n }(i, o, e, r), function uk(t, e, n, r, i, o) { let s = o ? e.classBindings : e.styleBindings, a = lr(s), l = Zr(s); t[r] = n; let u, c = !1; if (Array.isArray(n)) { const d = n; u = d[1], (null === u || Mo(d, u) > 0) && (c = !0) } else u = n; if (i) if (0 !== l) { const f = lr(t[a + 1]); t[r + 1] = Fl(f, a), 0 !== f && (t[f + 1] = Wd(t[f + 1], r)), t[a + 1] = function ex(t, e) { return 131071 & t | e << 17 }(t[a + 1], r) } else t[r + 1] = Fl(a, 0), 0 !== a && (t[a + 1] = Wd(t[a + 1], r)), a = r; else t[r + 1] = Fl(l, 0), 0 === a ? a = r : t[l + 1] = Wd(t[l + 1], r), l = r; c && (t[r + 1] = qd(t[r + 1])), yy(t, u, r, !0), yy(t, u, r, !1), function dk(t, e, n, r, i) { const o = i ? t.residualClasses : t.residualStyles; null != o && "string" == typeof e && Mo(o, e) >= 0 && (n[r + 1] = Zd(n[r + 1])) }(e, u, t, r, o), s = Fl(a, l), o ? e.classBindings = s : e.styleBindings = s }(i, o, e, n, s, r) } }(o, t, s, r), e !== ge && nn(i, s, e) && function ky(t, e, n, r, i, o, s, a) { if (!(3 & e.type)) return; const l = t.data, c = l[a + 1]; jl(function lb(t) { return 1 == (1 & t) }(c) ? Ay(l, e, n, i, Zr(c), s) : void 0) || (jl(o) || function ab(t) { return 2 == (2 & t) }(c) && (o = Ay(l, null, n, i, a, s)), function uT(t, e, n, r, i) { const o = Et(t); if (e) i ? o ? t.addClass(n, r) : n.classList.add(r) : o ? t.removeClass(n, r) : n.classList.remove(r); else { let s = -1 === r.indexOf("-") ? void 0 : Fn.DashCase; if (null == i) o ? t.removeStyle(n, r, s) : n.style.removeProperty(r); else { const a = "string" == typeof i && i.endsWith("!important"); a && (i = i.slice(0, -10), s |= Fn.Important), o ? t.setStyle(n, r, i, s) : n.style.setProperty(r, i, a ? "important" : "") } } }(r, s, el(fn(), n), i, o)) }(o, o.data[fn()], i, i[11], t, i[s + 1] = function xk(t, e) { return null == t || ("string" == typeof e ? t += e : "object" == typeof t && (t = Ze(ci(t)))), t }(e, n), r, s) } function wf(t, e, n, r, i) { let o = null; const s = n.directiveEnd; let a = n.directiveStylingLast; for (-1 === a ? a = n.directiveStart : a++; a < s && (o = e[a], r = Ks(r, o.hostAttrs, i), o !== t);)a++; return null !== t && (n.directiveStylingLast = a), r } function Ks(t, e, n) { const r = n ? 1 : 2; let i = -1; if (null !== e) for (let o = 0; o < e.length; o++) { const s = e[o]; "number" == typeof s ? i = s : i === r && (Array.isArray(t) || (t = void 0 === t ? [] : ["", t]), In(t, s, !!n || e[++o])) } return void 0 === t ? null : t } function Ay(t, e, n, r, i, o) { const s = null === e; let a; for (; i > 0;) { const l = t[i], c = Array.isArray(l), u = c ? l[1] : l, d = null === u; let f = n[i + 1]; f === ge && (f = d ? Ge : void 0); let h = d ? nd(f, r) : u === r ? f : void 0; if (c && !jl(h) && (h = nd(l, r)), jl(h) && (a = h, s)) return a; const m = t[i + 1]; i = s ? lr(m) : Zr(m) } if (null !== e) { let l = o ? e.residualClasses : e.residualStyles; null != l && (a = nd(l, r)) } return a } function jl(t) { return void 0 !== t } function Kt(t, e = "") { const n = k(), r = Pe(), i = t + 22, o = r.firstCreatePass ? No(r, i, 1, e, null) : r.data[i], s = n[i] = function Ed(t, e) { return Et(t) ? t.createText(e) : t.createTextNode(e) }(n[11], e); kl(r, n, s, o), _r(o, !1) } function Wo(t) { return Df("", t, ""), Wo } function Df(t, e, n) { const r = k(), i = function Lo(t, e, n, r) { return nn(t, bo(), n) ? e + ie(n) + r : ge }(r, t, e, n); return i !== ge && Kr(r, fn(), i), Df } function Ef(t, e, n) { const r = k(); return nn(r, bo(), e) && Nn(Pe(), Ct(), r, t, e, r[11], n, !0), Ef } const Ko = "en-US"; let Yy = Ko; function Tf(t, e, n, r, i) { if (t = J(t), Array.isArray(t)) for (let o = 0; o < t.length; o++)Tf(t[o], e, n, r, i); else { const o = Pe(), s = k(); let a = Oi(t) ? t : J(t.provide), l = Zg(t); const c = Ht(), u = 1048575 & c.providerIndexes, d = c.directiveStart, f = c.providerIndexes >> 20; if (Oi(t) || !t.multi) { const h = new Ds(l, i, T), m = kf(a, e, i ? u : u + f, d); -1 === m ? (dl(Cs(c, s), o, a), xf(o, t, e.length), e.push(a), c.directiveStart++, c.directiveEnd++, i && (c.providerIndexes += 1048576), n.push(h), s.push(h)) : (n[m] = h, s[m] = h) } else { const h = kf(a, e, u + f, d), m = kf(a, e, u, u + f), b = h >= 0 && n[h], w = m >= 0 && n[m]; if (i && !w || !i && !b) { dl(Cs(c, s), o, a); const C = function GA(t, e, n, r, i) { const o = new Ds(t, n, T); return o.multi = [], o.index = e, o.componentProviders = 0, D_(o, i, r && !n), o }(i ? UA : zA, n.length, i, r, l); !i && w && (n[m].providerFactory = C), xf(o, t, e.length, 0), e.push(a), c.directiveStart++, c.directiveEnd++, i && (c.providerIndexes += 1048576), n.push(C), s.push(C) } else xf(o, t, h > -1 ? h : m, D_(n[i ? m : h], l, !i && r)); !i && r && w && n[m].componentProviders++ } } } function xf(t, e, n, r) { const i = Oi(e), o = function AT(t) { return !!t.useClass }(e); if (i || o) { const l = (o ? J(e.useClass) : e).prototype.ngOnDestroy; if (l) { const c = t.destroyHooks || (t.destroyHooks = []); if (!i && e.multi) { const u = c.indexOf(n); -1 === u ? c.push(n, [r, l]) : c[u + 1].push(r, l) } else c.push(n, l) } } } function D_(t, e, n) { return n && t.componentProviders++, t.multi.push(e) - 1 } function kf(t, e, n, r) { for (let i = n; i < r; i++)if (e[i] === t) return i; return -1 } function zA(t, e, n, r) { return Af(this.multi, []) } function UA(t, e, n, r) { const i = this.multi; let o; if (this.providerFactory) { const s = this.providerFactory.componentProviders, a = Ms(n, n[1], this.providerFactory.index, r); o = a.slice(0, s), Af(i, o); for (let l = s; l < a.length; l++)o.push(a[l]) } else o = [], Af(i, o); return o } function Af(t, e) { for (let n = 0; n < t.length; n++)e.push((0, t[n])()); return e } function ct(t, e = []) { return n => { n.providersResolver = (r, i) => function $A(t, e, n) { const r = Pe(); if (r.firstCreatePass) { const i = sr(t); Tf(n, r.data, r.blueprint, i, !0), Tf(e, r.data, r.blueprint, i, !1) } }(r, i ? i(t) : t, e) } } class WA { resolveComponentFactory(e) { throw function qA(t) { const e = Error(`No component factory found for ${Ze(t)}. Did you add it to @NgModule.entryComponents?`); return e.ngComponent = t, e }(e) } } let Vi = (() => { class t { } return t.NULL = new WA, t })(); class Bi { } class C_ { } function QA() { return Yo(Ht(), k()) } function Yo(t, e) { return new Tt(qn(t, e)) } let Tt = (() => { class t { constructor(n) { this.nativeElement = n } } return t.__NG_ELEMENT_ID__ = QA, t })(); function YA(t) { return t instanceof Tt ? t.nativeElement : t } class Xo { } let Qr = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => function JA() { const t = k(), n = An(Ht().index, t); return function XA(t) { return t[11] }(Dn(n) ? n : t) }(), t })(), eS = (() => { class t { } return t.\u0275prov = pe({ token: t, providedIn: "root", factory: () => null }), t })(); class Hi { constructor(e) { this.full = e, this.major = e.split(".")[0], this.minor = e.split(".")[1], this.patch = e.split(".").slice(2).join(".") } } const tS = new Hi("14.0.2"), Sf = {}; function ql(t, e, n, r, i = !1) { for (; null !== n;) { const o = e[n.index]; if (null !== o && r.push(Rt(o)), or(o)) for (let a = 10; a < o.length; a++) { const l = o[a], c = l[1].firstChild; null !== c && ql(l[1], l, c, r) } const s = n.type; if (8 & s) ql(t, e, n.child, r); else if (32 & s) { const a = vd(n, e); let l; for (; l = a();)r.push(l) } else if (16 & s) { const a = xg(e, n); if (Array.isArray(a)) r.push(...a); else { const l = Vs(e[16]); ql(l[1], l, a, r, !0) } } n = i ? n.projectionNext : n.next } return r } class ea { constructor(e, n) { this._lView = e, this._cdRefInjectingView = n, this._appRef = null, this._attachedToViewContainer = !1 } get rootNodes() { const e = this._lView, n = e[1]; return ql(n, e, n.firstChild, []) } get context() { return this._lView[8] } set context(e) { this._lView[8] = e } get destroyed() { return 128 == (128 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const e = this._lView[3]; if (or(e)) { const n = e[8], r = n ? n.indexOf(this) : -1; r > -1 && (Md(e, r), ml(n, r)) } this._attachedToViewContainer = !1 } bg(this._lView[1], this._lView) } onDestroy(e) { Db(this._lView[1], this._lView, null, e) } markForCheck() { uf(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -65 } reattach() { this._lView[2] |= 64 } detectChanges() { !function ff(t, e, n) { const r = e[10]; r.begin && r.begin(); try { Ro(t, e, t.template, n) } catch (i) { throw Ob(e, i), i } finally { r.end && r.end() } }(this._lView[1], this._lView, this.context) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new P(902, ""); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function eT(t, e) { Bs(t, e, e[11], 2, null, null) }(this._lView[1], this._lView) } attachToAppRef(e) { if (this._attachedToViewContainer) throw new P(902, ""); this._appRef = e } } class nS extends ea { constructor(e) { super(e), this._view = e } detectChanges() { Sb(this._view) } checkNoChanges() { } get context() { return null } } class If extends Vi { constructor(e) { super(), this.ngModule = e } resolveComponentFactory(e) { const n = at(e); return new Ff(n, this.ngModule) } } function M_(t) { const e = []; for (let n in t) t.hasOwnProperty(n) && e.push({ propName: t[n], templateName: n }); return e } class iS { constructor(e, n) { this.injector = e, this.parentInjector = n } get(e, n, r) { const i = this.injector.get(e, Sf, r); return i !== Sf || n === Sf ? i : this.parentInjector.get(e, n, r) } } class Ff extends C_ { constructor(e, n) { super(), this.componentDef = e, this.ngModule = n, this.componentType = e.type, this.selector = function vT(t) { return t.map(_T).join(",") }(e.selectors), this.ngContentSelectors = e.ngContentSelectors ? e.ngContentSelectors : [], this.isBoundToModule = !!n } get inputs() { return M_(this.componentDef.inputs) } get outputs() { return M_(this.componentDef.outputs) } create(e, n, r, i) { let o = (i = i || this.ngModule) instanceof Hs ? i : i?.injector; o && null !== this.componentDef.getStandaloneInjector && (o = this.componentDef.getStandaloneInjector(o) || o); const s = o ? new iS(e, o) : e, a = s.get(Xo, rp), l = s.get(eS, null), c = a.createRenderer(null, this.componentDef), u = this.componentDef.selectors[0][0] || "div", d = r ? function wb(t, e, n) { if (Et(t)) return t.selectRootElement(e, n === rr.ShadowDom); let r = "string" == typeof e ? t.querySelector(e) : e; return r.textContent = "", r }(c, r, this.componentDef.encapsulation) : Cd(a.createRenderer(null, this.componentDef), u, function rS(t) { const e = t.toLowerCase(); return "svg" === e ? "svg" : "math" === e ? "math" : null }(u)), f = this.componentDef.onPush ? 288 : 272, h = function qb(t, e) { return { components: [], scheduler: t || GM, clean: Px, playerHandler: e || null, flags: 0 } }(), m = Rl(0, null, null, 1, 0, null, null, null, null, null), b = js(null, m, h, f, null, null, a, c, l, s, null); let w, C; nl(b); try { const I = function Ub(t, e, n, r, i, o) { const s = n[1]; n[22] = t; const l = No(s, 22, 2, "#host", null), c = l.mergedAttrs = e.hostAttrs; null !== c && (Ll(l, c, !0), null !== t && (al(i, t, c), null !== l.classes && Sd(i, t, l.classes), null !== l.styles && Sg(i, t, l.styles))); const u = r.createRenderer(t, e), d = js(n, _b(e), null, e.onPush ? 32 : 16, n[22], l, r, u, o || null, null, null); return s.firstCreatePass && (dl(Cs(l, n), s, e.type), Tb(s, l), xb(l, n.length, 1)), Pl(n, d), n[22] = d }(d, this.componentDef, b, a, c); if (d) if (r) al(c, d, ["ng-version", tS.full]); else { const { attrs: E, classes: R } = function wT(t) { const e = [], n = []; let r = 1, i = 2; for (; r < t.length;) { let o = t[r]; if ("string" == typeof o) 2 === i ? "" !== o && e.push(o, t[++r]) : 8 === i && n.push(o); else { if (!ar(i)) break; i = o } r++ } return { attrs: e, classes: n } }(this.componentDef.selectors[0]); E && al(c, d, E), R && R.length > 0 && Sd(c, d, R.join(" ")) } if (C = Bu(m, 22), void 0 !== n) { const E = C.projection = []; for (let R = 0; R < this.ngContentSelectors.length; R++) { const be = n[R]; E.push(null != be ? Array.from(be) : null) } } w = function Gb(t, e, n, r, i) { const o = n[1], s = function vx(t, e, n) { const r = Ht(); t.firstCreatePass && (n.providersResolver && n.providersResolver(n), kb(t, r, e, Oo(t, e, 1, null), n)); const i = Ms(e, t, r.directiveStart, r); en(i, e); const o = qn(r, e); return o && en(o, e), i }(o, n, e); if (r.components.push(s), t[8] = s, null !== i) for (const l of i) l(s, e); if (e.contentQueries) { const l = Ht(); e.contentQueries(1, s, l.directiveStart) } const a = Ht(); return !o.firstCreatePass || null === e.hostBindings && null === e.hostAttrs || (ai(a.index), Cb(n[1], a, 0, a.directiveStart, a.directiveEnd, e), Mb(e, s)), s }(I, this.componentDef, b, h, [Wx]), $s(m, b, null) } finally { rl() } return new sS(this.componentType, w, Yo(C, b), b, C) } } class sS extends class KA { }{ constructor(e, n, r, i, o) { super(), this.location = r, this._rootLView = i, this._tNode = o, this.instance = n, this.hostView = this.changeDetectorRef = new nS(i), this.componentType = e } get injector() { return new vo(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(e) { this.hostView.onDestroy(e) } } class T_ extends Bi { constructor(e, n) { super(), this._parent = n, this._bootstrapComponents = [], this.injector = this, this.destroyCbs = [], this.componentFactoryResolver = new If(this); const r = function xn(t, e) { const n = t[Wm] || null; if (!n && !0 === e) throw new Error(`Type ${Ze(t)} does not have '\u0275mod' property.`); return n }(e); this._bootstrapComponents = function Wr(t) { return t instanceof Function ? t() : t }(r.bootstrap), this._r3Injector = Qg(e, n, [{ provide: Bi, useValue: this }, { provide: Vi, useValue: this.componentFactoryResolver }], Ze(e), new Set(["environment"])), this._r3Injector.resolveInjectorInitializers(), this.instance = this.get(e) } get(e, n = tn.THROW_IF_NOT_FOUND, r = ue.Default) { return e === tn || e === Bi || e === Nd ? this : this._r3Injector.get(e, n, r) } destroy() { const e = this._r3Injector; !e.destroyed && e.destroy(), this.destroyCbs.forEach(n => n()), this.destroyCbs = null } onDestroy(e) { this.destroyCbs.push(e) } } class Nf extends class ZA { }{ constructor(e) { super(), this.moduleType = e } create(e) { return new T_(this.moduleType, e) } } function Wl(t, e, n, r, i, o, s) { return function I_(t, e, n, r, i, o, s, a, l) { const c = e + n; return function Wn(t, e, n, r, i, o) { const s = Pi(t, e, n, r); return Pi(t, e + 2, i, o) || s }(t, c, i, o, s, a) ? function Er(t, e, n) { return t[e] = n }(t, c + 4, l ? r.call(l, i, o, s, a) : r(i, o, s, a)) : function ta(t, e) { const n = t[e]; return n === ge ? void 0 : n }(t, c + 4) }(k(), function dn() { const t = he.lFrame; let e = t.bindingRootIndex; return -1 === e && (e = t.bindingRootIndex = t.tView.bindingStartIndex), e }(), t, e, n, r, i, o, s) } function Of(t) { return e => { setTimeout(t, void 0, e) } } const Ye = class kS extends Qt { constructor(e = !1) { super(), this.__isAsync = e } emit(e) { super.next(e) } subscribe(e, n, r) { let i = e, o = n || (() => null), s = r; if (e && "object" == typeof e) { const l = e; i = l.next?.bind(l), o = l.error?.bind(l), s = l.complete?.bind(l) } this.__isAsync && (o = Of(o), i && (i = Of(i)), s && (s = Of(s))); const a = super.subscribe({ next: i, error: o, complete: s }); return e instanceof ln && e.add(a), a } }; function AS() { return this._results[Ri()]() } class Rf { constructor(e = !1) { this._emitDistinctChangesOnly = e, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0; const n = Ri(), r = Rf.prototype; r[n] || (r[n] = AS) } get changes() { return this._changes || (this._changes = new Ye) } get(e) { return this._results[e] } map(e) { return this._results.map(e) } filter(e) { return this._results.filter(e) } find(e) { return this._results.find(e) } reduce(e, n) { return this._results.reduce(e, n) } forEach(e) { this._results.forEach(e) } some(e) { return this._results.some(e) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(e, n) { const r = this; r.dirty = !1; const i = Sn(e); (this._changesDetected = !function SC(t, e, n) { if (t.length !== e.length) return !1; for (let r = 0; r < t.length; r++) { let i = t[r], o = e[r]; if (n && (i = n(i), o = n(o)), o !== i) return !1 } return !0 }(r._results, i, n)) && (r._results = i, r.length = i.length, r.last = i[this.length - 1], r.first = i[0]) } notifyOnChanges() { this._changes && (this._changesDetected || !this._emitDistinctChangesOnly) && this._changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } let xr = (() => { class t { } return t.__NG_ELEMENT_ID__ = FS, t })(); const SS = xr, IS = class extends SS { constructor(e, n, r) { super(), this._declarationLView = e, this._declarationTContainer = n, this.elementRef = r } createEmbeddedView(e, n) { const r = this._declarationTContainer.tViews, i = js(this._declarationLView, r, e, 16, null, r.declTNode, null, null, null, null, n || null); i[17] = this._declarationLView[this._declarationTContainer.index]; const s = this._declarationLView[19]; return null !== s && (i[19] = s.createEmbeddedView(r)), $s(r, i, e), new ea(i) } }; function FS() { return Zl(Ht(), k()) } function Zl(t, e) { return 4 & t.type ? new IS(e, t, Yo(t, e)) : null } let hr = (() => { class t { } return t.__NG_ELEMENT_ID__ = NS, t })(); function NS() { return R_(Ht(), k()) } const OS = hr, N_ = class extends OS { constructor(e, n, r) { super(), this._lContainer = e, this._hostTNode = n, this._hostLView = r } get element() { return Yo(this._hostTNode, this._hostLView) } get injector() { return new vo(this._hostTNode, this._hostLView) } get parentInjector() { const e = ul(this._hostTNode, this._hostLView); if (vp(e)) { const n = _o(e, this._hostLView), r = yo(e); return new vo(n[1].data[r + 8], n) } return new vo(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(e) { const n = O_(this._lContainer); return null !== n && n[e] || null } get length() { return this._lContainer.length - 10 } createEmbeddedView(e, n, r) { let i, o; "number" == typeof r ? i = r : null != r && (i = r.index, o = r.injector); const s = e.createEmbeddedView(n || {}, o); return this.insert(s, i), s } createComponent(e, n, r, i, o) { const s = e && !function xs(t) { return "function" == typeof t }(e); let a; if (s) a = n; else { const d = n || {}; a = d.index, r = d.injector, i = d.projectableNodes, o = d.environmentInjector || d.ngModuleRef } const l = s ? e : new Ff(at(e)), c = r || this.parentInjector; if (!o && null == l.ngModule) { const f = (s ? c : this.parentInjector).get(Hs, null); f && (o = f) } const u = l.create(c, i, void 0, o); return this.insert(u.hostView, a), u } insert(e, n) { const r = e._lView, i = r[1]; if (function YE(t) { return or(t[3]) }(r)) { const u = this.indexOf(e); if (-1 !== u) this.detach(u); else { const d = r[3], f = new N_(d, d[6], d[3]); f.detach(f.indexOf(e)) } } const o = this._adjustIndex(n), s = this._lContainer; !function nT(t, e, n, r) { const i = 10 + r, o = n.length; r > 0 && (n[i - 1][4] = e), r < o - 10 ? (e[4] = n[i], Ip(n, 10 + r, e)) : (n.push(e), e[4] = null), e[3] = n; const s = e[17]; null !== s && n !== s && function rT(t, e) { const n = t[9]; e[16] !== e[3][3][16] && (t[2] = !0), null === n ? t[9] = [e] : n.push(e) }(s, e); const a = e[19]; null !== a && a.insertView(t), e[2] |= 64 }(i, r, s, o); const a = kd(o, s), l = r[11], c = xl(l, s[7]); return null !== c && function JM(t, e, n, r, i, o) { r[0] = i, r[6] = e, Bs(t, r, n, 1, i, o) }(i, s[6], l, r, c, a), e.attachToViewContainerRef(), Ip(Pf(s), o, e), e } move(e, n) { return this.insert(e, n) } indexOf(e) { const n = O_(this._lContainer); return null !== n ? n.indexOf(e) : -1 } remove(e) { const n = this._adjustIndex(e, -1), r = Md(this._lContainer, n); r && (ml(Pf(this._lContainer), n), bg(r[1], r)) } detach(e) { const n = this._adjustIndex(e, -1), r = Md(this._lContainer, n); return r && null != ml(Pf(this._lContainer), n) ? new ea(r) : null } _adjustIndex(e, n = 0) { return e ?? this.length + n } }; function O_(t) { return t[8] } function Pf(t) { return t[8] || (t[8] = []) } function R_(t, e) { let n; const r = e[t.index]; if (or(r)) n = r; else { let i; if (8 & t.type) i = Rt(r); else { const o = e[11]; i = o.createComment(""); const s = qn(t, e); Ni(o, xl(o, s), i, function aT(t, e) { return Et(t) ? t.nextSibling(e) : e.nextSibling }(o, s), !1) } e[t.index] = n = Ab(r, e, i, t), Pl(e, n) } return new N_(n, t, e) } class Lf { constructor(e) { this.queryList = e, this.matches = null } clone() { return new Lf(this.queryList) } setDirty() { this.queryList.setDirty() } } class Vf { constructor(e = []) { this.queries = e } createEmbeddedView(e) { const n = e.queries; if (null !== n) { const r = null !== e.contentQueries ? e.contentQueries[0] : n.length, i = []; for (let o = 0; o < r; o++) { const s = n.getByIndex(o); i.push(this.queries[s.indexInDeclarationView].clone()) } return new Vf(i) } return null } insertView(e) { this.dirtyQueriesWithMatches(e) } detachView(e) { this.dirtyQueriesWithMatches(e) } dirtyQueriesWithMatches(e) { for (let n = 0; n < this.queries.length; n++)null !== H_(e, n).matches && this.queries[n].setDirty() } } class P_ { constructor(e, n, r = null) { this.predicate = e, this.flags = n, this.read = r } } class Bf { constructor(e = []) { this.queries = e } elementStart(e, n) { for (let r = 0; r < this.queries.length; r++)this.queries[r].elementStart(e, n) } elementEnd(e) { for (let n = 0; n < this.queries.length; n++)this.queries[n].elementEnd(e) } embeddedTView(e) { let n = null; for (let r = 0; r < this.length; r++) { const i = null !== n ? n.length : 0, o = this.getByIndex(r).embeddedTView(e, i); o && (o.indexInDeclarationView = r, null !== n ? n.push(o) : n = [o]) } return null !== n ? new Bf(n) : null } template(e, n) { for (let r = 0; r < this.queries.length; r++)this.queries[r].template(e, n) } getByIndex(e) { return this.queries[e] } get length() { return this.queries.length } track(e) { this.queries.push(e) } } class Hf { constructor(e, n = -1) { this.metadata = e, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = n } elementStart(e, n) { this.isApplyingToNode(n) && this.matchTNode(e, n) } elementEnd(e) { this._declarationNodeIndex === e.index && (this._appliesToNextNode = !1) } template(e, n) { this.elementStart(e, n) } embeddedTView(e, n) { return this.isApplyingToNode(e) ? (this.crossesNgTemplate = !0, this.addMatch(-e.index, n), new Hf(this.metadata)) : null } isApplyingToNode(e) { if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) { const n = this._declarationNodeIndex; let r = e.parent; for (; null !== r && 8 & r.type && r.index !== n;)r = r.parent; return n === (null !== r ? r.index : -1) } return this._appliesToNextNode } matchTNode(e, n) { const r = this.metadata.predicate; if (Array.isArray(r)) for (let i = 0; i < r.length; i++) { const o = r[i]; this.matchTNodeWithReadOption(e, n, LS(n, o)), this.matchTNodeWithReadOption(e, n, fl(n, e, o, !1, !1)) } else r === xr ? 4 & n.type && this.matchTNodeWithReadOption(e, n, -1) : this.matchTNodeWithReadOption(e, n, fl(n, e, r, !1, !1)) } matchTNodeWithReadOption(e, n, r) { if (null !== r) { const i = this.metadata.read; if (null !== i) if (i === Tt || i === hr || i === xr && 4 & n.type) this.addMatch(n.index, -2); else { const o = fl(n, e, i, !1, !1); null !== o && this.addMatch(n.index, o) } else this.addMatch(n.index, r) } } addMatch(e, n) { null === this.matches ? this.matches = [e, n] : this.matches.push(e, n) } } function LS(t, e) { const n = t.localNames; if (null !== n) for (let r = 0; r < n.length; r += 2)if (n[r] === e) return n[r + 1]; return null } function BS(t, e, n, r) { return -1 === n ? function VS(t, e) { return 11 & t.type ? Yo(t, e) : 4 & t.type ? Zl(t, e) : null }(e, t) : -2 === n ? function HS(t, e, n) { return n === Tt ? Yo(e, t) : n === xr ? Zl(e, t) : n === hr ? R_(e, t) : void 0 }(t, e, r) : Ms(t, t[1], n, e) } function L_(t, e, n, r) { const i = e[19].queries[r]; if (null === i.matches) { const o = t.data, s = n.matches, a = []; for (let l = 0; l < s.length; l += 2) { const c = s[l]; a.push(c < 0 ? null : BS(e, o[c], s[l + 1], n.metadata.read)) } i.matches = a } return i.matches } function jf(t, e, n, r) { const i = t.queries.getByIndex(n), o = i.matches; if (null !== o) { const s = L_(t, e, i, n); for (let a = 0; a < o.length; a += 2) { const l = o[a]; if (l > 0) r.push(s[a / 2]); else { const c = o[a + 1], u = e[-l]; for (let d = 10; d < u.length; d++) { const f = u[d]; f[17] === f[3] && jf(f[1], f, c, r) } if (null !== u[9]) { const d = u[9]; for (let f = 0; f < d.length; f++) { const h = d[f]; jf(h[1], h, c, r) } } } } } return r } function rn(t) { const e = k(), n = Pe(), r = dp(); qu(r + 1); const i = H_(n, r); if (t.dirty && ip(e) === (2 == (2 & i.metadata.flags))) { if (null === i.matches) t.reset([]); else { const o = i.crossesNgTemplate ? jf(n, e, r, []) : L_(n, e, i, r); t.reset(o, YA), t.notifyOnChanges() } return !0 } return !1 } function ji(t, e, n) { const r = Pe(); r.firstCreatePass && (B_(r, new P_(t, e, n), -1), 2 == (2 & e) && (r.staticViewQueries = !0)), V_(r, k(), e) } function kr(t, e, n, r) { const i = Pe(); if (i.firstCreatePass) { const o = Ht(); B_(i, new P_(e, n, r), o.index), function $S(t, e) { const n = t.contentQueries || (t.contentQueries = []); e !== (n.length ? n[n.length - 1] : -1) && n.push(t.queries.length - 1, e) }(i, t), 2 == (2 & n) && (i.staticContentQueries = !0) } V_(i, k(), n) } function on() { return function jS(t, e) { return t[19].queries[e].queryList }(k(), dp()) } function V_(t, e, n) { const r = new Rf(4 == (4 & n)); Db(t, e, r, r.destroy), null === e[19] && (e[19] = new Vf), e[19].queries.push(new Lf(r)) } function B_(t, e, n) { null === t.queries && (t.queries = new Bf), t.queries.track(new Hf(e, n)) } function H_(t, e) { return t.queries.getByIndex(e) } function Kl(t, e) { return Zl(t, e) } function Yl(...t) { } const s0 = new K("Application Initializer"); let Xl = (() => { class t { constructor(n) { this.appInits = n, this.resolve = Yl, this.reject = Yl, this.initialized = !1, this.done = !1, this.donePromise = new Promise((r, i) => { this.resolve = r, this.reject = i }) } runInitializers() { if (this.initialized) return; const n = [], r = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let i = 0; i < this.appInits.length; i++) { const o = this.appInits[i](); if (Hl(o)) n.push(o); else if (oy(o)) { const s = new Promise((a, l) => { o.subscribe({ complete: a, error: l }) }); n.push(s) } } Promise.all(n).then(() => { r() }).catch(i => { this.reject(i) }), 0 === n.length && r(), this.initialized = !0 } } return t.\u0275fac = function (n) { return new (n || t)(B(s0, 8)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); const oa = new K("AppId", { providedIn: "root", factory: function a0() { return `${qf()}${qf()}${qf()}` } }); function qf() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const l0 = new K("Platform Initializer"), Jl = new K("Platform ID", { providedIn: "platform", factory: () => "unknown" }), lI = new K("appBootstrapListener"), sa = new K("AnimationModuleType"), Ar = new K("LocaleId", { providedIn: "root", factory: () => yl(Ar, ue.Optional | ue.SkipSelf) || function cI() { return typeof $localize < "u" && $localize.locale || Ko }() }), hI = (() => Promise.resolve(0))(); function Wf(t) { typeof Zone > "u" ? hI.then(() => { t && t.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", t) } class Xe { constructor({ enableLongStackTrace: e = !1, shouldCoalesceEventChangeDetection: n = !1, shouldCoalesceRunChangeDetection: r = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new Ye(!1), this.onMicrotaskEmpty = new Ye(!1), this.onStable = new Ye(!1), this.onError = new Ye(!1), typeof Zone > "u") throw new Error("In this configuration Angular requires Zone.js"); Zone.assertZonePatched(); const i = this; i._nesting = 0, i._outer = i._inner = Zone.current, Zone.TaskTrackingZoneSpec && (i._inner = i._inner.fork(new Zone.TaskTrackingZoneSpec)), e && Zone.longStackTraceZoneSpec && (i._inner = i._inner.fork(Zone.longStackTraceZoneSpec)), i.shouldCoalesceEventChangeDetection = !r && n, i.shouldCoalesceRunChangeDetection = r, i.lastRequestAnimationFrameId = -1, i.nativeRequestAnimationFrame = function mI() { let t = rt.requestAnimationFrame, e = rt.cancelAnimationFrame; if (typeof Zone < "u" && t && e) { const n = t[Zone.__symbol__("OriginalDelegate")]; n && (t = n); const r = e[Zone.__symbol__("OriginalDelegate")]; r && (e = r) } return { nativeRequestAnimationFrame: t, nativeCancelAnimationFrame: e } }().nativeRequestAnimationFrame, function bI(t) { const e = () => { !function gI(t) { t.isCheckStableRunning || -1 !== t.lastRequestAnimationFrameId || (t.lastRequestAnimationFrameId = t.nativeRequestAnimationFrame.call(rt, () => { t.fakeTopEventTask || (t.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { t.lastRequestAnimationFrameId = -1, Kf(t), t.isCheckStableRunning = !0, Zf(t), t.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), t.fakeTopEventTask.invoke() }), Kf(t)) }(t) }; t._inner = t._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (n, r, i, o, s, a) => { try { return c0(t), n.invokeTask(i, o, s, a) } finally { (t.shouldCoalesceEventChangeDetection && "eventTask" === o.type || t.shouldCoalesceRunChangeDetection) && e(), u0(t) } }, onInvoke: (n, r, i, o, s, a, l) => { try { return c0(t), n.invoke(i, o, s, a, l) } finally { t.shouldCoalesceRunChangeDetection && e(), u0(t) } }, onHasTask: (n, r, i, o) => { n.hasTask(i, o), r === i && ("microTask" == o.change ? (t._hasPendingMicrotasks = o.microTask, Kf(t), Zf(t)) : "macroTask" == o.change && (t.hasPendingMacrotasks = o.macroTask)) }, onHandleError: (n, r, i, o) => (n.handleError(i, o), t.runOutsideAngular(() => t.onError.emit(o)), !1) }) }(i) } static isInAngularZone() { return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!Xe.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!") } static assertNotInAngularZone() { if (Xe.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!") } run(e, n, r) { return this._inner.run(e, n, r) } runTask(e, n, r, i) { const o = this._inner, s = o.scheduleEventTask("NgZoneEvent: " + i, e, pI, Yl, Yl); try { return o.runTask(s, n, r) } finally { o.cancelTask(s) } } runGuarded(e, n, r) { return this._inner.runGuarded(e, n, r) } runOutsideAngular(e) { return this._outer.run(e) } } const pI = {}; function Zf(t) { if (0 == t._nesting && !t.hasPendingMicrotasks && !t.isStable) try { t._nesting++, t.onMicrotaskEmpty.emit(null) } finally { if (t._nesting--, !t.hasPendingMicrotasks) try { t.runOutsideAngular(() => t.onStable.emit(null)) } finally { t.isStable = !0 } } } function Kf(t) { t.hasPendingMicrotasks = !!(t._hasPendingMicrotasks || (t.shouldCoalesceEventChangeDetection || t.shouldCoalesceRunChangeDetection) && -1 !== t.lastRequestAnimationFrameId) } function c0(t) { t._nesting++, t.isStable && (t.isStable = !1, t.onUnstable.emit(null)) } function u0(t) { t._nesting--, Zf(t) } class yI { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new Ye, this.onMicrotaskEmpty = new Ye, this.onStable = new Ye, this.onError = new Ye } run(e, n, r) { return e.apply(n, r) } runGuarded(e, n, r) { return e.apply(n, r) } runOutsideAngular(e) { return e() } runTask(e, n, r, i) { return e.apply(n, r) } } const d0 = new K(""), ec = new K(""); let Xf, Qf = (() => { class t { constructor(n, r, i) { this._ngZone = n, this.registry = r, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, Xf || (function _I(t) { Xf = t }(i), i.addToWindow(r)), this._watchAngularEvents(), n.run(() => { this.taskTrackingZone = typeof Zone > "u" ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { Xe.assertNotInAngularZone(), Wf(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) Wf(() => { for (; 0 !== this._callbacks.length;) { let n = this._callbacks.pop(); clearTimeout(n.timeoutId), n.doneCb(this._didWork) } this._didWork = !1 }); else { let n = this.getPendingTasks(); this._callbacks = this._callbacks.filter(r => !r.updateCb || !r.updateCb(n) || (clearTimeout(r.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(n => ({ source: n.source, creationLocation: n.creationLocation, data: n.data })) : [] } addCallback(n, r, i) { let o = -1; r && r > 0 && (o = setTimeout(() => { this._callbacks = this._callbacks.filter(s => s.timeoutId !== o), n(this._didWork, this.getPendingTasks()) }, r)), this._callbacks.push({ doneCb: n, timeoutId: o, updateCb: i }) } whenStable(n, r, i) { if (i && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(n, r, i), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } registerApplication(n) { this.registry.registerApplication(n, this) } unregisterApplication(n) { this.registry.unregisterApplication(n) } findProviders(n, r, i) { return [] } } return t.\u0275fac = function (n) { return new (n || t)(B(Xe), B(Yf), B(ec)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac }), t })(), Yf = (() => { class t { constructor() { this._applications = new Map } registerApplication(n, r) { this._applications.set(n, r) } unregisterApplication(n) { this._applications.delete(n) } unregisterAllApplications() { this._applications.clear() } getTestability(n) { return this._applications.get(n) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(n, r = !0) { return Xf?.findTestabilityInTree(this, n, r) ?? null } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac, providedIn: "platform" }), t })(), fi = null; const f0 = new K("AllowMultipleToken"), h0 = new K("PlatformOnDestroy"); function p0(t, e, n = []) { const r = `Platform: ${e}`, i = new K(r); return (o = []) => { let s = Jf(); if (!s || s.injector.get(f0, !1)) { const a = [...n, ...o, { provide: i, useValue: !0 }]; t ? t(a) : function DI(t) { if (fi && !fi.get(f0, !1)) throw new P(400, ""); fi = t; const e = t.get(b0); (function m0(t) { const e = t.get(l0, null); e && e.forEach(n => n()) })(t) }(function g0(t = [], e) { return tn.create({ name: e, providers: [{ provide: Od, useValue: "platform" }, { provide: h0, useValue: () => fi = null }, ...t] }) }(a, r)) } return function CI(t) { const e = Jf(); if (!e) throw new P(401, ""); return e }() } } function Jf() { return fi?.get(b0) ?? null } let b0 = (() => { class t { constructor(n) { this._injector = n, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(n, r) { const i = function MI(t, e) { let n; return n = "noop" === t ? new yI : ("zone.js" === t ? void 0 : t) || new Xe(e), n }(r?.ngZone, function y0(t) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: !(!t || !t.ngZoneEventCoalescing) || !1, shouldCoalesceRunChangeDetection: !(!t || !t.ngZoneRunCoalescing) || !1 } }(r)), o = [{ provide: Xe, useValue: i }]; return i.run(() => { const s = tn.create({ providers: o, parent: this.injector, name: n.moduleType.name }), a = n.create(s), l = a.injector.get(ko, null); if (!l) throw new P(402, ""); return i.runOutsideAngular(() => { const c = i.onError.subscribe({ next: u => { l.handleError(u) } }); a.onDestroy(() => { tc(this._modules, a), c.unsubscribe() }) }), function _0(t, e, n) { try { const r = n(); return Hl(r) ? r.catch(i => { throw e.runOutsideAngular(() => t.handleError(i)), i }) : r } catch (r) { throw e.runOutsideAngular(() => t.handleError(r)), r } }(l, i, () => { const c = a.injector.get(Xl); return c.runInitializers(), c.donePromise.then(() => (function Xy(t) { Tn(t, "Expected localeId to be defined"), "string" == typeof t && (Yy = t.toLowerCase().replace(/_/g, "-")) }(a.injector.get(Ar, Ko) || Ko), this._moduleDoBootstrap(a), a)) }) }) } bootstrapModule(n, r = []) { const i = v0({}, r); return function vI(t, e, n) { const r = new Nf(n); return Promise.resolve(r) }(0, 0, n).then(o => this.bootstrapModuleFactory(o, i)) } _moduleDoBootstrap(n) { const r = n.injector.get(aa); if (n._bootstrapComponents.length > 0) n._bootstrapComponents.forEach(i => r.bootstrap(i)); else { if (!n.instance.ngDoBootstrap) throw new P(403, ""); n.instance.ngDoBootstrap(r) } this._modules.push(n) } onDestroy(n) { this._destroyListeners.push(n) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new P(404, ""); this._modules.slice().forEach(r => r.destroy()), this._destroyListeners.forEach(r => r()), this._injector.get(h0, null)?.(), this._destroyed = !0 } get destroyed() { return this._destroyed } } return t.\u0275fac = function (n) { return new (n || t)(B(tn)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac, providedIn: "platform" }), t })(); function v0(t, e) { return Array.isArray(e) ? e.reduce(v0, t) : { ...t, ...e } } let aa = (() => { class t { constructor(n, r, i, o) { this._zone = n, this._injector = r, this._exceptionHandler = i, this._initStatus = o, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this._destroyed = !1, this._destroyListeners = [], this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const s = new qe(l => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { l.next(this._stable), l.complete() }) }), a = new qe(l => { let c; this._zone.runOutsideAngular(() => { c = this._zone.onStable.subscribe(() => { Xe.assertNotInAngularZone(), Wf(() => { !this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks && (this._stable = !0, l.next(!0)) }) }) }); const u = this._zone.onUnstable.subscribe(() => { Xe.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { l.next(!1) })) }); return () => { c.unsubscribe(), u.unsubscribe() } }); this.isStable = me(s, a.pipe(function nt(t = {}) { const { connector: e = (() => new Qt), resetOnError: n = !0, resetOnComplete: r = !0, resetOnRefCountZero: i = !0 } = t; return o => { let s = null, a = null, l = null, c = 0, u = !1, d = !1; const f = () => { a?.unsubscribe(), a = null }, h = () => { f(), s = l = null, u = d = !1 }, m = () => { const b = s; h(), b?.unsubscribe() }; return Wt((b, w) => { c++, !d && !u && f(); const C = l = l ?? e(); w.add(() => { c--, 0 === c && !d && !u && (a = zn(m, i)) }), C.subscribe(w), s || (s = new Lr({ next: I => C.next(I), error: I => { d = !0, f(), a = zn(h, n, I), C.error(I) }, complete: () => { u = !0, f(), a = zn(h, r), C.complete() } }), le(b).subscribe(s)) })(o) } }())) } get destroyed() { return this._destroyed } get injector() { return this._injector } bootstrap(n, r) { const i = n instanceof C_; if (!this._initStatus.done) throw !i && function ia(t) { const e = at(t) || cn(t) || un(t); return null !== e && e.standalone }(n), new P(405, false); let o; o = i ? n : this._injector.get(Vi).resolveComponentFactory(n), this.componentTypes.push(o.componentType); const s = function wI(t) { return t.isBoundToModule }(o) ? void 0 : this._injector.get(Bi), l = o.create(tn.NULL, [], r || o.selector, s), c = l.location.nativeElement, u = l.injector.get(d0, null); return u?.registerApplication(c), l.onDestroy(() => { this.detachView(l.hostView), tc(this.components, l), u?.unregisterApplication(c) }), this._loadComponent(l), l } tick() { if (this._runningTick) throw new P(101, ""); try { this._runningTick = !0; for (let n of this._views) n.detectChanges() } catch (n) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(n)) } finally { this._runningTick = !1 } } attachView(n) { const r = n; this._views.push(r), r.attachToAppRef(this) } detachView(n) { const r = n; tc(this._views, r), r.detachFromAppRef() } _loadComponent(n) { this.attachView(n.hostView), this.tick(), this.components.push(n), this._injector.get(lI, []).concat(this._bootstrapListeners).forEach(i => i(n)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(n => n()), this._views.slice().forEach(n => n.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } finally { this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = [] } } onDestroy(n) { return this._destroyListeners.push(n), () => tc(this._destroyListeners, n) } destroy() { if (this._destroyed) throw new P(406, false); const n = this._injector; n.destroy && !n.destroyed && n.destroy() } get viewCount() { return this._views.length } warnIfDestroyed() { } } return t.\u0275fac = function (n) { return new (n || t)(B(Xe), B(tn), B(ko), B(Xl)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); function tc(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } let D0 = !0, ts = (() => { class t { } return t.__NG_ELEMENT_ID__ = kI, t })(); function kI(t) { return function AI(t, e, n) { if (Xa(t) && !n) { const r = An(t.index, e); return new ea(r, r) } return 47 & t.type ? new ea(e[16], e) : null }(Ht(), k(), 16 == (16 & t)) } class x0 { constructor() { } supports(e) { return zs(e) } create(e) { return new RI(e) } } const OI = (t, e) => e; class RI { constructor(e) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = e || OI } forEachItem(e) { let n; for (n = this._itHead; null !== n; n = n._next)e(n) } forEachOperation(e) { let n = this._itHead, r = this._removalsHead, i = 0, o = null; for (; n || r;) { const s = !r || n && n.currentIndex < A0(r, i, o) ? n : r, a = A0(s, i, o), l = s.currentIndex; if (s === r) i--, r = r._nextRemoved; else if (n = n._next, null == s.previousIndex) i++; else { o || (o = []); const c = a - i, u = l - i; if (c != u) { for (let f = 0; f < c; f++) { const h = f < o.length ? o[f] : o[f] = 0, m = h + f; u <= m && m < c && (o[f] = h + 1) } o[s.previousIndex] = u - c } } a !== l && e(s, a, l) } } forEachPreviousItem(e) { let n; for (n = this._previousItHead; null !== n; n = n._nextPrevious)e(n) } forEachAddedItem(e) { let n; for (n = this._additionsHead; null !== n; n = n._nextAdded)e(n) } forEachMovedItem(e) { let n; for (n = this._movesHead; null !== n; n = n._nextMoved)e(n) } forEachRemovedItem(e) { let n; for (n = this._removalsHead; null !== n; n = n._nextRemoved)e(n) } forEachIdentityChange(e) { let n; for (n = this._identityChangesHead; null !== n; n = n._nextIdentityChange)e(n) } diff(e) { if (null == e && (e = []), !zs(e)) throw new P(900, ""); return this.check(e) ? this : null } onDestroy() { } check(e) { this._reset(); let i, o, s, n = this._itHead, r = !1; if (Array.isArray(e)) { this.length = e.length; for (let a = 0; a < this.length; a++)o = e[a], s = this._trackByFn(a, o), null !== n && Object.is(n.trackById, s) ? (r && (n = this._verifyReinsertion(n, o, s, a)), Object.is(n.item, o) || this._addIdentityChange(n, o)) : (n = this._mismatch(n, o, s, a), r = !0), n = n._next } else i = 0, function nk(t, e) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++)e(t[n]); else { const n = t[Ri()](); let r; for (; !(r = n.next()).done;)e(r.value) } }(e, a => { s = this._trackByFn(i, a), null !== n && Object.is(n.trackById, s) ? (r && (n = this._verifyReinsertion(n, a, s, i)), Object.is(n.item, a) || this._addIdentityChange(n, a)) : (n = this._mismatch(n, a, s, i), r = !0), n = n._next, i++ }), this.length = i; return this._truncate(n), this.collection = e, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let e; for (e = this._previousItHead = this._itHead; null !== e; e = e._next)e._nextPrevious = e._next; for (e = this._additionsHead; null !== e; e = e._nextAdded)e.previousIndex = e.currentIndex; for (this._additionsHead = this._additionsTail = null, e = this._movesHead; null !== e; e = e._nextMoved)e.previousIndex = e.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(e, n, r, i) { let o; return null === e ? o = this._itTail : (o = e._prev, this._remove(e)), null !== (e = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null)) ? (Object.is(e.item, n) || this._addIdentityChange(e, n), this._reinsertAfter(e, o, i)) : null !== (e = null === this._linkedRecords ? null : this._linkedRecords.get(r, i)) ? (Object.is(e.item, n) || this._addIdentityChange(e, n), this._moveAfter(e, o, i)) : e = this._addAfter(new PI(n, r), o, i), e } _verifyReinsertion(e, n, r, i) { let o = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null); return null !== o ? e = this._reinsertAfter(o, e._prev, i) : e.currentIndex != i && (e.currentIndex = i, this._addToMoves(e, i)), e } _truncate(e) { for (; null !== e;) { const n = e._next; this._addToRemovals(this._unlink(e)), e = n } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(e, n, r) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(e); const i = e._prevRemoved, o = e._nextRemoved; return null === i ? this._removalsHead = o : i._nextRemoved = o, null === o ? this._removalsTail = i : o._prevRemoved = i, this._insertAfter(e, n, r), this._addToMoves(e, r), e } _moveAfter(e, n, r) { return this._unlink(e), this._insertAfter(e, n, r), this._addToMoves(e, r), e } _addAfter(e, n, r) { return this._insertAfter(e, n, r), this._additionsTail = null === this._additionsTail ? this._additionsHead = e : this._additionsTail._nextAdded = e, e } _insertAfter(e, n, r) { const i = null === n ? this._itHead : n._next; return e._next = i, e._prev = n, null === i ? this._itTail = e : i._prev = e, null === n ? this._itHead = e : n._next = e, null === this._linkedRecords && (this._linkedRecords = new k0), this._linkedRecords.put(e), e.currentIndex = r, e } _remove(e) { return this._addToRemovals(this._unlink(e)) } _unlink(e) { null !== this._linkedRecords && this._linkedRecords.remove(e); const n = e._prev, r = e._next; return null === n ? this._itHead = r : n._next = r, null === r ? this._itTail = n : r._prev = n, e } _addToMoves(e, n) { return e.previousIndex === n || (this._movesTail = null === this._movesTail ? this._movesHead = e : this._movesTail._nextMoved = e), e } _addToRemovals(e) { return null === this._unlinkedRecords && (this._unlinkedRecords = new k0), this._unlinkedRecords.put(e), e.currentIndex = null, e._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = e, e._prevRemoved = null) : (e._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = e), e } _addIdentityChange(e, n) { return e.item = n, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = e : this._identityChangesTail._nextIdentityChange = e, e } } class PI { constructor(e, n) { this.item = e, this.trackById = n, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class LI { constructor() { this._head = null, this._tail = null } add(e) { null === this._head ? (this._head = this._tail = e, e._nextDup = null, e._prevDup = null) : (this._tail._nextDup = e, e._prevDup = this._tail, e._nextDup = null, this._tail = e) } get(e, n) { let r; for (r = this._head; null !== r; r = r._nextDup)if ((null === n || n <= r.currentIndex) && Object.is(r.trackById, e)) return r; return null } remove(e) { const n = e._prevDup, r = e._nextDup; return null === n ? this._head = r : n._nextDup = r, null === r ? this._tail = n : r._prevDup = n, null === this._head } } class k0 { constructor() { this.map = new Map } put(e) { const n = e.trackById; let r = this.map.get(n); r || (r = new LI, this.map.set(n, r)), r.add(e) } get(e, n) { const i = this.map.get(e); return i ? i.get(e, n) : null } remove(e) { const n = e.trackById; return this.map.get(n).remove(e) && this.map.delete(n), e } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function A0(t, e, n) { const r = t.previousIndex; if (null === r) return r; let i = 0; return n && r < n.length && (i = n[r]), r + e + i } function I0() { return new ic([new x0]) } let ic = (() => { class t { constructor(n) { this.factories = n } static create(n, r) { if (null != r) { const i = r.factories.slice(); n = n.concat(i) } return new t(n) } static extend(n) { return { provide: t, useFactory: r => t.create(n, r || I0()), deps: [[t, new vl, new _l]] } } find(n) { const r = this.factories.find(i => i.supports(n)); if (null != r) return r; throw new P(901, "") } } return t.\u0275prov = pe({ token: t, providedIn: "root", factory: I0 }), t })(); const $I = p0(null, "core", []); let zI = (() => { class t { constructor(n) { } } return t.\u0275fac = function (n) { return new (n || t)(B(aa)) }, t.\u0275mod = Ot({ type: t }), t.\u0275inj = At({}), t })(), oc = null; function zi() { return oc } const Gt = new K("DocumentToken"); class L1 { constructor(e, n, r, i) { this.$implicit = e, this.ngForOf = n, this.index = r, this.count = i } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let z0 = (() => { class t { constructor(n, r, i) { this._viewContainer = n, this._template = r, this._differs = i, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForOf(n) { this._ngForOf = n, this._ngForOfDirty = !0 } set ngForTrackBy(n) { this._trackByFn = n } get ngForTrackBy() { return this._trackByFn } set ngForTemplate(n) { n && (this._template = n) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const n = this._ngForOf; !this._differ && n && (this._differ = this._differs.find(n).create(this.ngForTrackBy)) } if (this._differ) { const n = this._differ.diff(this._ngForOf); n && this._applyChanges(n) } } _applyChanges(n) { const r = this._viewContainer; n.forEachOperation((i, o, s) => { if (null == i.previousIndex) r.createEmbeddedView(this._template, new L1(i.item, this._ngForOf, -1, -1), null === s ? void 0 : s); else if (null == s) r.remove(null === o ? void 0 : o); else if (null !== o) { const a = r.get(o); r.move(a, s), U0(a, i) } }); for (let i = 0, o = r.length; i < o; i++) { const a = r.get(i).context; a.index = i, a.count = o, a.ngForOf = this._ngForOf } n.forEachIdentityChange(i => { U0(r.get(i.currentIndex), i) }) } static ngTemplateContextGuard(n, r) { return !0 } } return t.\u0275fac = function (n) { return new (n || t)(T(hr), T(xr), T(ic)) }, t.\u0275dir = te({ type: t, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" } }), t })(); function U0(t, e) { t.context.$implicit = e.item } let pc = (() => { class t { constructor(n, r) { this._viewContainer = n, this._context = new V1, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = r } set ngIf(n) { this._context.$implicit = this._context.ngIf = n, this._updateView() } set ngIfThen(n) { G0("ngIfThen", n), this._thenTemplateRef = n, this._thenViewRef = null, this._updateView() } set ngIfElse(n) { G0("ngIfElse", n), this._elseTemplateRef = n, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(n, r) { return !0 } } return t.\u0275fac = function (n) { return new (n || t)(T(hr), T(xr)) }, t.\u0275dir = te({ type: t, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" } }), t })(); class V1 { constructor() { this.$implicit = null, this.ngIf = null } } function G0(t, e) { if (e && !e.createEmbeddedView) throw new Error(`${t} must be a TemplateRef, but received '${Ze(e)}'.`) } class mh { constructor(e, n) { this._viewContainerRef = e, this._templateRef = n, this._created = !1 } create() { this._created = !0, this._viewContainerRef.createEmbeddedView(this._templateRef) } destroy() { this._created = !1, this._viewContainerRef.clear() } enforceState(e) { e && !this._created ? this.create() : !e && this._created && this.destroy() } } let gc = (() => { class t { constructor() { this._defaultUsed = !1, this._caseCount = 0, this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1 } set ngSwitch(n) { this._ngSwitch = n, 0 === this._caseCount && this._updateDefaultCases(!0) } _addCase() { return this._caseCount++ } _addDefault(n) { this._defaultViews || (this._defaultViews = []), this._defaultViews.push(n) } _matchCase(n) { const r = n == this._ngSwitch; return this._lastCasesMatched = this._lastCasesMatched || r, this._lastCaseCheckIndex++, this._lastCaseCheckIndex === this._caseCount && (this._updateDefaultCases(!this._lastCasesMatched), this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1), r } _updateDefaultCases(n) { if (this._defaultViews && n !== this._defaultUsed) { this._defaultUsed = n; for (let r = 0; r < this._defaultViews.length; r++)this._defaultViews[r].enforceState(n) } } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275dir = te({ type: t, selectors: [["", "ngSwitch", ""]], inputs: { ngSwitch: "ngSwitch" } }), t })(), q0 = (() => { class t { constructor(n, r, i) { this.ngSwitch = i, i._addCase(), this._view = new mh(n, r) } ngDoCheck() { this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase)) } } return t.\u0275fac = function (n) { return new (n || t)(T(hr), T(xr), T(gc, 9)) }, t.\u0275dir = te({ type: t, selectors: [["", "ngSwitchCase", ""]], inputs: { ngSwitchCase: "ngSwitchCase" } }), t })(), Z0 = (() => { class t { constructor(n) { this._viewContainerRef = n, this._viewRef = null, this.ngTemplateOutletContext = null, this.ngTemplateOutlet = null, this.ngTemplateOutletInjector = null } ngOnChanges(n) { if (n.ngTemplateOutlet || n.ngTemplateOutletInjector) { const r = this._viewContainerRef; if (this._viewRef && r.remove(r.indexOf(this._viewRef)), this.ngTemplateOutlet) { const { ngTemplateOutlet: i, ngTemplateOutletContext: o, ngTemplateOutletInjector: s } = this; this._viewRef = r.createEmbeddedView(i, o, s ? { injector: s } : void 0) } else this._viewRef = null } else this._viewRef && n.ngTemplateOutletContext && this.ngTemplateOutletContext && (this._viewRef.context = this.ngTemplateOutletContext) } } return t.\u0275fac = function (n) { return new (n || t)(T(hr)) }, t.\u0275dir = te({ type: t, selectors: [["", "ngTemplateOutlet", ""]], inputs: { ngTemplateOutletContext: "ngTemplateOutletContext", ngTemplateOutlet: "ngTemplateOutlet", ngTemplateOutletInjector: "ngTemplateOutletInjector" }, features: [yr] }), t })(), bc = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Ot({ type: t }), t.\u0275inj = At({}), t })(); const Q0 = "browser"; function Y0(t) { return t === Q0 } class bh extends class mF extends class qI { }{ constructor() { super(...arguments), this.supportsDOMEvents = !0 } }{ static makeCurrent() { !function GI(t) { oc || (oc = t) }(new bh) } onAndCancel(e, n, r) { return e.addEventListener(n, r, !1), () => { e.removeEventListener(n, r, !1) } } dispatchEvent(e, n) { e.dispatchEvent(n) } remove(e) { e.parentNode && e.parentNode.removeChild(e) } createElement(e, n) { return (n = n || this.getDefaultDocument()).createElement(e) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(e) { return e.nodeType === Node.ELEMENT_NODE } isShadowRoot(e) { return e instanceof DocumentFragment } getGlobalEventTarget(e, n) { return "window" === n ? window : "document" === n ? e : "body" === n ? e.body : null } getBaseHref(e) { const n = function pF() { return da = da || document.querySelector("base"), da ? da.getAttribute("href") : null }(); return null == n ? null : function gF(t) { yc = yc || document.createElement("a"), yc.setAttribute("href", t); const e = yc.pathname; return "/" === e.charAt(0) ? e : `/${e}` }(n) } resetBaseElement() { da = null } getUserAgent() { return window.navigator.userAgent } getCookie(e) { return function O1(t, e) { e = encodeURIComponent(e); for (const n of t.split(";")) { const r = n.indexOf("="), [i, o] = -1 == r ? [n, ""] : [n.slice(0, r), n.slice(r + 1)]; if (i.trim() === e) return decodeURIComponent(o) } return null }(document.cookie, e) } } let yc, da = null; const J0 = new K("TRANSITION_ID"), yF = [{ provide: s0, useFactory: function bF(t, e, n) { return () => { n.get(Xl).donePromise.then(() => { const r = zi(), i = e.querySelectorAll(`style[ng-transition="${t}"]`); for (let o = 0; o < i.length; o++)r.remove(i[o]) }) } }, deps: [J0, Gt, tn], multi: !0 }]; let vF = (() => { class t { build() { return new XMLHttpRequest } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac }), t })(); const _c = new K("EventManagerPlugins"); let vc = (() => { class t { constructor(n, r) { this._zone = r, this._eventNameToPlugin = new Map, n.forEach(i => i.manager = this), this._plugins = n.slice().reverse() } addEventListener(n, r, i) { return this._findPluginFor(r).addEventListener(n, r, i) } addGlobalEventListener(n, r, i) { return this._findPluginFor(r).addGlobalEventListener(n, r, i) } getZone() { return this._zone } _findPluginFor(n) { const r = this._eventNameToPlugin.get(n); if (r) return r; const i = this._plugins; for (let o = 0; o < i.length; o++) { const s = i[o]; if (s.supports(n)) return this._eventNameToPlugin.set(n, s), s } throw new Error(`No event manager plugin found for event ${n}`) } } return t.\u0275fac = function (n) { return new (n || t)(B(_c), B(Xe)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac }), t })(); class ev { constructor(e) { this._doc = e } addGlobalEventListener(e, n, r) { const i = zi().getGlobalEventTarget(this._doc, e); if (!i) throw new Error(`Unsupported event target ${i} for event ${n}`); return this.addEventListener(i, n, r) } } let tv = (() => { class t { constructor() { this._stylesSet = new Set } addStyles(n) { const r = new Set; n.forEach(i => { this._stylesSet.has(i) || (this._stylesSet.add(i), r.add(i)) }), this.onStylesAdded(r) } onStylesAdded(n) { } getAllStyles() { return Array.from(this._stylesSet) } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac }), t })(), fa = (() => { class t extends tv { constructor(n) { super(), this._doc = n, this._hostNodes = new Map, this._hostNodes.set(n.head, []) } _addStylesToHost(n, r, i) { n.forEach(o => { const s = this._doc.createElement("style"); s.textContent = o, i.push(r.appendChild(s)) }) } addHost(n) { const r = []; this._addStylesToHost(this._stylesSet, n, r), this._hostNodes.set(n, r) } removeHost(n) { const r = this._hostNodes.get(n); r && r.forEach(nv), this._hostNodes.delete(n) } onStylesAdded(n) { this._hostNodes.forEach((r, i) => { this._addStylesToHost(n, i, r) }) } ngOnDestroy() { this._hostNodes.forEach(n => n.forEach(nv)) } } return t.\u0275fac = function (n) { return new (n || t)(B(Gt)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac }), t })(); function nv(t) { zi().remove(t) } const yh = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/MathML/" }, _h = /%COMP%/g; function wc(t, e, n) { for (let r = 0; r < e.length; r++) { let i = e[r]; Array.isArray(i) ? wc(t, i, n) : (i = i.replace(_h, t), n.push(i)) } return n } function ov(t) { return e => { if ("__ngUnwrap__" === e) return t; !1 === t(e) && (e.preventDefault(), e.returnValue = !1) } } let Dc = (() => { class t { constructor(n, r, i) { this.eventManager = n, this.sharedStylesHost = r, this.appId = i, this.rendererByCompId = new Map, this.defaultRenderer = new vh(n) } createRenderer(n, r) { if (!n || !r) return this.defaultRenderer; switch (r.encapsulation) { case rr.Emulated: { let i = this.rendererByCompId.get(r.id); return i || (i = new TF(this.eventManager, this.sharedStylesHost, r, this.appId), this.rendererByCompId.set(r.id, i)), i.applyToHost(n), i } case 1: case rr.ShadowDom: return new xF(this.eventManager, this.sharedStylesHost, n, r); default: if (!this.rendererByCompId.has(r.id)) { const i = wc(r.id, r.styles, []); this.sharedStylesHost.addStyles(i), this.rendererByCompId.set(r.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return t.\u0275fac = function (n) { return new (n || t)(B(vc), B(fa), B(oa)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac }), t })(); class vh { constructor(e) { this.eventManager = e, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(e, n) { return n ? document.createElementNS(yh[n] || n, e) : document.createElement(e) } createComment(e) { return document.createComment(e) } createText(e) { return document.createTextNode(e) } appendChild(e, n) { (av(e) ? e.content : e).appendChild(n) } insertBefore(e, n, r) { e && (av(e) ? e.content : e).insertBefore(n, r) } removeChild(e, n) { e && e.removeChild(n) } selectRootElement(e, n) { let r = "string" == typeof e ? document.querySelector(e) : e; if (!r) throw new Error(`The selector "${e}" did not match any elements`); return n || (r.textContent = ""), r } parentNode(e) { return e.parentNode } nextSibling(e) { return e.nextSibling } setAttribute(e, n, r, i) { if (i) { n = i + ":" + n; const o = yh[i]; o ? e.setAttributeNS(o, n, r) : e.setAttribute(n, r) } else e.setAttribute(n, r) } removeAttribute(e, n, r) { if (r) { const i = yh[r]; i ? e.removeAttributeNS(i, n) : e.removeAttribute(`${r}:${n}`) } else e.removeAttribute(n) } addClass(e, n) { e.classList.add(n) } removeClass(e, n) { e.classList.remove(n) } setStyle(e, n, r, i) { i & (Fn.DashCase | Fn.Important) ? e.style.setProperty(n, r, i & Fn.Important ? "important" : "") : e.style[n] = r } removeStyle(e, n, r) { r & Fn.DashCase ? e.style.removeProperty(n) : e.style[n] = "" } setProperty(e, n, r) { e[n] = r } setValue(e, n) { e.nodeValue = n } listen(e, n, r) { return "string" == typeof e ? this.eventManager.addGlobalEventListener(e, n, ov(r)) : this.eventManager.addEventListener(e, n, ov(r)) } } function av(t) { return "TEMPLATE" === t.tagName && void 0 !== t.content } class TF extends vh { constructor(e, n, r, i) { super(e), this.component = r; const o = wc(i + "-" + r.id, r.styles, []); n.addStyles(o), this.contentAttr = function EF(t) { return "_ngcontent-%COMP%".replace(_h, t) }(i + "-" + r.id), this.hostAttr = function CF(t) { return "_nghost-%COMP%".replace(_h, t) }(i + "-" + r.id) } applyToHost(e) { super.setAttribute(e, this.hostAttr, "") } createElement(e, n) { const r = super.createElement(e, n); return super.setAttribute(r, this.contentAttr, ""), r } } class xF extends vh { constructor(e, n, r, i) { super(e), this.sharedStylesHost = n, this.hostEl = r, this.shadowRoot = r.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const o = wc(i.id, i.styles, []); for (let s = 0; s < o.length; s++) { const a = document.createElement("style"); a.textContent = o[s], this.shadowRoot.appendChild(a) } } nodeOrShadowRoot(e) { return e === this.hostEl ? this.shadowRoot : e } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(e, n) { return super.appendChild(this.nodeOrShadowRoot(e), n) } insertBefore(e, n, r) { return super.insertBefore(this.nodeOrShadowRoot(e), n, r) } removeChild(e, n) { return super.removeChild(this.nodeOrShadowRoot(e), n) } parentNode(e) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(e))) } } let kF = (() => { class t extends ev { constructor(n) { super(n) } supports(n) { return !0 } addEventListener(n, r, i) { return n.addEventListener(r, i, !1), () => this.removeEventListener(n, r, i) } removeEventListener(n, r, i) { return n.removeEventListener(r, i) } } return t.\u0275fac = function (n) { return new (n || t)(B(Gt)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac }), t })(); const lv = ["alt", "control", "meta", "shift"], SF = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, cv = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" }, IF = { alt: t => t.altKey, control: t => t.ctrlKey, meta: t => t.metaKey, shift: t => t.shiftKey }; let FF = (() => { class t extends ev { constructor(n) { super(n) } supports(n) { return null != t.parseEventName(n) } addEventListener(n, r, i) { const o = t.parseEventName(r), s = t.eventCallback(o.fullKey, i, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => zi().onAndCancel(n, o.domEventName, s)) } static parseEventName(n) { const r = n.toLowerCase().split("."), i = r.shift(); if (0 === r.length || "keydown" !== i && "keyup" !== i) return null; const o = t._normalizeKey(r.pop()); let s = ""; if (lv.forEach(l => { const c = r.indexOf(l); c > -1 && (r.splice(c, 1), s += l + ".") }), s += o, 0 != r.length || 0 === o.length) return null; const a = {}; return a.domEventName = i, a.fullKey = s, a } static getEventFullKey(n) { let r = "", i = function NF(t) { let e = t.key; if (null == e) { if (e = t.keyIdentifier, null == e) return "Unidentified"; e.startsWith("U+") && (e = String.fromCharCode(parseInt(e.substring(2), 16)), 3 === t.location && cv.hasOwnProperty(e) && (e = cv[e])) } return SF[e] || e }(n); return i = i.toLowerCase(), " " === i ? i = "space" : "." === i && (i = "dot"), lv.forEach(o => { o != i && IF[o](n) && (r += o + ".") }), r += i, r } static eventCallback(n, r, i) { return o => { t.getEventFullKey(o) === n && i.runGuarded(() => r(o)) } } static _normalizeKey(n) { return "esc" === n ? "escape" : n } } return t.\u0275fac = function (n) { return new (n || t)(B(Gt)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac }), t })(); const LF = p0($I, "browser", [{ provide: Jl, useValue: Q0 }, { provide: l0, useValue: function OF() { bh.makeCurrent() }, multi: !0 }, { provide: Gt, useFactory: function PF() { return function WE(t) { Lu = t }(document), document }, deps: [] }]), dv = new K(""), fv = [{ provide: ec, useClass: class _F { addToWindow(e) { rt.getAngularTestability = (r, i = !0) => { const o = e.findTestabilityInTree(r, i); if (null == o) throw new Error("Could not find testability for element."); return o }, rt.getAllAngularTestabilities = () => e.getAllTestabilities(), rt.getAllAngularRootElements = () => e.getAllRootElements(), rt.frameworkStabilizers || (rt.frameworkStabilizers = []), rt.frameworkStabilizers.push(r => { const i = rt.getAllAngularTestabilities(); let o = i.length, s = !1; const a = function (l) { s = s || l, o--, 0 == o && r(s) }; i.forEach(function (l) { l.whenStable(a) }) }) } findTestabilityInTree(e, n, r) { return null == n ? null : e.getTestability(n) ?? (r ? zi().isShadowRoot(n) ? this.findTestabilityInTree(e, n.host, !0) : this.findTestabilityInTree(e, n.parentElement, !0) : null) } }, deps: [] }, { provide: d0, useClass: Qf, deps: [Xe, Yf, ec] }, { provide: Qf, useClass: Qf, deps: [Xe, Yf, ec] }], hv = [{ provide: Od, useValue: "root" }, { provide: ko, useFactory: function RF() { return new ko }, deps: [] }, { provide: _c, useClass: kF, multi: !0, deps: [Gt, Xe, Jl] }, { provide: _c, useClass: FF, multi: !0, deps: [Gt] }, { provide: Dc, useClass: Dc, deps: [vc, fa, oa] }, { provide: Xo, useExisting: Dc }, { provide: tv, useExisting: fa }, { provide: fa, useClass: fa, deps: [Gt] }, { provide: vc, useClass: vc, deps: [_c, Xe] }, { provide: class hF { }, useClass: vF, deps: [] }, []]; let mv = (() => { class t { constructor(n) { } static withServerTransition(n) { return { ngModule: t, providers: [{ provide: oa, useValue: n.appId }, { provide: J0, useExisting: oa }, yF] } } } return t.\u0275fac = function (n) { return new (n || t)(B(dv, 12)) }, t.\u0275mod = Ot({ type: t }), t.\u0275inj = At({ providers: [...hv, ...fv], imports: [bc, zI] }), t })(); typeof window < "u" && window; const Eh = { now: () => (Eh.delegate || Date).now(), delegate: void 0 }; class ZF extends Qt { constructor(e = 1 / 0, n = 1 / 0, r = Eh) { super(), this._bufferSize = e, this._windowTime = n, this._timestampProvider = r, this._buffer = [], this._infiniteTimeWindow = !0, this._infiniteTimeWindow = n === 1 / 0, this._bufferSize = Math.max(1, e), this._windowTime = Math.max(1, n) } next(e) { const { isStopped: n, _buffer: r, _infiniteTimeWindow: i, _timestampProvider: o, _windowTime: s } = this; n || (r.push(e), !i && r.push(o.now() + s)), this._trimBuffer(), super.next(e) } _subscribe(e) { this._throwIfClosed(), this._trimBuffer(); const n = this._innerSubscribe(e), { _infiniteTimeWindow: r, _buffer: i } = this, o = i.slice(); for (let s = 0; s < o.length && !e.closed; s += r ? 1 : 2)e.next(o[s]); return this._checkFinalizedStatuses(e), n } _trimBuffer() { const { _bufferSize: e, _timestampProvider: n, _buffer: r, _infiniteTimeWindow: i } = this, o = (i ? 1 : 2) * e; if (e < 1 / 0 && o < r.length && r.splice(0, r.length - o), !i) { const s = n.now(); let a = 0; for (let l = 1; l < r.length && r[l] <= s; l += 2)a = l; a && r.splice(0, a + 1) } } } function bv(t, e) { return Wt((n, r) => { let i = null, o = 0, s = !1; const a = () => s && !i && r.complete(); n.subscribe(et(r, l => { i?.unsubscribe(); let c = 0; const u = o++; Ue(t(l, u)).subscribe(i = et(r, d => r.next(e ? e(l, d, u, c++) : d), () => { i = null, a() })) }, () => { s = !0, a() })) }) } const Ec = { schedule(t, e) { const n = setTimeout(t, e); return () => clearTimeout(n) }, scheduleBeforeRender(t) { if (typeof window > "u") return Ec.schedule(t, 0); if (typeof window.requestAnimationFrame > "u") return Ec.schedule(t, 16); const e = window.requestAnimationFrame(t); return () => window.cancelAnimationFrame(e) } }; let Ch; function rN(t, e, n) { let r = n; return function QF(t) { return !!t && t.nodeType === Node.ELEMENT_NODE }(t) && e.some((i, o) => !("*" === i || !function XF(t, e) { if (!Ch) { const n = Element.prototype; Ch = n.matches || n.matchesSelector || n.mozMatchesSelector || n.msMatchesSelector || n.oMatchesSelector || n.webkitMatchesSelector } return t.nodeType === Node.ELEMENT_NODE && Ch.call(t, e) }(t, i) || (r = o, 0))), r } class oN { constructor(e, n) { this.componentFactory = n.get(Vi).resolveComponentFactory(e) } create(e) { return new sN(this.componentFactory, e) } } class sN { constructor(e, n) { this.componentFactory = e, this.injector = n, this.eventEmitters = new ZF(1), this.events = this.eventEmitters.pipe(bv(r => me(...r))), this.componentRef = null, this.viewChangeDetectorRef = null, this.inputChanges = null, this.hasInputChanges = !1, this.implementsOnChanges = !1, this.scheduledChangeDetectionFn = null, this.scheduledDestroyFn = null, this.initialInputValues = new Map, this.unchangedInputs = new Set(this.componentFactory.inputs.map(({ propName: r }) => r)), this.ngZone = this.injector.get(Xe), this.elementZone = typeof Zone > "u" ? null : this.ngZone.run(() => Zone.current) } connect(e) { this.runInZone(() => { if (null !== this.scheduledDestroyFn) return this.scheduledDestroyFn(), void (this.scheduledDestroyFn = null); null === this.componentRef && this.initializeComponent(e) }) } disconnect() { this.runInZone(() => { null === this.componentRef || null !== this.scheduledDestroyFn || (this.scheduledDestroyFn = Ec.schedule(() => { null !== this.componentRef && (this.componentRef.destroy(), this.componentRef = null, this.viewChangeDetectorRef = null) }, 10)) }) } getInputValue(e) { return this.runInZone(() => null === this.componentRef ? this.initialInputValues.get(e) : this.componentRef.instance[e]) } setInputValue(e, n) { this.runInZone(() => { null !== this.componentRef ? function JF(t, e) { return t === e || t != t && e != e }(n, this.getInputValue(e)) && (void 0 !== n || !this.unchangedInputs.has(e)) || (this.recordInputChange(e, n), this.unchangedInputs.delete(e), this.hasInputChanges = !0, this.componentRef.instance[e] = n, this.scheduleDetectChanges()) : this.initialInputValues.set(e, n) }) } initializeComponent(e) { const n = tn.create({ providers: [], parent: this.injector }), r = function nN(t, e) { const n = t.childNodes, r = e.map(() => []); let i = -1; e.some((o, s) => "*" === o && (i = s, !0)); for (let o = 0, s = n.length; o < s; ++o) { const a = n[o], l = rN(a, e, i); -1 !== l && r[l].push(a) } return r }(e, this.componentFactory.ngContentSelectors); this.componentRef = this.componentFactory.create(n, r, e), this.viewChangeDetectorRef = this.componentRef.injector.get(ts), this.implementsOnChanges = function YF(t) { return "function" == typeof t }(this.componentRef.instance.ngOnChanges), this.initializeInputs(), this.initializeOutputs(this.componentRef), this.detectChanges(), this.injector.get(aa).attachView(this.componentRef.hostView) } initializeInputs() { this.componentFactory.inputs.forEach(({ propName: e }) => { this.initialInputValues.has(e) && this.setInputValue(e, this.initialInputValues.get(e)) }), this.initialInputValues.clear() } initializeOutputs(e) { const n = this.componentFactory.outputs.map(({ propName: r, templateName: i }) => e.instance[r].pipe(Br(s => ({ name: i, value: s })))); this.eventEmitters.next(n) } callNgOnChanges(e) { if (!this.implementsOnChanges || null === this.inputChanges) return; const n = this.inputChanges; this.inputChanges = null, e.instance.ngOnChanges(n) } markViewForCheck(e) { this.hasInputChanges && (this.hasInputChanges = !1, e.markForCheck()) } scheduleDetectChanges() { this.scheduledChangeDetectionFn || (this.scheduledChangeDetectionFn = Ec.scheduleBeforeRender(() => { this.scheduledChangeDetectionFn = null, this.detectChanges() })) } recordInputChange(e, n) { if (!this.implementsOnChanges) return; null === this.inputChanges && (this.inputChanges = {}); const r = this.inputChanges[e]; if (r) return void (r.currentValue = n); const i = this.unchangedInputs.has(e), o = i ? void 0 : this.getInputValue(e); this.inputChanges[e] = new Jm(o, n, i) } detectChanges() { null !== this.componentRef && (this.callNgOnChanges(this.componentRef), this.markViewForCheck(this.viewChangeDetectorRef), this.componentRef.changeDetectorRef.detectChanges()) } runInZone(e) { return this.elementZone && Zone.current !== this.elementZone ? this.ngZone.run(e) : e() } } class aN extends HTMLElement { constructor() { super(...arguments), this.ngElementEventsSubscription = null } } const { isArray: cN } = Array, { getPrototypeOf: uN, prototype: dN, keys: fN } = Object; function yv(t) { if (1 === t.length) { const e = t[0]; if (cN(e)) return { args: e, keys: null }; if (function hN(t) { return t && "object" == typeof t && uN(t) === dN }(e)) { const n = fN(e); return { args: n.map(r => e[r]), keys: n } } } return { args: t, keys: null } } const { isArray: mN } = Array; function Mh(t) { return Br(e => function pN(t, e) { return mN(e) ? t(...e) : t(e) }(t, e)) } function _v(t, e) { return t.reduce((n, r, i) => (n[r] = e[i], n), {}) } let vv = (() => { class t { constructor(n, r) { this._renderer = n, this._elementRef = r, this.onChange = i => { }, this.onTouched = () => { } } setProperty(n, r) { this._renderer.setProperty(this._elementRef.nativeElement, n, r) } registerOnTouched(n) { this.onTouched = n } registerOnChange(n) { this.onChange = n } setDisabledState(n) { this.setProperty("disabled", n) } } return t.\u0275fac = function (n) { return new (n || t)(T(Qr), T(Tt)) }, t.\u0275dir = te({ type: t }), t })(), Ui = (() => { class t extends vv { } return t.\u0275fac = function () { let e; return function (r) { return (e || (e = function Jt(t) { return oi(() => { const e = t.prototype.constructor, n = e[zr] || Ju(e), r = Object.prototype; let i = Object.getPrototypeOf(t.prototype).constructor; for (; i && i !== r;) { const o = i[zr] || Ju(i); if (o && o !== n) return o; i = Object.getPrototypeOf(i) } return o => new o }) }(t)))(r || t) } }(), t.\u0275dir = te({ type: t, features: [je] }), t })(); const Ir = new K("NgValueAccessor"), yN = { provide: Ir, useExisting: Je(() => Cc), multi: !0 }, vN = new K("CompositionEventMode"); let Cc = (() => { class t extends vv { constructor(n, r, i) { super(n, r), this._compositionMode = i, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function _N() { const t = zi() ? zi().getUserAgent() : ""; return /android (\d+)/.test(t.toLowerCase()) }()) } writeValue(n) { this.setProperty("value", n ?? "") } _handleInput(n) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(n) } _compositionStart() { this._composing = !0 } _compositionEnd(n) { this._composing = !1, this._compositionMode && this.onChange(n) } } return t.\u0275fac = function (n) { return new (n || t)(T(Qr), T(Tt), T(vN, 8)) }, t.\u0275dir = te({ type: t, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function (n, r) { 1 & n && St("input", function (o) { return r._handleInput(o.target.value) })("blur", function () { return r.onTouched() })("compositionstart", function () { return r._compositionStart() })("compositionend", function (o) { return r._compositionEnd(o.target.value) }) }, features: [ct([yN]), je] }), t })(); function mi(t) { return null == t || ("string" == typeof t || Array.isArray(t)) && 0 === t.length } function Dv(t) { return null != t && "number" == typeof t.length } const sn = new K("NgValidators"), pi = new K("NgAsyncValidators"), wN = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/; class Mc { static min(e) { return function Ev(t) { return e => { if (mi(e.value) || mi(t)) return null; const n = parseFloat(e.value); return !isNaN(n) && n < t ? { min: { min: t, actual: e.value } } : null } }(e) } static max(e) { return function Cv(t) { return e => { if (mi(e.value) || mi(t)) return null; const n = parseFloat(e.value); return !isNaN(n) && n > t ? { max: { max: t, actual: e.value } } : null } }(e) } static required(e) { return function Mv(t) { return mi(t.value) ? { required: !0 } : null }(e) } static requiredTrue(e) { return function Tv(t) { return !0 === t.value ? null : { required: !0 } }(e) } static email(e) { return function xv(t) { return mi(t.value) || wN.test(t.value) ? null : { email: !0 } }(e) } static minLength(e) { return function kv(t) { return e => mi(e.value) || !Dv(e.value) ? null : e.value.length < t ? { minlength: { requiredLength: t, actualLength: e.value.length } } : null }(e) } static maxLength(e) { return function Av(t) { return e => Dv(e.value) && e.value.length > t ? { maxlength: { requiredLength: t, actualLength: e.value.length } } : null }(e) } static pattern(e) { return function Sv(t) { if (!t) return Tc; let e, n; return "string" == typeof t ? (n = "", "^" !== t.charAt(0) && (n += "^"), n += t, "$" !== t.charAt(t.length - 1) && (n += "$"), e = new RegExp(n)) : (n = t.toString(), e = t), r => { if (mi(r.value)) return null; const i = r.value; return e.test(i) ? null : { pattern: { requiredPattern: n, actualValue: i } } } }(e) } static nullValidator(e) { return null } static compose(e) { return Pv(e) } static composeAsync(e) { return Lv(e) } } function Tc(t) { return null } function Iv(t) { return null != t } function Fv(t) { const e = Hl(t) ? le(t) : t; return oy(e), e } function Nv(t) { let e = {}; return t.forEach(n => { e = null != n ? { ...e, ...n } : e }), 0 === Object.keys(e).length ? null : e } function Ov(t, e) { return e.map(n => n(t)) } function Rv(t) { return t.map(e => function DN(t) { return !t.validate }(e) ? e : n => e.validate(n)) } function Pv(t) { if (!t) return null; const e = t.filter(Iv); return 0 == e.length ? null : function (n) { return Nv(Ov(n, e)) } } function Th(t) { return null != t ? Pv(Rv(t)) : null } function Lv(t) { if (!t) return null; const e = t.filter(Iv); return 0 == e.length ? null : function (n) { return function gN(...t) { const e = _(t), { args: n, keys: r } = yv(t), i = new qe(o => { const { length: s } = n; if (!s) return void o.complete(); const a = new Array(s); let l = s, c = s; for (let u = 0; u < s; u++) { let d = !1; Ue(n[u]).subscribe(et(o, f => { d || (d = !0, c--), a[u] = f }, () => l--, void 0, () => { (!l || !d) && (c || o.next(r ? _v(r, a) : a), o.complete()) })) } }); return e ? i.pipe(Mh(e)) : i }(Ov(n, e).map(Fv)).pipe(Br(Nv)) } } function xh(t) { return null != t ? Lv(Rv(t)) : null } function Vv(t, e) { return null === t ? [e] : Array.isArray(t) ? [...t, e] : [t, e] } function Bv(t) { return t._rawValidators } function Hv(t) { return t._rawAsyncValidators } function kh(t) { return t ? Array.isArray(t) ? t : [t] : [] } function xc(t, e) { return Array.isArray(t) ? t.includes(e) : t === e } function jv(t, e) { const n = kh(e); return kh(t).forEach(i => { xc(n, i) || n.push(i) }), n } function $v(t, e) { return kh(e).filter(n => !xc(t, n)) } class zv { constructor() { this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = [] } get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } _setValidators(e) { this._rawValidators = e || [], this._composedValidatorFn = Th(this._rawValidators) } _setAsyncValidators(e) { this._rawAsyncValidators = e || [], this._composedAsyncValidatorFn = xh(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn || null } get asyncValidator() { return this._composedAsyncValidatorFn || null } _registerOnDestroy(e) { this._onDestroyCallbacks.push(e) } _invokeOnDestroyCallbacks() { this._onDestroyCallbacks.forEach(e => e()), this._onDestroyCallbacks = [] } reset(e) { this.control && this.control.reset(e) } hasError(e, n) { return !!this.control && this.control.hasError(e, n) } getError(e, n) { return this.control ? this.control.getError(e, n) : null } } class bn extends zv { get formDirective() { return null } get path() { return null } } class Fr extends zv { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null } } class Uv { constructor(e) { this._cd = e } get isTouched() { return !!this._cd?.control?.touched } get isUntouched() { return !!this._cd?.control?.untouched } get isPristine() { return !!this._cd?.control?.pristine } get isDirty() { return !!this._cd?.control?.dirty } get isValid() { return !!this._cd?.control?.valid } get isInvalid() { return !!this._cd?.control?.invalid } get isPending() { return !!this._cd?.control?.pending } get isSubmitted() { return !!this._cd?.submitted } } let Gv = (() => { class t extends Uv { constructor(n) { super(n) } } return t.\u0275fac = function (n) { return new (n || t)(T(Fr, 2)) }, t.\u0275dir = te({ type: t, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function (n, r) { 2 & n && En("ng-untouched", r.isUntouched)("ng-touched", r.isTouched)("ng-pristine", r.isPristine)("ng-dirty", r.isDirty)("ng-valid", r.isValid)("ng-invalid", r.isInvalid)("ng-pending", r.isPending) }, features: [je] }), t })(), qv = (() => { class t extends Uv { constructor(n) { super(n) } } return t.\u0275fac = function (n) { return new (n || t)(T(bn, 10)) }, t.\u0275dir = te({ type: t, selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]], hostVars: 16, hostBindings: function (n, r) { 2 & n && En("ng-untouched", r.isUntouched)("ng-touched", r.isTouched)("ng-pristine", r.isPristine)("ng-dirty", r.isDirty)("ng-valid", r.isValid)("ng-invalid", r.isInvalid)("ng-pending", r.isPending)("ng-submitted", r.isSubmitted) }, features: [je] }), t })(); const ha = "VALID", Ac = "INVALID", ns = "PENDING", ma = "DISABLED"; function Fh(t) { return (Sc(t) ? t.validators : t) || null } function Zv(t) { return Array.isArray(t) ? Th(t) : t || null } function Nh(t, e) { return (Sc(e) ? e.asyncValidators : t) || null } function Kv(t) { return Array.isArray(t) ? xh(t) : t || null } function Sc(t) { return null != t && !Array.isArray(t) && "object" == typeof t } function Qv(t, e, n) { const r = t.controls; if (!(e ? Object.keys(r) : r).length) throw new P(1e3, ""); if (!r[n]) throw new P(1001, "") } function Yv(t, e, n) { t._forEachChild((r, i) => { if (void 0 === n[i]) throw new P(1002, "") }) } class Ic { constructor(e, n) { this._pendingDirty = !1, this._hasOwnPendingAsyncValidator = !1, this._pendingTouched = !1, this._onCollectionChange = () => { }, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._rawValidators = e, this._rawAsyncValidators = n, this._composedValidatorFn = Zv(this._rawValidators), this._composedAsyncValidatorFn = Kv(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn } set validator(e) { this._rawValidators = this._composedValidatorFn = e } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(e) { this._rawAsyncValidators = this._composedAsyncValidatorFn = e } get parent() { return this._parent } get valid() { return this.status === ha } get invalid() { return this.status === Ac } get pending() { return this.status == ns } get disabled() { return this.status === ma } get enabled() { return this.status !== ma } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(e) { this._rawValidators = e, this._composedValidatorFn = Zv(e) } setAsyncValidators(e) { this._rawAsyncValidators = e, this._composedAsyncValidatorFn = Kv(e) } addValidators(e) { this.setValidators(jv(e, this._rawValidators)) } addAsyncValidators(e) { this.setAsyncValidators(jv(e, this._rawAsyncValidators)) } removeValidators(e) { this.setValidators($v(e, this._rawValidators)) } removeAsyncValidators(e) { this.setAsyncValidators($v(e, this._rawAsyncValidators)) } hasValidator(e) { return xc(this._rawValidators, e) } hasAsyncValidator(e) { return xc(this._rawAsyncValidators, e) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(e = {}) { this.touched = !0, this._parent && !e.onlySelf && this._parent.markAsTouched(e) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(e => e.markAllAsTouched()) } markAsUntouched(e = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(n => { n.markAsUntouched({ onlySelf: !0 }) }), this._parent && !e.onlySelf && this._parent._updateTouched(e) } markAsDirty(e = {}) { this.pristine = !1, this._parent && !e.onlySelf && this._parent.markAsDirty(e) } markAsPristine(e = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(n => { n.markAsPristine({ onlySelf: !0 }) }), this._parent && !e.onlySelf && this._parent._updatePristine(e) } markAsPending(e = {}) { this.status = ns, !1 !== e.emitEvent && this.statusChanges.emit(this.status), this._parent && !e.onlySelf && this._parent.markAsPending(e) } disable(e = {}) { const n = this._parentMarkedDirty(e.onlySelf); this.status = ma, this.errors = null, this._forEachChild(r => { r.disable({ ...e, onlySelf: !0 }) }), this._updateValue(), !1 !== e.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors({ ...e, skipPristineCheck: n }), this._onDisabledChange.forEach(r => r(!0)) } enable(e = {}) { const n = this._parentMarkedDirty(e.onlySelf); this.status = ha, this._forEachChild(r => { r.enable({ ...e, onlySelf: !0 }) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: e.emitEvent }), this._updateAncestors({ ...e, skipPristineCheck: n }), this._onDisabledChange.forEach(r => r(!1)) } _updateAncestors(e) { this._parent && !e.onlySelf && (this._parent.updateValueAndValidity(e), e.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(e) { this._parent = e } getRawValue() { return this.value } updateValueAndValidity(e = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), (this.status === ha || this.status === ns) && this._runAsyncValidator(e.emitEvent)), !1 !== e.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !e.onlySelf && this._parent.updateValueAndValidity(e) } _updateTreeValidity(e = { emitEvent: !0 }) { this._forEachChild(n => n._updateTreeValidity(e)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: e.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? ma : ha } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(e) { if (this.asyncValidator) { this.status = ns, this._hasOwnPendingAsyncValidator = !0; const n = Fv(this.asyncValidator(this)); this._asyncValidationSubscription = n.subscribe(r => { this._hasOwnPendingAsyncValidator = !1, this.setErrors(r, { emitEvent: e }) }) } } _cancelExistingSubscription() { this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1) } setErrors(e, n = {}) { this.errors = e, this._updateControlsErrors(!1 !== n.emitEvent) } get(e) { let n = e; return null == n || (Array.isArray(n) || (n = n.split(".")), 0 === n.length) ? null : n.reduce((r, i) => r && r._find(i), this) } getError(e, n) { const r = n ? this.get(n) : this; return r && r.errors ? r.errors[e] : null } hasError(e, n) { return !!this.getError(e, n) } get root() { let e = this; for (; e._parent;)e = e._parent; return e } _updateControlsErrors(e) { this.status = this._calculateStatus(), e && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(e) } _initObservables() { this.valueChanges = new Ye, this.statusChanges = new Ye } _calculateStatus() { return this._allControlsDisabled() ? ma : this.errors ? Ac : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(ns) ? ns : this._anyControlsHaveStatus(Ac) ? Ac : ha } _anyControlsHaveStatus(e) { return this._anyControls(n => n.status === e) } _anyControlsDirty() { return this._anyControls(e => e.dirty) } _anyControlsTouched() { return this._anyControls(e => e.touched) } _updatePristine(e = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !e.onlySelf && this._parent._updatePristine(e) } _updateTouched(e = {}) { this.touched = this._anyControlsTouched(), this._parent && !e.onlySelf && this._parent._updateTouched(e) } _registerOnCollectionChange(e) { this._onCollectionChange = e } _setUpdateStrategy(e) { Sc(e) && null != e.updateOn && (this._updateOn = e.updateOn) } _parentMarkedDirty(e) { return !e && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty() } _find(e) { return null } } class Fc extends Ic { constructor(e, n, r) { super(Fh(n), Nh(r, n)), this.controls = e, this._initObservables(), this._setUpdateStrategy(n), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } registerControl(e, n) { return this.controls[e] ? this.controls[e] : (this.controls[e] = n, n.setParent(this), n._registerOnCollectionChange(this._onCollectionChange), n) } addControl(e, n, r = {}) { this.registerControl(e, n), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } removeControl(e, n = {}) { this.controls[e] && this.controls[e]._registerOnCollectionChange(() => { }), delete this.controls[e], this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange() } setControl(e, n, r = {}) { this.controls[e] && this.controls[e]._registerOnCollectionChange(() => { }), delete this.controls[e], n && this.registerControl(e, n), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } contains(e) { return this.controls.hasOwnProperty(e) && this.controls[e].enabled } setValue(e, n = {}) { Yv(this, 0, e), Object.keys(e).forEach(r => { Qv(this, !0, r), this.controls[r].setValue(e[r], { onlySelf: !0, emitEvent: n.emitEvent }) }), this.updateValueAndValidity(n) } patchValue(e, n = {}) { null != e && (Object.keys(e).forEach(r => { const i = this.controls[r]; i && i.patchValue(e[r], { onlySelf: !0, emitEvent: n.emitEvent }) }), this.updateValueAndValidity(n)) } reset(e = {}, n = {}) { this._forEachChild((r, i) => { r.reset(e[i], { onlySelf: !0, emitEvent: n.emitEvent }) }), this._updatePristine(n), this._updateTouched(n), this.updateValueAndValidity(n) } getRawValue() { return this._reduceChildren({}, (e, n, r) => (e[r] = n.getRawValue(), e)) } _syncPendingControls() { let e = this._reduceChildren(!1, (n, r) => !!r._syncPendingControls() || n); return e && this.updateValueAndValidity({ onlySelf: !0 }), e } _forEachChild(e) { Object.keys(this.controls).forEach(n => { const r = this.controls[n]; r && e(r, n) }) } _setUpControls() { this._forEachChild(e => { e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(e) { for (const [n, r] of Object.entries(this.controls)) if (this.contains(n) && e(r)) return !0; return !1 } _reduceValue() { return this._reduceChildren({}, (n, r, i) => ((r.enabled || this.disabled) && (n[i] = r.value), n)) } _reduceChildren(e, n) { let r = e; return this._forEachChild((i, o) => { r = n(r, i, o) }), r } _allControlsDisabled() { for (const e of Object.keys(this.controls)) if (this.controls[e].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _find(e) { return this.controls.hasOwnProperty(e) ? this.controls[e] : null } } function pa(t, e) { Oh(t, e), e.valueAccessor.writeValue(t.value), t.disabled && e.valueAccessor.setDisabledState?.(!0), function IN(t, e) { e.valueAccessor.registerOnChange(n => { t._pendingValue = n, t._pendingChange = !0, t._pendingDirty = !0, "change" === t.updateOn && Xv(t, e) }) }(t, e), function NN(t, e) { const n = (r, i) => { e.valueAccessor.writeValue(r), i && e.viewToModelUpdate(r) }; t.registerOnChange(n), e._registerOnDestroy(() => { t._unregisterOnChange(n) }) }(t, e), function FN(t, e) { e.valueAccessor.registerOnTouched(() => { t._pendingTouched = !0, "blur" === t.updateOn && t._pendingChange && Xv(t, e), "submit" !== t.updateOn && t.markAsTouched() }) }(t, e), function SN(t, e) { if (e.valueAccessor.setDisabledState) { const n = r => { e.valueAccessor.setDisabledState(r) }; t.registerOnDisabledChange(n), e._registerOnDestroy(() => { t._unregisterOnDisabledChange(n) }) } }(t, e) } function Oc(t, e, n = !0) { const r = () => { }; e.valueAccessor && (e.valueAccessor.registerOnChange(r), e.valueAccessor.registerOnTouched(r)), Pc(t, e), t && (e._invokeOnDestroyCallbacks(), t._registerOnCollectionChange(() => { })) } function Rc(t, e) { t.forEach(n => { n.registerOnValidatorChange && n.registerOnValidatorChange(e) }) } function Oh(t, e) { const n = Bv(t); null !== e.validator ? t.setValidators(Vv(n, e.validator)) : "function" == typeof n && t.setValidators([n]); const r = Hv(t); null !== e.asyncValidator ? t.setAsyncValidators(Vv(r, e.asyncValidator)) : "function" == typeof r && t.setAsyncValidators([r]); const i = () => t.updateValueAndValidity(); Rc(e._rawValidators, i), Rc(e._rawAsyncValidators, i) } function Pc(t, e) { let n = !1; if (null !== t) { if (null !== e.validator) { const i = Bv(t); if (Array.isArray(i) && i.length > 0) { const o = i.filter(s => s !== e.validator); o.length !== i.length && (n = !0, t.setValidators(o)) } } if (null !== e.asyncValidator) { const i = Hv(t); if (Array.isArray(i) && i.length > 0) { const o = i.filter(s => s !== e.asyncValidator); o.length !== i.length && (n = !0, t.setAsyncValidators(o)) } } } const r = () => { }; return Rc(e._rawValidators, r), Rc(e._rawAsyncValidators, r), n } function Xv(t, e) { t._pendingDirty && t.markAsDirty(), t.setValue(t._pendingValue, { emitModelToViewChange: !1 }), e.viewToModelUpdate(t._pendingValue), t._pendingChange = !1 } function Jv(t, e) { Oh(t, e) } function tw(t, e) { t._syncPendingControls(), e.forEach(n => { const r = n.control; "submit" === r.updateOn && r._pendingChange && (n.viewToModelUpdate(r._pendingValue), r._pendingChange = !1) }) } const VN = { provide: bn, useExisting: Je(() => Lc) }, ga = (() => Promise.resolve(null))(); let Lc = (() => { class t extends bn { constructor(n, r) { super(), this.submitted = !1, this._directives = new Set, this.ngSubmit = new Ye, this.form = new Fc({}, Th(n), xh(r)) } ngAfterViewInit() { this._setUpdateStrategy() } get formDirective() { return this } get control() { return this.form } get path() { return [] } get controls() { return this.form.controls } addControl(n) { ga.then(() => { const r = this._findContainer(n.path); n.control = r.registerControl(n.name, n.control), pa(n.control, n), n.control.updateValueAndValidity({ emitEvent: !1 }), this._directives.add(n) }) } getControl(n) { return this.form.get(n.path) } removeControl(n) { ga.then(() => { const r = this._findContainer(n.path); r && r.removeControl(n.name), this._directives.delete(n) }) } addFormGroup(n) { ga.then(() => { const r = this._findContainer(n.path), i = new Fc({}); Jv(i, n), r.registerControl(n.name, i), i.updateValueAndValidity({ emitEvent: !1 }) }) } removeFormGroup(n) { ga.then(() => { const r = this._findContainer(n.path); r && r.removeControl(n.name) }) } getFormGroup(n) { return this.form.get(n.path) } updateModel(n, r) { ga.then(() => { this.form.get(n.path).setValue(r) }) } setValue(n) { this.control.setValue(n) } onSubmit(n) { return this.submitted = !0, tw(this.form, this._directives), this.ngSubmit.emit(n), !1 } onReset() { this.resetForm() } resetForm(n) { this.form.reset(n), this.submitted = !1 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn) } _findContainer(n) { return n.pop(), n.length ? this.form.get(n) : this.form } } return t.\u0275fac = function (n) { return new (n || t)(T(sn, 10), T(pi, 10)) }, t.\u0275dir = te({ type: t, selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]], hostBindings: function (n, r) { 1 & n && St("submit", function (o) { return r.onSubmit(o) })("reset", function () { return r.onReset() }) }, inputs: { options: ["ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [ct([VN]), je] }), t })(); function nw(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } function rw(t) { return "object" == typeof t && null !== t && 2 === Object.keys(t).length && "value" in t && "disabled" in t } const ba = class extends Ic { constructor(e = null, n, r) { super(Fh(n), Nh(r, n)), this.defaultValue = null, this._onChange = [], this._pendingChange = !1, this._applyFormState(e), this._setUpdateStrategy(n), this._initObservables(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }), Sc(n) && (n.nonNullable || n.initialValueIsDefault) && (this.defaultValue = rw(e) ? e.value : e) } setValue(e, n = {}) { this.value = this._pendingValue = e, this._onChange.length && !1 !== n.emitModelToViewChange && this._onChange.forEach(r => r(this.value, !1 !== n.emitViewToModelChange)), this.updateValueAndValidity(n) } patchValue(e, n = {}) { this.setValue(e, n) } reset(e = this.defaultValue, n = {}) { this._applyFormState(e), this.markAsPristine(n), this.markAsUntouched(n), this.setValue(this.value, n), this._pendingChange = !1 } _updateValue() { } _anyControls(e) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(e) { this._onChange.push(e) } _unregisterOnChange(e) { nw(this._onChange, e) } registerOnDisabledChange(e) { this._onDisabledChange.push(e) } _unregisterOnDisabledChange(e) { nw(this._onDisabledChange, e) } _forEachChild(e) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(e) { rw(e) ? (this.value = this._pendingValue = e.value, e.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = e } }; let lw = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275dir = te({ type: t, selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]], hostAttrs: ["novalidate", ""] }), t })(), uw = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Ot({ type: t }), t.\u0275inj = At({}), t })(); const Lh = new K("NgModelWithFormControlWarning"), WN = { provide: bn, useExisting: Je(() => ya) }; let ya = (() => { class t extends bn { constructor(n, r) { super(), this.validators = n, this.asyncValidators = r, this.submitted = !1, this._onCollectionChange = () => this._updateDomValue(), this.directives = [], this.form = null, this.ngSubmit = new Ye, this._setValidators(n), this._setAsyncValidators(r) } ngOnChanges(n) { this._checkFormPresent(), n.hasOwnProperty("form") && (this._updateValidators(), this._updateDomValue(), this._updateRegistrations(), this._oldForm = this.form) } ngOnDestroy() { this.form && (Pc(this.form, this), this.form._onCollectionChange === this._onCollectionChange && this.form._registerOnCollectionChange(() => { })) } get formDirective() { return this } get control() { return this.form } get path() { return [] } addControl(n) { const r = this.form.get(n.path); return pa(r, n), r.updateValueAndValidity({ emitEvent: !1 }), this.directives.push(n), r } getControl(n) { return this.form.get(n.path) } removeControl(n) { Oc(n.control || null, n, !1), function LN(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) }(this.directives, n) } addFormGroup(n) { this._setUpFormContainer(n) } removeFormGroup(n) { this._cleanUpFormContainer(n) } getFormGroup(n) { return this.form.get(n.path) } addFormArray(n) { this._setUpFormContainer(n) } removeFormArray(n) { this._cleanUpFormContainer(n) } getFormArray(n) { return this.form.get(n.path) } updateModel(n, r) { this.form.get(n.path).setValue(r) } onSubmit(n) { return this.submitted = !0, tw(this.form, this.directives), this.ngSubmit.emit(n), !1 } onReset() { this.resetForm() } resetForm(n) { this.form.reset(n), this.submitted = !1 } _updateDomValue() { this.directives.forEach(n => { const r = n.control, i = this.form.get(n.path); r !== i && (Oc(r || null, n), (t => t instanceof ba)(i) && (pa(i, n), n.control = i)) }), this.form._updateTreeValidity({ emitEvent: !1 }) } _setUpFormContainer(n) { const r = this.form.get(n.path); Jv(r, n), r.updateValueAndValidity({ emitEvent: !1 }) } _cleanUpFormContainer(n) { if (this.form) { const r = this.form.get(n.path); r && function ON(t, e) { return Pc(t, e) }(r, n) && r.updateValueAndValidity({ emitEvent: !1 }) } } _updateRegistrations() { this.form._registerOnCollectionChange(this._onCollectionChange), this._oldForm && this._oldForm._registerOnCollectionChange(() => { }) } _updateValidators() { Oh(this.form, this), this._oldForm && Pc(this._oldForm, this) } _checkFormPresent() { } } return t.\u0275fac = function (n) { return new (n || t)(T(sn, 10), T(pi, 10)) }, t.\u0275dir = te({ type: t, selectors: [["", "formGroup", ""]], hostBindings: function (n, r) { 1 & n && St("submit", function (o) { return r.onSubmit(o) })("reset", function () { return r.onReset() }) }, inputs: { form: ["formGroup", "form"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [ct([WN]), je, yr] }), t })(); const QN = { provide: Fr, useExisting: Je(() => Hh) }; let Hh = (() => { class t extends Fr { constructor(n, r, i, o, s) { super(), this._ngModelWarningConfig = s, this._added = !1, this.update = new Ye, this._ngModelWarningSent = !1, this._parent = n, this._setValidators(r), this._setAsyncValidators(i), this.valueAccessor = function Ph(t, e) { if (!e) return null; let n, r, i; return Array.isArray(e), e.forEach(o => { o.constructor === Cc ? n = o : function PN(t) { return Object.getPrototypeOf(t.constructor) === Ui }(o) ? r = o : i = o }), i || r || n || null }(0, o) } set isDisabled(n) { } ngOnChanges(n) { this._added || this._setUpControl(), function Rh(t, e) { if (!t.hasOwnProperty("model")) return !1; const n = t.model; return !!n.isFirstChange() || !Object.is(e, n.currentValue) }(n, this.viewModel) && (this.viewModel = this.model, this.formDirective.updateModel(this, this.model)) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } viewToModelUpdate(n) { this.viewModel = n, this.update.emit(n) } get path() { return function Nc(t, e) { return [...e.path, t] }(null == this.name ? this.name : this.name.toString(), this._parent) } get formDirective() { return this._parent ? this._parent.formDirective : null } _checkParentType() { } _setUpControl() { this._checkParentType(), this.control = this.formDirective.addControl(this), this._added = !0 } } return t._ngModelWarningSentOnce = !1, t.\u0275fac = function (n) { return new (n || t)(T(bn, 13), T(sn, 10), T(pi, 10), T(Ir, 10), T(Lh, 8)) }, t.\u0275dir = te({ type: t, selectors: [["", "formControlName", ""]], inputs: { name: ["formControlName", "name"], isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, features: [ct([QN]), je, yr] }), t })(), Tw = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Ot({ type: t }), t.\u0275inj = At({ imports: [uw] }), t })(), dO = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Ot({ type: t }), t.\u0275inj = At({ imports: [Tw] }), t })(), xw = (() => { class t { static withConfig(n) { return { ngModule: t, providers: [{ provide: Lh, useValue: n.warnOnNgModelWithFormControl }] } } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Ot({ type: t }), t.\u0275inj = At({ imports: [Tw] }), t })(); class kw extends Ic { constructor(e, n, r) { super(Fh(n), Nh(r, n)), this.controls = e, this._initObservables(), this._setUpdateStrategy(n), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } at(e) { return this.controls[this._adjustIndex(e)] } push(e, n = {}) { this.controls.push(e), this._registerControl(e), this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange() } insert(e, n, r = {}) { this.controls.splice(e, 0, n), this._registerControl(n), this.updateValueAndValidity({ emitEvent: r.emitEvent }) } removeAt(e, n = {}) { let r = this._adjustIndex(e); r < 0 && (r = 0), this.controls[r] && this.controls[r]._registerOnCollectionChange(() => { }), this.controls.splice(r, 1), this.updateValueAndValidity({ emitEvent: n.emitEvent }) } setControl(e, n, r = {}) { let i = this._adjustIndex(e); i < 0 && (i = 0), this.controls[i] && this.controls[i]._registerOnCollectionChange(() => { }), this.controls.splice(i, 1), n && (this.controls.splice(i, 0, n), this._registerControl(n)), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } get length() { return this.controls.length } setValue(e, n = {}) { Yv(this, 0, e), e.forEach((r, i) => { Qv(this, !1, i), this.at(i).setValue(r, { onlySelf: !0, emitEvent: n.emitEvent }) }), this.updateValueAndValidity(n) } patchValue(e, n = {}) { null != e && (e.forEach((r, i) => { this.at(i) && this.at(i).patchValue(r, { onlySelf: !0, emitEvent: n.emitEvent }) }), this.updateValueAndValidity(n)) } reset(e = [], n = {}) { this._forEachChild((r, i) => { r.reset(e[i], { onlySelf: !0, emitEvent: n.emitEvent }) }), this._updatePristine(n), this._updateTouched(n), this.updateValueAndValidity(n) } getRawValue() { return this.controls.map(e => e.getRawValue()) } clear(e = {}) { this.controls.length < 1 || (this._forEachChild(n => n._registerOnCollectionChange(() => { })), this.controls.splice(0), this.updateValueAndValidity({ emitEvent: e.emitEvent })) } _adjustIndex(e) { return e < 0 ? e + this.length : e } _syncPendingControls() { let e = this.controls.reduce((n, r) => !!r._syncPendingControls() || n, !1); return e && this.updateValueAndValidity({ onlySelf: !0 }), e } _forEachChild(e) { this.controls.forEach((n, r) => { e(n, r) }) } _updateValue() { this.value = this.controls.filter(e => e.enabled || this.disabled).map(e => e.value) } _anyControls(e) { return this.controls.some(n => n.enabled && e(n)) } _setUpControls() { this._forEachChild(e => this._registerControl(e)) } _allControlsDisabled() { for (const e of this.controls) if (e.enabled) return !1; return this.controls.length > 0 || this.disabled } _registerControl(e) { e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange) } _find(e) { return this.at(e) ?? null } } function Uh(t) { return !!t && (void 0 !== t.asyncValidators || void 0 !== t.validators || void 0 !== t.updateOn) } let Gh, fO = (() => { class t { constructor() { this.useNonNullable = !1 } get nonNullable() { const n = new t; return n.useNonNullable = !0, n } group(n, r = null) { const i = this._reduceControls(n); let a, o = null, s = null; return null !== r && (Uh(r) ? (o = null != r.validators ? r.validators : null, s = null != r.asyncValidators ? r.asyncValidators : null, a = null != r.updateOn ? r.updateOn : void 0) : (o = null != r.validator ? r.validator : null, s = null != r.asyncValidator ? r.asyncValidator : null)), new Fc(i, { asyncValidators: s, updateOn: a, validators: o }) } control(n, r, i) { let o = {}; return this.useNonNullable ? (Uh(r) ? o = r : (o.validators = r, o.asyncValidators = i), new ba(n, { ...o, nonNullable: !0 })) : new ba(n, r, i) } array(n, r, i) { const o = n.map(s => this._createControl(s)); return new kw(o, r, i) } _reduceControls(n) { const r = {}; return Object.keys(n).forEach(i => { r[i] = this._createControl(n[i]) }), r } _createControl(n) { return n instanceof ba || n instanceof Ic ? n : Array.isArray(n) ? this.control(n[0], n.length > 1 ? n[1] : null, n.length > 2 ? n[2] : null) : this.control(n) } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac, providedIn: xw }), t })(); try { Gh = typeof Intl < "u" && Intl.v8BreakIterator } catch { Gh = !1 } let rs, gi = (() => { class t { constructor(n) { this._platformId = n, this.isBrowser = this._platformId ? Y0(this._platformId) : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !Gh) && typeof CSS < "u" && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT } } return t.\u0275fac = function (n) { return new (n || t)(B(Jl)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); const Aw = ["color", "button", "checkbox", "date", "datetime-local", "email", "file", "hidden", "image", "month", "number", "password", "radio", "range", "reset", "search", "submit", "tel", "text", "time", "url", "week"]; function Sw() { if (rs) return rs; if ("object" != typeof document || !document) return rs = new Set(Aw), rs; let t = document.createElement("input"); return rs = new Set(Aw.filter(e => (t.setAttribute("type", e), t.type === e))), rs } let _a, qh; function Vc(t) { return function hO() { if (null == _a && typeof window < "u") try { window.addEventListener("test", null, Object.defineProperty({}, "passive", { get: () => _a = !0 })) } finally { _a = _a || !1 } return _a }() ? t : !!t.capture } function va(t) { return t.composedPath ? t.composedPath()[0] : t.target } class bO extends Qt { constructor(e) { super(), this._value = e } get value() { return this.getValue() } _subscribe(e) { const n = super._subscribe(e); return !n.closed && e.next(this._value), n } getValue() { const { hasError: e, thrownError: n, _value: r } = this; if (e) throw n; return this._throwIfClosed(), r } next(e) { super.next(this._value = e) } } function Iw(...t) { return le(t, X(t)) } function Fw(t, e) { return Wt((n, r) => { let i = 0; n.subscribe(et(r, o => t.call(e, o, i++) && r.next(o))) }) } function Nw(t) { return Fw((e, n) => t <= n) } function CO(t, e) { return t === e } function wa(t) { return Wt((e, n) => { Ue(t).subscribe(et(n, () => n.complete(), Pr)), !n.closed && e.subscribe(n) }) } function Wi(t) { return null != t && "false" != `${t}` } function Ow(t) { return Array.isArray(t) ? t : [t] } function bi(t) { return t instanceof Tt ? t.nativeElement : t } function Rw(t, e, n) { t ? Nt(n, t, e) : e() } function Wh(...t) { return function AO() { return vn(1) }()(le(t, X(t))) } class SO extends ln { constructor(e, n) { super() } schedule(e, n = 0) { return this } } const Hc = { setInterval(t, e, ...n) { const { delegate: r } = Hc; return r?.setInterval ? r.setInterval(t, e, ...n) : setInterval(t, e, ...n) }, clearInterval(t) { const { delegate: e } = Hc; return (e?.clearInterval || clearInterval)(t) }, delegate: void 0 }; class Pw extends SO { constructor(e, n) { super(e, n), this.scheduler = e, this.work = n, this.pending = !1 } schedule(e, n = 0) { if (this.closed) return this; this.state = e; const r = this.id, i = this.scheduler; return null != r && (this.id = this.recycleAsyncId(i, r, n)), this.pending = !0, this.delay = n, this.id = this.id || this.requestAsyncId(i, this.id, n), this } requestAsyncId(e, n, r = 0) { return Hc.setInterval(e.flush.bind(e, this), r) } recycleAsyncId(e, n, r = 0) { if (null != r && this.delay === r && !1 === this.pending) return n; Hc.clearInterval(n) } execute(e, n) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; const r = this._execute(e, n); if (r) return r; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(e, n) { let i, r = !1; try { this.work(e) } catch (o) { r = !0, i = o || new Error("Scheduled action threw falsy error") } if (r) return this.unsubscribe(), i } unsubscribe() { if (!this.closed) { const { id: e, scheduler: n } = this, { actions: r } = n; this.work = this.state = this.scheduler = null, this.pending = !1, to(r, this), null != e && (this.id = this.recycleAsyncId(n, e, null)), this.delay = null, super.unsubscribe() } } } class Da { constructor(e, n = Da.now) { this.schedulerActionCtor = e, this.now = n } schedule(e, n = 0, r) { return new this.schedulerActionCtor(this, e).schedule(r, n) } } Da.now = Eh.now; class Lw extends Da { constructor(e, n = Da.now) { super(e, n), this.actions = [], this._active = !1, this._scheduled = void 0 } flush(e) { const { actions: n } = this; if (this._active) return void n.push(e); let r; this._active = !0; do { if (r = e.execute(e.state, e.delay)) break } while (e = n.shift()); if (this._active = !1, r) { for (; e = n.shift();)e.unsubscribe(); throw r } } } const IO = new Lw(Pw); function jc(t, e = IO) { return Wt((n, r) => { let i = null, o = null, s = null; const a = () => { if (i) { i.unsubscribe(), i = null; const c = o; o = null, r.next(c) } }; function l() { const c = s + t, u = e.now(); if (u < c) return i = this.schedule(void 0, c - u), void r.add(i); a() } n.subscribe(et(r, c => { o = c, s = e.now(), i || (i = e.schedule(l, t), r.add(i)) }, () => { a(), r.complete() }, void 0, () => { o = i = null })) }) } function $c(...t) { const e = X(t); return Wt((n, r) => { (e ? Wh(t, n, e) : Wh(t, n)).subscribe(r) }) } const Vw = new Set; let is, FO = (() => { class t { constructor(n) { this._platform = n, this._matchMedia = this._platform.isBrowser && window.matchMedia ? window.matchMedia.bind(window) : OO } matchMedia(n) { return (this._platform.WEBKIT || this._platform.BLINK) && function NO(t) { if (!Vw.has(t)) try { is || (is = document.createElement("style"), is.setAttribute("type", "text/css"), document.head.appendChild(is)), is.sheet && (is.sheet.insertRule(`@media ${t} {body{ }}`, 0), Vw.add(t)) } catch (e) { console.error(e) } }(n), this._matchMedia(n) } } return t.\u0275fac = function (n) { return new (n || t)(B(gi)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); function OO(t) { return { matches: "all" === t || "" === t, media: t, addListener: () => { }, removeListener: () => { } } } let RO = (() => { class t { constructor(n, r) { this._mediaMatcher = n, this._zone = r, this._queries = new Map, this._destroySubject = new Qt } ngOnDestroy() { this._destroySubject.next(), this._destroySubject.complete() } isMatched(n) { return Bw(Ow(n)).some(i => this._registerQuery(i).mql.matches) } observe(n) { let o = function xO(...t) { const e = X(t), n = _(t), { args: r, keys: i } = yv(t); if (0 === r.length) return le([], e); const o = new qe(function kO(t, e, n = Vr) { return r => { Rw(e, () => { const { length: i } = t, o = new Array(i); let s = i, a = i; for (let l = 0; l < i; l++)Rw(e, () => { const c = le(t[l], e); let u = !1; c.subscribe(et(r, d => { o[l] = d, u || (u = !0, a--), a || r.next(n(o.slice())) }, () => { --s || r.complete() })) }, r) }, r) } }(r, e, i ? s => _v(i, s) : Vr)); return n ? o.pipe(Mh(n)) : o }(Bw(Ow(n)).map(s => this._registerQuery(s).observable)); return o = Wh(o.pipe(We(1)), o.pipe(Nw(1), jc(0))), o.pipe(Br(s => { const a = { matches: !1, breakpoints: {} }; return s.forEach(({ matches: l, query: c }) => { a.matches = a.matches || l, a.breakpoints[c] = l }), a })) } _registerQuery(n) { if (this._queries.has(n)) return this._queries.get(n); const r = this._mediaMatcher.matchMedia(n), o = { observable: new qe(s => { const a = l => this._zone.run(() => s.next(l)); return r.addListener(a), () => { r.removeListener(a) } }).pipe($c(r), Br(({ matches: s }) => ({ query: n, matches: s })), wa(this._destroySubject)), mql: r }; return this._queries.set(n, o), o } } return t.\u0275fac = function (n) { return new (n || t)(B(FO), B(Xe)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); function Bw(t) { return t.map(e => e.split(",")).reduce((e, n) => e.concat(n)).map(e => e.trim()) } function zw(t) { return 0 === t.buttons || 0 === t.offsetX && 0 === t.offsetY } function Uw(t) { const e = t.touches && t.touches[0] || t.changedTouches && t.changedTouches[0]; return !(!e || -1 !== e.identifier || null != e.radiusX && 1 !== e.radiusX || null != e.radiusY && 1 !== e.radiusY) } const zO = new K("cdk-input-modality-detector-options"), UO = { ignoreKeys: [18, 17, 224, 91, 16] }, os = Vc({ passive: !0, capture: !0 }); let GO = (() => { class t { constructor(n, r, i, o) { this._platform = n, this._mostRecentTarget = null, this._modality = new bO(null), this._lastTouchMs = 0, this._onKeydown = s => { this._options?.ignoreKeys?.some(a => a === s.keyCode) || (this._modality.next("keyboard"), this._mostRecentTarget = va(s)) }, this._onMousedown = s => { Date.now() - this._lastTouchMs < 650 || (this._modality.next(zw(s) ? "keyboard" : "mouse"), this._mostRecentTarget = va(s)) }, this._onTouchstart = s => { Uw(s) ? this._modality.next("keyboard") : (this._lastTouchMs = Date.now(), this._modality.next("touch"), this._mostRecentTarget = va(s)) }, this._options = { ...UO, ...o }, this.modalityDetected = this._modality.pipe(Nw(1)), this.modalityChanged = this.modalityDetected.pipe(function EO(t, e = Vr) { return t = t ?? CO, Wt((n, r) => { let i, o = !0; n.subscribe(et(r, s => { const a = e(s); (o || !t(i, a)) && (o = !1, i = a, r.next(s)) })) }) }()), n.isBrowser && r.runOutsideAngular(() => { i.addEventListener("keydown", this._onKeydown, os), i.addEventListener("mousedown", this._onMousedown, os), i.addEventListener("touchstart", this._onTouchstart, os) }) } get mostRecentModality() { return this._modality.value } ngOnDestroy() { this._modality.complete(), this._platform.isBrowser && (document.removeEventListener("keydown", this._onKeydown, os), document.removeEventListener("mousedown", this._onMousedown, os), document.removeEventListener("touchstart", this._onTouchstart, os)) } } return t.\u0275fac = function (n) { return new (n || t)(B(gi), B(Xe), B(Gt), B(zO, 8)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); const WO = new K("cdk-focus-monitor-default-options"), zc = Vc({ passive: !0, capture: !0 }); let ZO = (() => { class t { constructor(n, r, i, o, s) { this._ngZone = n, this._platform = r, this._inputModalityDetector = i, this._origin = null, this._windowFocused = !1, this._originFromTouchInteraction = !1, this._elementInfo = new Map, this._monitoredElementCount = 0, this._rootNodeFocusListenerCount = new Map, this._windowFocusListener = () => { this._windowFocused = !0, this._windowFocusTimeoutId = window.setTimeout(() => this._windowFocused = !1) }, this._stopInputModalityDetector = new Qt, this._rootNodeFocusAndBlurListener = a => { for (let c = va(a); c; c = c.parentElement)"focus" === a.type ? this._onFocus(a, c) : this._onBlur(a, c) }, this._document = o, this._detectionMode = s?.detectionMode || 0 } monitor(n, r = !1) { const i = bi(n); if (!this._platform.isBrowser || 1 !== i.nodeType) return Iw(null); const o = function pO(t) { if (function mO() { if (null == qh) { const t = typeof document < "u" ? document.head : null; qh = !(!t || !t.createShadowRoot && !t.attachShadow) } return qh }()) { const e = t.getRootNode ? t.getRootNode() : null; if (typeof ShadowRoot < "u" && ShadowRoot && e instanceof ShadowRoot) return e } return null }(i) || this._getDocument(), s = this._elementInfo.get(i); if (s) return r && (s.checkChildren = !0), s.subject; const a = { checkChildren: r, subject: new Qt, rootNode: o }; return this._elementInfo.set(i, a), this._registerGlobalListeners(a), a.subject } stopMonitoring(n) { const r = bi(n), i = this._elementInfo.get(r); i && (i.subject.complete(), this._setClasses(r), this._elementInfo.delete(r), this._removeGlobalListeners(i)) } focusVia(n, r, i) { const o = bi(n); o === this._getDocument().activeElement ? this._getClosestElementsInfo(o).forEach(([a, l]) => this._originChanged(a, r, l)) : (this._setOrigin(r), "function" == typeof o.focus && o.focus(i)) } ngOnDestroy() { this._elementInfo.forEach((n, r) => this.stopMonitoring(r)) } _getDocument() { return this._document || document } _getWindow() { return this._getDocument().defaultView || window } _getFocusOrigin(n) { return this._origin ? this._originFromTouchInteraction ? this._shouldBeAttributedToTouch(n) ? "touch" : "program" : this._origin : this._windowFocused && this._lastFocusOrigin ? this._lastFocusOrigin : n && this._isLastInteractionFromInputLabel(n) ? "mouse" : "program" } _shouldBeAttributedToTouch(n) { return 1 === this._detectionMode || !!n?.contains(this._inputModalityDetector._mostRecentTarget) } _setClasses(n, r) { n.classList.toggle("cdk-focused", !!r), n.classList.toggle("cdk-touch-focused", "touch" === r), n.classList.toggle("cdk-keyboard-focused", "keyboard" === r), n.classList.toggle("cdk-mouse-focused", "mouse" === r), n.classList.toggle("cdk-program-focused", "program" === r) } _setOrigin(n, r = !1) { this._ngZone.runOutsideAngular(() => { this._origin = n, this._originFromTouchInteraction = "touch" === n && r, 0 === this._detectionMode && (clearTimeout(this._originTimeoutId), this._originTimeoutId = setTimeout(() => this._origin = null, this._originFromTouchInteraction ? 650 : 1)) }) } _onFocus(n, r) { const i = this._elementInfo.get(r), o = va(n); !i || !i.checkChildren && r !== o || this._originChanged(r, this._getFocusOrigin(o), i) } _onBlur(n, r) { const i = this._elementInfo.get(r); !i || i.checkChildren && n.relatedTarget instanceof Node && r.contains(n.relatedTarget) || (this._setClasses(r), this._emitOrigin(i, null)) } _emitOrigin(n, r) { n.subject.observers.length && this._ngZone.run(() => n.subject.next(r)) } _registerGlobalListeners(n) { if (!this._platform.isBrowser) return; const r = n.rootNode, i = this._rootNodeFocusListenerCount.get(r) || 0; i || this._ngZone.runOutsideAngular(() => { r.addEventListener("focus", this._rootNodeFocusAndBlurListener, zc), r.addEventListener("blur", this._rootNodeFocusAndBlurListener, zc) }), this._rootNodeFocusListenerCount.set(r, i + 1), 1 == ++this._monitoredElementCount && (this._ngZone.runOutsideAngular(() => { this._getWindow().addEventListener("focus", this._windowFocusListener) }), this._inputModalityDetector.modalityDetected.pipe(wa(this._stopInputModalityDetector)).subscribe(o => { this._setOrigin(o, !0) })) } _removeGlobalListeners(n) { const r = n.rootNode; if (this._rootNodeFocusListenerCount.has(r)) { const i = this._rootNodeFocusListenerCount.get(r); i > 1 ? this._rootNodeFocusListenerCount.set(r, i - 1) : (r.removeEventListener("focus", this._rootNodeFocusAndBlurListener, zc), r.removeEventListener("blur", this._rootNodeFocusAndBlurListener, zc), this._rootNodeFocusListenerCount.delete(r)) } --this._monitoredElementCount || (this._getWindow().removeEventListener("focus", this._windowFocusListener), this._stopInputModalityDetector.next(), clearTimeout(this._windowFocusTimeoutId), clearTimeout(this._originTimeoutId)) } _originChanged(n, r, i) { this._setClasses(n, r), this._emitOrigin(i, r), this._lastFocusOrigin = r } _getClosestElementsInfo(n) { const r = []; return this._elementInfo.forEach((i, o) => { (o === n || i.checkChildren && o.contains(n)) && r.push([o, i]) }), r } _isLastInteractionFromInputLabel(n) { const { _mostRecentTarget: r, mostRecentModality: i } = this._inputModalityDetector; if ("mouse" !== i || !r || r === n || "INPUT" !== n.nodeName && "TEXTAREA" !== n.nodeName || n.disabled) return !1; const o = n.labels; if (o) for (let s = 0; s < o.length; s++)if (o[s].contains(r)) return !0; return !1 } } return t.\u0275fac = function (n) { return new (n || t)(B(Xe), B(gi), B(GO), B(Gt, 8), B(WO, 8)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); const qw = "cdk-high-contrast-black-on-white", Ww = "cdk-high-contrast-white-on-black", Zh = "cdk-high-contrast-active"; let KO = (() => { class t { constructor(n, r) { this._platform = n, this._document = r, this._breakpointSubscription = yl(RO).observe("(forced-colors: active)").subscribe(() => { this._hasCheckedHighContrastMode && (this._hasCheckedHighContrastMode = !1, this._applyBodyHighContrastModeCssClasses()) }) } getHighContrastMode() { if (!this._platform.isBrowser) return 0; const n = this._document.createElement("div"); n.style.backgroundColor = "rgb(1,2,3)", n.style.position = "absolute", this._document.body.appendChild(n); const r = this._document.defaultView || window, i = r && r.getComputedStyle ? r.getComputedStyle(n) : null, o = (i && i.backgroundColor || "").replace(/ /g, ""); switch (n.remove(), o) { case "rgb(0,0,0)": return 2; case "rgb(255,255,255)": return 1 }return 0 } ngOnDestroy() { this._breakpointSubscription.unsubscribe() } _applyBodyHighContrastModeCssClasses() { if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) { const n = this._document.body.classList; n.remove(Zh, qw, Ww), this._hasCheckedHighContrastMode = !0; const r = this.getHighContrastMode(); 1 === r ? n.add(Zh, qw) : 2 === r && n.add(Zh, Ww) } } } return t.\u0275fac = function (n) { return new (n || t)(B(gi), B(Gt)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); const QO = new K("cdk-dir-doc", { providedIn: "root", factory: function YO() { return yl(Gt) } }), XO = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i; let eR = (() => { class t { constructor(n) { if (this.value = "ltr", this.change = new Ye, n) { const i = n.documentElement ? n.documentElement.dir : null; this.value = function JO(t) { const e = t?.toLowerCase() || ""; return "auto" === e && typeof navigator < "u" && navigator?.language ? XO.test(navigator.language) ? "rtl" : "ltr" : "rtl" === e ? "rtl" : "ltr" }((n.body ? n.body.dir : null) || i || "ltr") } } ngOnDestroy() { this.change.complete() } } return t.\u0275fac = function (n) { return new (n || t)(B(QO, 8)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(), Zw = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Ot({ type: t }), t.\u0275inj = At({}), t })(); const nR = new K("mat-sanity-checks", { providedIn: "root", factory: function tR() { return !0 } }); let Zi = (() => { class t { constructor(n, r, i) { this._sanityChecks = r, this._document = i, this._hasDoneGlobalChecks = !1, n._applyBodyHighContrastModeCssClasses(), this._hasDoneGlobalChecks || (this._hasDoneGlobalChecks = !0) } _checkIsEnabled(n) { return !function gO() { return typeof __karma__ < "u" && !!__karma__ || typeof jasmine < "u" && !!jasmine || typeof jest < "u" && !!jest || typeof Mocha < "u" && !!Mocha }() && ("boolean" == typeof this._sanityChecks ? this._sanityChecks : !!this._sanityChecks[n]) } } return t.\u0275fac = function (n) { return new (n || t)(B(KO), B(nR, 8), B(Gt)) }, t.\u0275mod = Ot({ type: t }), t.\u0275inj = At({ imports: [Zw, Zw] }), t })(); function rR(t) { return class extends t { constructor(...e) { super(...e), this._disabled = !1 } get disabled() { return this._disabled } set disabled(e) { this._disabled = Wi(e) } } } function Yw(t, e) { return class extends t { constructor(...n) { super(...n), this.defaultColor = e, this.color = e } get color() { return this._color } set color(n) { const r = n || this.defaultColor; r !== this._color && (this._color && this._elementRef.nativeElement.classList.remove(`mat-${this._color}`), r && this._elementRef.nativeElement.classList.add(`mat-${r}`), this._color = r) } } } function iR(t) { return class extends t { constructor(...e) { super(...e), this._disableRipple = !1 } get disableRipple() { return this._disableRipple } set disableRipple(e) { this._disableRipple = Wi(e) } } } function oR(t) { return class extends t { constructor(...e) { super(...e), this.errorState = !1 } updateErrorState() { const e = this.errorState, o = (this.errorStateMatcher || this._defaultErrorStateMatcher).isErrorState(this.ngControl ? this.ngControl.control : null, this._parentFormGroup || this._parentForm); o !== e && (this.errorState = o, this.stateChanges.next()) } } } let Xw = (() => { class t { isErrorState(n, r) { return !!(n && n.invalid && (n.touched || r && r.submitted)) } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); class aR { constructor(e, n, r, i = !1) { this._renderer = e, this.element = n, this.config = r, this._animationForciblyDisabledThroughCss = i, this.state = 3 } fadeOut() { this._renderer.fadeOutRipple(this) } } const Jw = { enterDuration: 225, exitDuration: 150 }, Kh = Vc({ passive: !0 }), eD = ["mousedown", "touchstart"], tD = ["mouseup", "mouseleave", "touchend", "touchcancel"]; class cR { constructor(e, n, r, i) { this._target = e, this._ngZone = n, this._isPointerDown = !1, this._activeRipples = new Map, this._pointerUpEventsRegistered = !1, i.isBrowser && (this._containerElement = bi(r)) } fadeInRipple(e, n, r = {}) { const i = this._containerRect = this._containerRect || this._containerElement.getBoundingClientRect(), o = { ...Jw, ...r.animation }; r.centered && (e = i.left + i.width / 2, n = i.top + i.height / 2); const s = r.radius || function uR(t, e, n) { const r = Math.max(Math.abs(t - n.left), Math.abs(t - n.right)), i = Math.max(Math.abs(e - n.top), Math.abs(e - n.bottom)); return Math.sqrt(r * r + i * i) }(e, n, i), a = e - i.left, l = n - i.top, c = o.enterDuration, u = document.createElement("div"); u.classList.add("mat-ripple-element"), u.style.left = a - s + "px", u.style.top = l - s + "px", u.style.height = 2 * s + "px", u.style.width = 2 * s + "px", null != r.color && (u.style.backgroundColor = r.color), u.style.transitionDuration = `${c}ms`, this._containerElement.appendChild(u); const d = window.getComputedStyle(u), h = d.transitionDuration, m = "none" === d.transitionProperty || "0s" === h || "0s, 0s" === h, b = new aR(this, u, r, m); u.style.transform = "scale3d(1, 1, 1)", b.state = 0, r.persistent || (this._mostRecentTransientRipple = b); let w = null; return !m && (c || o.exitDuration) && this._ngZone.runOutsideAngular(() => { const C = () => this._finishRippleTransition(b), I = () => this._destroyRipple(b); u.addEventListener("transitionend", C), u.addEventListener("transitioncancel", I), w = { onTransitionEnd: C, onTransitionCancel: I } }), this._activeRipples.set(b, w), (m || !c) && this._finishRippleTransition(b), b } fadeOutRipple(e) { if (2 === e.state || 3 === e.state) return; const n = e.element, r = { ...Jw, ...e.config.animation }; n.style.transitionDuration = `${r.exitDuration}ms`, n.style.opacity = "0", e.state = 2, (e._animationForciblyDisabledThroughCss || !r.exitDuration) && this._finishRippleTransition(e) } fadeOutAll() { this._getActiveRipples().forEach(e => e.fadeOut()) } fadeOutAllNonPersistent() { this._getActiveRipples().forEach(e => { e.config.persistent || e.fadeOut() }) } setupTriggerEvents(e) { const n = bi(e); !n || n === this._triggerElement || (this._removeTriggerEvents(), this._triggerElement = n, this._registerEvents(eD)) } handleEvent(e) { "mousedown" === e.type ? this._onMousedown(e) : "touchstart" === e.type ? this._onTouchStart(e) : this._onPointerUp(), this._pointerUpEventsRegistered || (this._registerEvents(tD), this._pointerUpEventsRegistered = !0) } _finishRippleTransition(e) { 0 === e.state ? this._startFadeOutTransition(e) : 2 === e.state && this._destroyRipple(e) } _startFadeOutTransition(e) { const n = e === this._mostRecentTransientRipple, { persistent: r } = e.config; e.state = 1, !r && (!n || !this._isPointerDown) && e.fadeOut() } _destroyRipple(e) { const n = this._activeRipples.get(e) ?? null; this._activeRipples.delete(e), this._activeRipples.size || (this._containerRect = null), e === this._mostRecentTransientRipple && (this._mostRecentTransientRipple = null), e.state = 3, null !== n && (e.element.removeEventListener("transitionend", n.onTransitionEnd), e.element.removeEventListener("transitioncancel", n.onTransitionCancel)), e.element.remove() } _onMousedown(e) { const n = zw(e), r = this._lastTouchStartEvent && Date.now() < this._lastTouchStartEvent + 800; !this._target.rippleDisabled && !n && !r && (this._isPointerDown = !0, this.fadeInRipple(e.clientX, e.clientY, this._target.rippleConfig)) } _onTouchStart(e) { if (!this._target.rippleDisabled && !Uw(e)) { this._lastTouchStartEvent = Date.now(), this._isPointerDown = !0; const n = e.changedTouches; for (let r = 0; r < n.length; r++)this.fadeInRipple(n[r].clientX, n[r].clientY, this._target.rippleConfig) } } _onPointerUp() { !this._isPointerDown || (this._isPointerDown = !1, this._getActiveRipples().forEach(e => { !e.config.persistent && (1 === e.state || e.config.terminateOnPointerUp && 0 === e.state) && e.fadeOut() })) } _registerEvents(e) { this._ngZone.runOutsideAngular(() => { e.forEach(n => { this._triggerElement.addEventListener(n, this, Kh) }) }) } _getActiveRipples() { return Array.from(this._activeRipples.keys()) } _removeTriggerEvents() { this._triggerElement && (eD.forEach(e => { this._triggerElement.removeEventListener(e, this, Kh) }), this._pointerUpEventsRegistered && tD.forEach(e => { this._triggerElement.removeEventListener(e, this, Kh) })) } } const dR = new K("mat-ripple-global-options"); let nD = (() => { class t { constructor(n, r, i, o, s) { this._elementRef = n, this._animationMode = s, this.radius = 0, this._disabled = !1, this._isInitialized = !1, this._globalOptions = o || {}, this._rippleRenderer = new cR(this, r, n, i) } get disabled() { return this._disabled } set disabled(n) { n && this.fadeOutAllNonPersistent(), this._disabled = n, this._setupTriggerEventsIfEnabled() } get trigger() { return this._trigger || this._elementRef.nativeElement } set trigger(n) { this._trigger = n, this._setupTriggerEventsIfEnabled() } ngOnInit() { this._isInitialized = !0, this._setupTriggerEventsIfEnabled() } ngOnDestroy() { this._rippleRenderer._removeTriggerEvents() } fadeOutAll() { this._rippleRenderer.fadeOutAll() } fadeOutAllNonPersistent() { this._rippleRenderer.fadeOutAllNonPersistent() } get rippleConfig() { return { centered: this.centered, radius: this.radius, color: this.color, animation: { ...this._globalOptions.animation, ..."NoopAnimations" === this._animationMode ? { enterDuration: 0, exitDuration: 0 } : {}, ...this.animation }, terminateOnPointerUp: this._globalOptions.terminateOnPointerUp } } get rippleDisabled() { return this.disabled || !!this._globalOptions.disabled } _setupTriggerEventsIfEnabled() { !this.disabled && this._isInitialized && this._rippleRenderer.setupTriggerEvents(this.trigger) } launch(n, r = 0, i) { return "number" == typeof n ? this._rippleRenderer.fadeInRipple(n, r, { ...this.rippleConfig, ...i }) : this._rippleRenderer.fadeInRipple(0, 0, { ...this.rippleConfig, ...n }) } } return t.\u0275fac = function (n) { return new (n || t)(T(Tt), T(Xe), T(gi), T(dR, 8), T(sa, 8)) }, t.\u0275dir = te({ type: t, selectors: [["", "mat-ripple", ""], ["", "matRipple", ""]], hostAttrs: [1, "mat-ripple"], hostVars: 2, hostBindings: function (n, r) { 2 & n && En("mat-ripple-unbounded", r.unbounded) }, inputs: { color: ["matRippleColor", "color"], unbounded: ["matRippleUnbounded", "unbounded"], centered: ["matRippleCentered", "centered"], radius: ["matRippleRadius", "radius"], animation: ["matRippleAnimation", "animation"], disabled: ["matRippleDisabled", "disabled"], trigger: ["matRippleTrigger", "trigger"] }, exportAs: ["matRipple"] }), t })(), fR = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Ot({ type: t }), t.\u0275inj = At({ imports: [Zi, Zi] }), t })(); const hR = ["mat-button", ""], mR = ["*"], gR = ["mat-button", "mat-flat-button", "mat-icon-button", "mat-raised-button", "mat-stroked-button", "mat-mini-fab", "mat-fab"], bR = Yw(rR(iR(class { constructor(t) { this._elementRef = t } }))); let yR = (() => { class t extends bR { constructor(n, r, i) { super(n), this._focusMonitor = r, this._animationMode = i, this.isRoundButton = this._hasHostAttributes("mat-fab", "mat-mini-fab"), this.isIconButton = this._hasHostAttributes("mat-icon-button"); for (const o of gR) this._hasHostAttributes(o) && this._getHostElement().classList.add(o); n.nativeElement.classList.add("mat-button-base"), this.isRoundButton && (this.color = "accent") } ngAfterViewInit() { this._focusMonitor.monitor(this._elementRef, !0) } ngOnDestroy() { this._focusMonitor.stopMonitoring(this._elementRef) } focus(n, r) { n ? this._focusMonitor.focusVia(this._getHostElement(), n, r) : this._getHostElement().focus(r) } _getHostElement() { return this._elementRef.nativeElement } _isRippleDisabled() { return this.disableRipple || this.disabled } _hasHostAttributes(...n) { return n.some(r => this._getHostElement().hasAttribute(r)) } } return t.\u0275fac = function (n) { return new (n || t)(T(Tt), T(ZO), T(sa, 8)) }, t.\u0275cmp = uo({ type: t, selectors: [["button", "mat-button", ""], ["button", "mat-raised-button", ""], ["button", "mat-icon-button", ""], ["button", "mat-fab", ""], ["button", "mat-mini-fab", ""], ["button", "mat-stroked-button", ""], ["button", "mat-flat-button", ""]], viewQuery: function (n, r) { if (1 & n && ji(nD, 5), 2 & n) { let i; rn(i = on()) && (r.ripple = i.first) } }, hostAttrs: [1, "mat-focus-indicator"], hostVars: 5, hostBindings: function (n, r) { 2 & n && (mn("disabled", r.disabled || null), En("_mat-animation-noopable", "NoopAnimations" === r._animationMode)("mat-button-disabled", r.disabled)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", color: "color" }, exportAs: ["matButton"], features: [je], attrs: hR, ngContentSelectors: mR, decls: 4, vars: 5, consts: [[1, "mat-button-wrapper"], ["matRipple", "", 1, "mat-button-ripple", 3, "matRippleDisabled", "matRippleCentered", "matRippleTrigger"], [1, "mat-button-focus-overlay"]], template: function (n, r) { 1 & n && (_f(), Fe(0, "span", 0), Cr(1), Le(), ur(2, "span", 1)(3, "span", 2)), 2 & n && (Qe(2), En("mat-button-ripple-round", r.isRoundButton || r.isIconButton), Ae("matRippleDisabled", r._isRippleDisabled())("matRippleCentered", r.isIconButton)("matRippleTrigger", r._getHostElement())) }, dependencies: [nD], styles: [".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0);display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0);display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0);display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}.mat-fab._mat-animation-noopable{transition:none !important;animation:none !important}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0);display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:inline-flex;justify-content:center;align-items:center;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}"], encapsulation: 2, changeDetection: 0 }), t })(), _R = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Ot({ type: t }), t.\u0275inj = At({ imports: [fR, Zi, Zi] }), t })(), rD = (() => { class t { create(n) { return typeof MutationObserver > "u" ? null : new MutationObserver(n) } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(), vR = (() => { class t { constructor(n) { this._mutationObserverFactory = n, this._observedElements = new Map } ngOnDestroy() { this._observedElements.forEach((n, r) => this._cleanupObserver(r)) } observe(n) { const r = bi(n); return new qe(i => { const s = this._observeElement(r).subscribe(i); return () => { s.unsubscribe(), this._unobserveElement(r) } }) } _observeElement(n) { if (this._observedElements.has(n)) this._observedElements.get(n).count++; else { const r = new Qt, i = this._mutationObserverFactory.create(o => r.next(o)); i && i.observe(n, { characterData: !0, childList: !0, subtree: !0 }), this._observedElements.set(n, { observer: i, stream: r, count: 1 }) } return this._observedElements.get(n).stream } _unobserveElement(n) { this._observedElements.has(n) && (this._observedElements.get(n).count--, this._observedElements.get(n).count || this._cleanupObserver(n)) } _cleanupObserver(n) { if (this._observedElements.has(n)) { const { observer: r, stream: i } = this._observedElements.get(n); r && r.disconnect(), i.complete(), this._observedElements.delete(n) } } } return t.\u0275fac = function (n) { return new (n || t)(B(rD)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(), wR = (() => { class t { constructor(n, r, i) { this._contentObserver = n, this._elementRef = r, this._ngZone = i, this.event = new Ye, this._disabled = !1, this._currentSubscription = null } get disabled() { return this._disabled } set disabled(n) { this._disabled = Wi(n), this._disabled ? this._unsubscribe() : this._subscribe() } get debounce() { return this._debounce } set debounce(n) { this._debounce = function MO(t, e = 0) { return function TO(t) { return !isNaN(parseFloat(t)) && !isNaN(Number(t)) }(t) ? Number(t) : e }(n), this._subscribe() } ngAfterContentInit() { !this._currentSubscription && !this.disabled && this._subscribe() } ngOnDestroy() { this._unsubscribe() } _subscribe() { this._unsubscribe(); const n = this._contentObserver.observe(this._elementRef); this._ngZone.runOutsideAngular(() => { this._currentSubscription = (this.debounce ? n.pipe(jc(this.debounce)) : n).subscribe(this.event) }) } _unsubscribe() { this._currentSubscription?.unsubscribe() } } return t.\u0275fac = function (n) { return new (n || t)(T(vR), T(Tt), T(Xe)) }, t.\u0275dir = te({ type: t, selectors: [["", "cdkObserveContent", ""]], inputs: { disabled: ["cdkObserveContentDisabled", "disabled"], debounce: "debounce" }, outputs: { event: "cdkObserveContent" }, exportAs: ["cdkObserveContent"] }), t })(), DR = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Ot({ type: t }), t.\u0275inj = At({ providers: [rD] }), t })(); const ER = ["addListener", "removeListener"], CR = ["addEventListener", "removeEventListener"], MR = ["on", "off"]; function Ca(t, e, n, r) { if (Ce(n) && (r = n, n = void 0), r) return Ca(t, e, n).pipe(Mh(r)); const [i, o] = function kR(t) { return Ce(t.addEventListener) && Ce(t.removeEventListener) }(t) ? CR.map(s => a => t[s](e, a, n)) : function TR(t) { return Ce(t.addListener) && Ce(t.removeListener) }(t) ? ER.map(iD(t, e)) : function xR(t) { return Ce(t.on) && Ce(t.off) }(t) ? MR.map(iD(t, e)) : []; if (!i && we(t)) return st(s => Ca(s, e, n))(Ue(t)); if (!i) throw new TypeError("Invalid event target"); return new qe(s => { const a = (...l) => s.next(1 < l.length ? l : l[0]); return i(a), () => o(a) }) } function iD(t, e) { return n => r => t[n](e, r) } class oD { } const Xr = "*"; function sD(t, e) { return { type: 7, name: t, definitions: e, options: {} } } function Uc(t, e = null) { return { type: 4, styles: e, timings: t } } function aD(t, e = null) { return { type: 2, steps: t, options: e } } function yi(t) { return { type: 6, styles: t, offset: null } } function Qh(t, e, n) { return { type: 0, name: t, styles: e, options: n } } function Gc(t, e, n = null) { return { type: 1, expr: t, animation: e, options: n } } function lD(t) { Promise.resolve(null).then(t) } class Ma { constructor(e = 0, n = 0) { this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this._position = 0, this.parentPlayer = null, this.totalTime = e + n } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = []) } onStart(e) { this._onStartFns.push(e) } onDone(e) { this._onDoneFns.push(e) } onDestroy(e) { this._onDestroyFns.push(e) } hasStarted() { return this._started } init() { } play() { this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0 } triggerMicrotask() { lD(() => this._onFinish()) } _onStart() { this._onStartFns.forEach(e => e()), this._onStartFns = [] } pause() { } restart() { } finish() { this._onFinish() } destroy() { this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = []) } reset() { this._started = !1 } setPosition(e) { this._position = this.totalTime ? e * this.totalTime : 1 } getPosition() { return this.totalTime ? this._position / this.totalTime : 1 } triggerCallback(e) { const n = "start" == e ? this._onStartFns : this._onDoneFns; n.forEach(r => r()), n.length = 0 } } class cD { constructor(e) { this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = e; let n = 0, r = 0, i = 0; const o = this.players.length; 0 == o ? lD(() => this._onFinish()) : this.players.forEach(s => { s.onDone(() => { ++n == o && this._onFinish() }), s.onDestroy(() => { ++r == o && this._onDestroy() }), s.onStart(() => { ++i == o && this._onStart() }) }), this.totalTime = this.players.reduce((s, a) => Math.max(s, a.totalTime), 0) } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = []) } init() { this.players.forEach(e => e.init()) } onStart(e) { this._onStartFns.push(e) } _onStart() { this.hasStarted() || (this._started = !0, this._onStartFns.forEach(e => e()), this._onStartFns = []) } onDone(e) { this._onDoneFns.push(e) } onDestroy(e) { this._onDestroyFns.push(e) } hasStarted() { return this._started } play() { this.parentPlayer || this.init(), this._onStart(), this.players.forEach(e => e.play()) } pause() { this.players.forEach(e => e.pause()) } restart() { this.players.forEach(e => e.restart()) } finish() { this._onFinish(), this.players.forEach(e => e.finish()) } destroy() { this._onDestroy() } _onDestroy() { this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(e => e.destroy()), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = []) } reset() { this.players.forEach(e => e.reset()), this._destroyed = !1, this._finished = !1, this._started = !1 } setPosition(e) { const n = e * this.totalTime; this.players.forEach(r => { const i = r.totalTime ? Math.min(1, n / r.totalTime) : 1; r.setPosition(i) }) } getPosition() { const e = this.players.reduce((n, r) => null === n || r.totalTime > n.totalTime ? r : n, null); return null != e ? e.getPosition() : 0 } beforeDestroy() { this.players.forEach(e => { e.beforeDestroy && e.beforeDestroy() }) } triggerCallback(e) { const n = "start" == e ? this._onStartFns : this._onDoneFns; n.forEach(r => r()), n.length = 0 } } const SR = ["connectionContainer"], IR = ["inputContainer"], FR = ["label"]; function NR(t, e) { 1 & t && (Gs(0), Fe(1, "div", 14), ur(2, "div", 15)(3, "div", 16)(4, "div", 17), Le(), Fe(5, "div", 18), ur(6, "div", 15)(7, "div", 16)(8, "div", 17), Le(), qs()) } function OR(t, e) { if (1 & t) { const n = Ws(); Fe(0, "div", 19), St("cdkObserveContent", function () { return Ii(n), Fi(lt().updateOutlineGap()) }), Cr(1, 1), Le() } 2 & t && Ae("cdkObserveContentDisabled", "outline" != lt().appearance) } function RR(t, e) { if (1 & t && (Gs(0), Cr(1, 2), Fe(2, "span"), Kt(3), Le(), qs()), 2 & t) { const n = lt(2); Qe(3), Wo(n._control.placeholder) } } function PR(t, e) { 1 & t && Cr(0, 3, ["*ngSwitchCase", "true"]) } function LR(t, e) { 1 & t && (Fe(0, "span", 23), Kt(1, " *"), Le()) } function VR(t, e) { if (1 & t) { const n = Ws(); Fe(0, "label", 20, 21), St("cdkObserveContent", function () { return Ii(n), Fi(lt().updateOutlineGap()) }), it(2, RR, 4, 1, "ng-container", 12), it(3, PR, 1, 0, "ng-content", 12), it(4, LR, 2, 0, "span", 22), Le() } if (2 & t) { const n = lt(); En("mat-empty", n._control.empty && !n._shouldAlwaysFloat())("mat-form-field-empty", n._control.empty && !n._shouldAlwaysFloat())("mat-accent", "accent" == n.color)("mat-warn", "warn" == n.color), Ae("cdkObserveContentDisabled", "outline" != n.appearance)("id", n._labelId)("ngSwitch", n._hasLabel()), mn("for", n._control.id)("aria-owns", n._control.id), Qe(2), Ae("ngSwitchCase", !1), Qe(1), Ae("ngSwitchCase", !0), Qe(1), Ae("ngIf", !n.hideRequiredMarker && n._control.required && !n._control.disabled) } } function BR(t, e) { 1 & t && (Fe(0, "div", 24), Cr(1, 4), Le()) } function HR(t, e) { if (1 & t && (Fe(0, "div", 25), ur(1, "span", 26), Le()), 2 & t) { const n = lt(); Qe(1), En("mat-accent", "accent" == n.color)("mat-warn", "warn" == n.color) } } function jR(t, e) { 1 & t && (Fe(0, "div"), Cr(1, 5), Le()), 2 & t && Ae("@transitionMessages", lt()._subscriptAnimationState) } function $R(t, e) { if (1 & t && (Fe(0, "div", 30), Kt(1), Le()), 2 & t) { const n = lt(2); Ae("id", n._hintLabelId), Qe(1), Wo(n.hintLabel) } } function zR(t, e) { if (1 & t && (Fe(0, "div", 27), it(1, $R, 2, 2, "div", 28), Cr(2, 6), ur(3, "div", 29), Cr(4, 7), Le()), 2 & t) { const n = lt(); Ae("@transitionMessages", n._subscriptAnimationState), Qe(1), Ae("ngIf", n.hintLabel) } } const UR = ["*", [["", "matPrefix", ""]], [["mat-placeholder"]], [["mat-label"]], [["", "matSuffix", ""]], [["mat-error"]], [["mat-hint", 3, "align", "end"]], [["mat-hint", "align", "end"]]], GR = ["*", "[matPrefix]", "mat-placeholder", "mat-label", "[matSuffix]", "mat-error", "mat-hint:not([align='end'])", "mat-hint[align='end']"]; let qR = 0; const uD = new K("MatError"); let WR = (() => { class t { constructor(n, r) { this.id = "mat-error-" + qR++, n || r.nativeElement.setAttribute("aria-live", "polite") } } return t.\u0275fac = function (n) { return new (n || t)(function hl(t) { return function CC(t, e) { if ("class" === e) return t.classes; if ("style" === e) return t.styles; const n = t.attrs; if (n) { const r = n.length; let i = 0; for (; i < r;) { const o = n[i]; if (yp(o)) break; if (0 === o) i += 2; else if ("number" == typeof o) for (i++; i < r && "string" == typeof n[i];)i++; else { if (o === e) return n[i + 1]; i += 2 } } } return null }(Ht(), t) }("aria-live"), T(Tt)) }, t.\u0275dir = te({ type: t, selectors: [["mat-error"]], hostAttrs: ["aria-atomic", "true", 1, "mat-error"], hostVars: 1, hostBindings: function (n, r) { 2 & n && mn("id", r.id) }, inputs: { id: "id" }, features: [ct([{ provide: uD, useExisting: t }])] }), t })(); const ZR = { transitionMessages: sD("transitionMessages", [Qh("enter", yi({ opacity: 1, transform: "translateY(0%)" })), Gc("void => enter", [yi({ opacity: 0, transform: "translateY(-5px)" }), Uc("300ms cubic-bezier(0.55, 0, 0.55, 0.2)")])]) }; let Xh = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275dir = te({ type: t }), t })(); const KR = new K("MatHint"); let Jh = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275dir = te({ type: t, selectors: [["mat-label"]] }), t })(), QR = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275dir = te({ type: t, selectors: [["mat-placeholder"]] }), t })(); const YR = new K("MatPrefix"), XR = new K("MatSuffix"); let dD = 0; const eP = Yw(class { constructor(t) { this._elementRef = t } }, "primary"), tP = new K("MAT_FORM_FIELD_DEFAULT_OPTIONS"), hD = new K("MatFormField"); let nP = (() => { class t extends eP { constructor(n, r, i, o, s, a, l) { super(n), this._changeDetectorRef = r, this._dir = i, this._defaults = o, this._platform = s, this._ngZone = a, this._outlineGapCalculationNeededImmediately = !1, this._outlineGapCalculationNeededOnStable = !1, this._destroyed = new Qt, this._hideRequiredMarker = !1, this._showAlwaysAnimate = !1, this._subscriptAnimationState = "", this._hintLabel = "", this._hintLabelId = "mat-hint-" + dD++, this._labelId = "mat-form-field-label-" + dD++, this.floatLabel = this._getDefaultFloatLabelState(), this._animationsEnabled = "NoopAnimations" !== l, this.appearance = o?.appearance || "legacy", o && (this._hideRequiredMarker = Boolean(o.hideRequiredMarker), o.color && (this.color = this.defaultColor = o.color)) } get appearance() { return this._appearance } set appearance(n) { const r = this._appearance; this._appearance = n || this._defaults?.appearance || "legacy", "outline" === this._appearance && r !== n && (this._outlineGapCalculationNeededOnStable = !0) } get hideRequiredMarker() { return this._hideRequiredMarker } set hideRequiredMarker(n) { this._hideRequiredMarker = Wi(n) } _shouldAlwaysFloat() { return "always" === this.floatLabel && !this._showAlwaysAnimate } _canLabelFloat() { return "never" !== this.floatLabel } get hintLabel() { return this._hintLabel } set hintLabel(n) { this._hintLabel = n, this._processHints() } get floatLabel() { return "legacy" !== this.appearance && "never" === this._floatLabel ? "auto" : this._floatLabel } set floatLabel(n) { n !== this._floatLabel && (this._floatLabel = n || this._getDefaultFloatLabelState(), this._changeDetectorRef.markForCheck()) } get _control() { return this._explicitFormFieldControl || this._controlNonStatic || this._controlStatic } set _control(n) { this._explicitFormFieldControl = n } getLabelId() { return this._hasFloatingLabel() ? this._labelId : null } getConnectedOverlayOrigin() { return this._connectionContainerRef || this._elementRef } ngAfterContentInit() { this._validateControlChild(); const n = this._control; n.controlType && this._elementRef.nativeElement.classList.add(`mat-form-field-type-${n.controlType}`), n.stateChanges.pipe($c(null)).subscribe(() => { this._validatePlaceholders(), this._syncDescribedByIds(), this._changeDetectorRef.markForCheck() }), n.ngControl && n.ngControl.valueChanges && n.ngControl.valueChanges.pipe(wa(this._destroyed)).subscribe(() => this._changeDetectorRef.markForCheck()), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.pipe(wa(this._destroyed)).subscribe(() => { this._outlineGapCalculationNeededOnStable && this.updateOutlineGap() }) }), me(this._prefixChildren.changes, this._suffixChildren.changes).subscribe(() => { this._outlineGapCalculationNeededOnStable = !0, this._changeDetectorRef.markForCheck() }), this._hintChildren.changes.pipe($c(null)).subscribe(() => { this._processHints(), this._changeDetectorRef.markForCheck() }), this._errorChildren.changes.pipe($c(null)).subscribe(() => { this._syncDescribedByIds(), this._changeDetectorRef.markForCheck() }), this._dir && this._dir.change.pipe(wa(this._destroyed)).subscribe(() => { "function" == typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => this.updateOutlineGap()) }) : this.updateOutlineGap() }) } ngAfterContentChecked() { this._validateControlChild(), this._outlineGapCalculationNeededImmediately && this.updateOutlineGap() } ngAfterViewInit() { this._subscriptAnimationState = "enter", this._changeDetectorRef.detectChanges() } ngOnDestroy() { this._destroyed.next(), this._destroyed.complete() } _shouldForward(n) { const r = this._control ? this._control.ngControl : null; return r && r[n] } _hasPlaceholder() { return !!(this._control && this._control.placeholder || this._placeholderChild) } _hasLabel() { return !(!this._labelChildNonStatic && !this._labelChildStatic) } _shouldLabelFloat() { return this._canLabelFloat() && (this._control && this._control.shouldLabelFloat || this._shouldAlwaysFloat()) } _hideControlPlaceholder() { return "legacy" === this.appearance && !this._hasLabel() || this._hasLabel() && !this._shouldLabelFloat() } _hasFloatingLabel() { return this._hasLabel() || "legacy" === this.appearance && this._hasPlaceholder() } _getDisplayedMessages() { return this._errorChildren && this._errorChildren.length > 0 && this._control.errorState ? "error" : "hint" } _animateAndLockLabel() { this._hasFloatingLabel() && this._canLabelFloat() && (this._animationsEnabled && this._label && (this._showAlwaysAnimate = !0, Ca(this._label.nativeElement, "transitionend").pipe(We(1)).subscribe(() => { this._showAlwaysAnimate = !1 })), this.floatLabel = "always", this._changeDetectorRef.markForCheck()) } _validatePlaceholders() { } _processHints() { this._validateHints(), this._syncDescribedByIds() } _validateHints() { } _getDefaultFloatLabelState() { return this._defaults && this._defaults.floatLabel || "auto" } _syncDescribedByIds() { if (this._control) { let n = []; if (this._control.userAriaDescribedBy && "string" == typeof this._control.userAriaDescribedBy && n.push(...this._control.userAriaDescribedBy.split(" ")), "hint" === this._getDisplayedMessages()) { const r = this._hintChildren ? this._hintChildren.find(o => "start" === o.align) : null, i = this._hintChildren ? this._hintChildren.find(o => "end" === o.align) : null; r ? n.push(r.id) : this._hintLabel && n.push(this._hintLabelId), i && n.push(i.id) } else this._errorChildren && n.push(...this._errorChildren.map(r => r.id)); this._control.setDescribedByIds(n) } } _validateControlChild() { } updateOutlineGap() { const n = this._label ? this._label.nativeElement : null, r = this._connectionContainerRef.nativeElement, i = ".mat-form-field-outline-start", o = ".mat-form-field-outline-gap"; if ("outline" !== this.appearance || !this._platform.isBrowser) return; if (!n || !n.children.length || !n.textContent.trim()) { const u = r.querySelectorAll(`${i}, ${o}`); for (let d = 0; d < u.length; d++)u[d].style.width = "0"; return } if (!this._isAttachedToDOM()) return void (this._outlineGapCalculationNeededImmediately = !0); let s = 0, a = 0; const l = r.querySelectorAll(i), c = r.querySelectorAll(o); if (this._label && this._label.nativeElement.children.length) { const u = r.getBoundingClientRect(); if (0 === u.width && 0 === u.height) return this._outlineGapCalculationNeededOnStable = !0, void (this._outlineGapCalculationNeededImmediately = !1); const d = this._getStartEnd(u), f = n.children, h = this._getStartEnd(f[0].getBoundingClientRect()); let m = 0; for (let b = 0; b < f.length; b++)m += f[b].offsetWidth; s = Math.abs(h - d) - 5, a = m > 0 ? .75 * m + 10 : 0 } for (let u = 0; u < l.length; u++)l[u].style.width = `${s}px`; for (let u = 0; u < c.length; u++)c[u].style.width = `${a}px`; this._outlineGapCalculationNeededOnStable = this._outlineGapCalculationNeededImmediately = !1 } _getStartEnd(n) { return this._dir && "rtl" === this._dir.value ? n.right : n.left } _isAttachedToDOM() { const n = this._elementRef.nativeElement; if (n.getRootNode) { const r = n.getRootNode(); return r && r !== n } return document.documentElement.contains(n) } } return t.\u0275fac = function (n) { return new (n || t)(T(Tt), T(ts), T(eR, 8), T(tP, 8), T(gi), T(Xe), T(sa, 8)) }, t.\u0275cmp = uo({ type: t, selectors: [["mat-form-field"]], contentQueries: function (n, r, i) { if (1 & n && (kr(i, Xh, 5), kr(i, Xh, 7), kr(i, Jh, 5), kr(i, Jh, 7), kr(i, QR, 5), kr(i, uD, 5), kr(i, KR, 5), kr(i, YR, 5), kr(i, XR, 5)), 2 & n) { let o; rn(o = on()) && (r._controlNonStatic = o.first), rn(o = on()) && (r._controlStatic = o.first), rn(o = on()) && (r._labelChildNonStatic = o.first), rn(o = on()) && (r._labelChildStatic = o.first), rn(o = on()) && (r._placeholderChild = o.first), rn(o = on()) && (r._errorChildren = o), rn(o = on()) && (r._hintChildren = o), rn(o = on()) && (r._prefixChildren = o), rn(o = on()) && (r._suffixChildren = o) } }, viewQuery: function (n, r) { if (1 & n && (ji(SR, 7), ji(IR, 5), ji(FR, 5)), 2 & n) { let i; rn(i = on()) && (r._connectionContainerRef = i.first), rn(i = on()) && (r._inputContainerRef = i.first), rn(i = on()) && (r._label = i.first) } }, hostAttrs: [1, "mat-form-field"], hostVars: 40, hostBindings: function (n, r) { 2 & n && En("mat-form-field-appearance-standard", "standard" == r.appearance)("mat-form-field-appearance-fill", "fill" == r.appearance)("mat-form-field-appearance-outline", "outline" == r.appearance)("mat-form-field-appearance-legacy", "legacy" == r.appearance)("mat-form-field-invalid", r._control.errorState)("mat-form-field-can-float", r._canLabelFloat())("mat-form-field-should-float", r._shouldLabelFloat())("mat-form-field-has-label", r._hasFloatingLabel())("mat-form-field-hide-placeholder", r._hideControlPlaceholder())("mat-form-field-disabled", r._control.disabled)("mat-form-field-autofilled", r._control.autofilled)("mat-focused", r._control.focused)("ng-untouched", r._shouldForward("untouched"))("ng-touched", r._shouldForward("touched"))("ng-pristine", r._shouldForward("pristine"))("ng-dirty", r._shouldForward("dirty"))("ng-valid", r._shouldForward("valid"))("ng-invalid", r._shouldForward("invalid"))("ng-pending", r._shouldForward("pending"))("_mat-animation-noopable", !r._animationsEnabled) }, inputs: { color: "color", appearance: "appearance", hideRequiredMarker: "hideRequiredMarker", hintLabel: "hintLabel", floatLabel: "floatLabel" }, exportAs: ["matFormField"], features: [ct([{ provide: hD, useExisting: t }]), je], ngContentSelectors: GR, decls: 15, vars: 8, consts: [[1, "mat-form-field-wrapper"], [1, "mat-form-field-flex", 3, "click"], ["connectionContainer", ""], [4, "ngIf"], ["class", "mat-form-field-prefix", 3, "cdkObserveContentDisabled", "cdkObserveContent", 4, "ngIf"], [1, "mat-form-field-infix"], ["inputContainer", ""], [1, "mat-form-field-label-wrapper"], ["class", "mat-form-field-label", 3, "cdkObserveContentDisabled", "id", "mat-empty", "mat-form-field-empty", "mat-accent", "mat-warn", "ngSwitch", "cdkObserveContent", 4, "ngIf"], ["class", "mat-form-field-suffix", 4, "ngIf"], ["class", "mat-form-field-underline", 4, "ngIf"], [1, "mat-form-field-subscript-wrapper", 3, "ngSwitch"], [4, "ngSwitchCase"], ["class", "mat-form-field-hint-wrapper", 4, "ngSwitchCase"], [1, "mat-form-field-outline"], [1, "mat-form-field-outline-start"], [1, "mat-form-field-outline-gap"], [1, "mat-form-field-outline-end"], [1, "mat-form-field-outline", "mat-form-field-outline-thick"], [1, "mat-form-field-prefix", 3, "cdkObserveContentDisabled", "cdkObserveContent"], [1, "mat-form-field-label", 3, "cdkObserveContentDisabled", "id", "ngSwitch", "cdkObserveContent"], ["label", ""], ["class", "mat-placeholder-required mat-form-field-required-marker", "aria-hidden", "true", 4, "ngIf"], ["aria-hidden", "true", 1, "mat-placeholder-required", "mat-form-field-required-marker"], [1, "mat-form-field-suffix"], [1, "mat-form-field-underline"], [1, "mat-form-field-ripple"], [1, "mat-form-field-hint-wrapper"], ["class", "mat-hint", 3, "id", 4, "ngIf"], [1, "mat-form-field-hint-spacer"], [1, "mat-hint", 3, "id"]], template: function (n, r) { 1 & n && (_f(UR), Fe(0, "div", 0)(1, "div", 1, 2), St("click", function (o) { return r._control.onContainerClick && r._control.onContainerClick(o) }), it(3, NR, 9, 0, "ng-container", 3), it(4, OR, 2, 1, "div", 4), Fe(5, "div", 5, 6), Cr(7), Fe(8, "span", 7), it(9, VR, 5, 16, "label", 8), Le()(), it(10, BR, 2, 0, "div", 9), Le(), it(11, HR, 2, 4, "div", 10), Fe(12, "div", 11), it(13, jR, 2, 1, "div", 12), it(14, zR, 5, 2, "div", 13), Le()()), 2 & n && (Qe(3), Ae("ngIf", "outline" == r.appearance), Qe(1), Ae("ngIf", r._prefixChildren.length), Qe(5), Ae("ngIf", r._hasFloatingLabel()), Qe(1), Ae("ngIf", r._suffixChildren.length), Qe(1), Ae("ngIf", "outline" != r.appearance), Qe(1), Ae("ngSwitch", r._getDisplayedMessages()), Qe(1), Ae("ngSwitchCase", "error"), Qe(1), Ae("ngSwitchCase", "hint")) }, dependencies: [pc, gc, q0, wR], styles: [".mat-form-field{display:inline-block;position:relative;text-align:left}[dir=rtl] .mat-form-field{text-align:right}.mat-form-field-wrapper{position:relative}.mat-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-form-field-prefix,.mat-form-field-suffix{white-space:nowrap;flex:none;position:relative}.mat-form-field-infix{display:block;position:relative;flex:auto;min-width:0;width:180px}.cdk-high-contrast-active .mat-form-field-infix{border-image:linear-gradient(transparent, transparent)}.mat-form-field-label-wrapper{position:absolute;left:0;box-sizing:content-box;width:100%;height:100%;overflow:hidden;pointer-events:none}[dir=rtl] .mat-form-field-label-wrapper{left:auto;right:0}.mat-form-field-label{position:absolute;left:0;font:inherit;pointer-events:none;width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;transform-origin:0 0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),width 400ms cubic-bezier(0.25, 0.8, 0.25, 1);display:none}[dir=rtl] .mat-form-field-label{transform-origin:100% 0;left:auto;right:0}.cdk-high-contrast-active .mat-form-field-disabled .mat-form-field-label{color:GrayText}.mat-form-field-empty.mat-form-field-label,.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label{display:block}.mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:block;transition:none}.mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-form-field-can-float .mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:block}.mat-form-field-label:not(.mat-form-field-empty){transition:none}.mat-form-field-underline{position:absolute;width:100%;pointer-events:none;transform:scale3d(1, 1.0001, 1)}.mat-form-field-ripple{position:absolute;left:0;width:100%;transform-origin:50%;transform:scaleX(0.5);opacity:0;transition:background-color 300ms cubic-bezier(0.55, 0, 0.55, 0.2)}.mat-form-field.mat-focused .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple{opacity:1;transform:none;transition:transform 300ms cubic-bezier(0.25, 0.8, 0.25, 1),opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 300ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-subscript-wrapper{position:absolute;box-sizing:border-box;width:100%;overflow:hidden}.mat-form-field-subscript-wrapper .mat-icon,.mat-form-field-label-wrapper .mat-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.mat-form-field-hint-wrapper{display:flex}.mat-form-field-hint-spacer{flex:1 0 1em}.mat-error{display:block}.mat-form-field-control-wrapper{position:relative}.mat-form-field-hint-end{order:1}.mat-form-field._mat-animation-noopable .mat-form-field-label,.mat-form-field._mat-animation-noopable .mat-form-field-ripple{transition:none}", '.mat-form-field-appearance-fill .mat-form-field-flex{border-radius:4px 4px 0 0;padding:.75em .75em 0 .75em}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-flex{outline:solid 1px}.cdk-high-contrast-active .mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-flex{outline-color:GrayText}.cdk-high-contrast-active .mat-form-field-appearance-fill.mat-focused .mat-form-field-flex{outline:dashed 3px}.mat-form-field-appearance-fill .mat-form-field-underline::before{content:"";display:block;position:absolute;bottom:0;height:1px;width:100%}.mat-form-field-appearance-fill .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-ripple{height:0}.mat-form-field-appearance-fill:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-fill._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}.mat-form-field-appearance-fill .mat-form-field-subscript-wrapper{padding:0 1em}', '.mat-input-element{font:inherit;background:rgba(0,0,0,0);color:currentColor;border:none;outline:none;padding:0;margin:0;width:100%;max-width:100%;vertical-align:bottom;text-align:inherit;box-sizing:content-box}.mat-input-element:-moz-ui-invalid{box-shadow:none}.mat-input-element,.mat-input-element::-webkit-search-cancel-button,.mat-input-element::-webkit-search-decoration,.mat-input-element::-webkit-search-results-button,.mat-input-element::-webkit-search-results-decoration{-webkit-appearance:none}.mat-input-element::-webkit-contacts-auto-fill-button,.mat-input-element::-webkit-caps-lock-indicator,.mat-input-element:not([type=password])::-webkit-credentials-auto-fill-button{visibility:hidden}.mat-input-element[type=date],.mat-input-element[type=datetime],.mat-input-element[type=datetime-local],.mat-input-element[type=month],.mat-input-element[type=week],.mat-input-element[type=time]{line-height:1}.mat-input-element[type=date]::after,.mat-input-element[type=datetime]::after,.mat-input-element[type=datetime-local]::after,.mat-input-element[type=month]::after,.mat-input-element[type=week]::after,.mat-input-element[type=time]::after{content:" ";white-space:pre;width:1px}.mat-input-element::-webkit-inner-spin-button,.mat-input-element::-webkit-calendar-picker-indicator,.mat-input-element::-webkit-clear-button{font-size:.75em}.mat-input-element::placeholder{-webkit-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-moz-placeholder{-webkit-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-webkit-input-placeholder{-webkit-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element:-ms-input-placeholder{-webkit-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-hide-placeholder .mat-input-element::placeholder{color:rgba(0,0,0,0) !important;-webkit-text-fill-color:rgba(0,0,0,0);transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element::placeholder{opacity:0}.mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{color:rgba(0,0,0,0) !important;-webkit-text-fill-color:rgba(0,0,0,0);transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{opacity:0}.mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{color:rgba(0,0,0,0) !important;-webkit-text-fill-color:rgba(0,0,0,0);transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{opacity:0}.mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{color:rgba(0,0,0,0) !important;-webkit-text-fill-color:rgba(0,0,0,0);transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{opacity:0}._mat-animation-noopable .mat-input-element::placeholder{transition:none}._mat-animation-noopable .mat-input-element::-moz-placeholder{transition:none}._mat-animation-noopable .mat-input-element::-webkit-input-placeholder{transition:none}._mat-animation-noopable .mat-input-element:-ms-input-placeholder{transition:none}textarea.mat-input-element{resize:vertical;overflow:auto}textarea.mat-input-element.cdk-textarea-autosize{resize:none}textarea.mat-input-element{padding:2px 0;margin:-2px 0}select.mat-input-element{-moz-appearance:none;-webkit-appearance:none;position:relative;background-color:rgba(0,0,0,0);display:inline-flex;box-sizing:border-box;padding-top:1em;top:-1em;margin-bottom:-1em}select.mat-input-element::-moz-focus-inner{border:0}select.mat-input-element:not(:disabled){cursor:pointer}.mat-form-field-type-mat-native-select .mat-form-field-infix::after{content:"";width:0;height:0;border-left:5px solid rgba(0,0,0,0);border-right:5px solid rgba(0,0,0,0);border-top:5px solid;position:absolute;top:50%;right:0;margin-top:-2.5px;pointer-events:none}[dir=rtl] .mat-form-field-type-mat-native-select .mat-form-field-infix::after{right:auto;left:0}.mat-form-field-type-mat-native-select .mat-input-element{padding-right:15px}[dir=rtl] .mat-form-field-type-mat-native-select .mat-input-element{padding-right:0;padding-left:15px}.mat-form-field-type-mat-native-select .mat-form-field-label-wrapper{max-width:calc(100% - 10px)}.mat-form-field-type-mat-native-select.mat-form-field-appearance-outline .mat-form-field-infix::after{margin-top:-5px}.mat-form-field-type-mat-native-select.mat-form-field-appearance-fill .mat-form-field-infix::after{margin-top:-10px}', ".mat-form-field-appearance-legacy .mat-form-field-label{transform:perspective(100px)}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon{width:1em}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button{font:inherit;vertical-align:baseline}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button .mat-icon{font-size:inherit}.mat-form-field-appearance-legacy .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-legacy .mat-form-field-ripple{top:0;height:2px;overflow:hidden}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:rgba(0,0,0,0)}.cdk-high-contrast-active .mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px;border-top-color:GrayText}.mat-form-field-appearance-legacy.mat-form-field-invalid:not(.mat-focused) .mat-form-field-ripple{height:1px}", ".mat-form-field-appearance-outline .mat-form-field-wrapper{margin:.25em 0}.mat-form-field-appearance-outline .mat-form-field-flex{padding:0 .75em 0 .75em;margin-top:-0.25em;position:relative}.mat-form-field-appearance-outline .mat-form-field-prefix,.mat-form-field-appearance-outline .mat-form-field-suffix{top:.25em}.mat-form-field-appearance-outline .mat-form-field-outline{display:flex;position:absolute;top:.25em;left:0;right:0;bottom:0;pointer-events:none}.mat-form-field-appearance-outline .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-end{border:1px solid currentColor;min-width:5px}.mat-form-field-appearance-outline .mat-form-field-outline-start{border-radius:5px 0 0 5px;border-right-style:none}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-start{border-right-style:solid;border-left-style:none;border-radius:0 5px 5px 0}.mat-form-field-appearance-outline .mat-form-field-outline-end{border-radius:0 5px 5px 0;border-left-style:none;flex-grow:1}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-end{border-left-style:solid;border-right-style:none;border-radius:5px 0 0 5px}.mat-form-field-appearance-outline .mat-form-field-outline-gap{border-radius:.000001px;border:1px solid currentColor;border-left-style:none;border-right-style:none}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-outline-gap{border-top-color:rgba(0,0,0,0)}.mat-form-field-appearance-outline .mat-form-field-outline-thick{opacity:0}.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-end,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-gap{border-width:2px}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline{opacity:0;transition:opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline-thick{opacity:1}.cdk-high-contrast-active .mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick{border:3px dashed}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline{opacity:0;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{padding:0 1em}.cdk-high-contrast-active .mat-form-field-appearance-outline.mat-form-field-disabled .mat-form-field-outline{color:GrayText}.mat-form-field-appearance-outline._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-start,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-end,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-gap{transition:none}", ".mat-form-field-appearance-standard .mat-form-field-flex{padding-top:.75em}.mat-form-field-appearance-standard .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-standard .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:rgba(0,0,0,0)}.cdk-high-contrast-active .mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-standard:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-standard._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}"], encapsulation: 2, data: { animation: [ZR.transitionMessages] }, changeDetection: 0 }), t })(), em = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Ot({ type: t }), t.\u0275inj = At({ imports: [bc, Zi, DR, Zi] }), t })(); const mD = Vc({ passive: !0 }); let rP = (() => { class t { constructor(n, r) { this._platform = n, this._ngZone = r, this._monitoredElements = new Map } monitor(n) { if (!this._platform.isBrowser) return xt; const r = bi(n), i = this._monitoredElements.get(r); if (i) return i.subject; const o = new Qt, s = "cdk-text-field-autofilled", a = l => { "cdk-text-field-autofill-start" !== l.animationName || r.classList.contains(s) ? "cdk-text-field-autofill-end" === l.animationName && r.classList.contains(s) && (r.classList.remove(s), this._ngZone.run(() => o.next({ target: l.target, isAutofilled: !1 }))) : (r.classList.add(s), this._ngZone.run(() => o.next({ target: l.target, isAutofilled: !0 }))) }; return this._ngZone.runOutsideAngular(() => { r.addEventListener("animationstart", a, mD), r.classList.add("cdk-text-field-autofill-monitored") }), this._monitoredElements.set(r, { subject: o, unlisten: () => { r.removeEventListener("animationstart", a, mD) } }), o } stopMonitoring(n) { const r = bi(n), i = this._monitoredElements.get(r); i && (i.unlisten(), i.subject.complete(), r.classList.remove("cdk-text-field-autofill-monitored"), r.classList.remove("cdk-text-field-autofilled"), this._monitoredElements.delete(r)) } ngOnDestroy() { this._monitoredElements.forEach((n, r) => this.stopMonitoring(r)) } } return t.\u0275fac = function (n) { return new (n || t)(B(gi), B(Xe)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(), pD = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Ot({ type: t }), t.\u0275inj = At({}), t })(); const iP = new K("MAT_INPUT_VALUE_ACCESSOR"), oP = ["button", "checkbox", "file", "hidden", "image", "radio", "range", "reset", "submit"]; let sP = 0; const aP = oR(class { constructor(t, e, n, r) { this._defaultErrorStateMatcher = t, this._parentForm = e, this._parentFormGroup = n, this.ngControl = r, this.stateChanges = new Qt } }); let lP = (() => { class t extends aP { constructor(n, r, i, o, s, a, l, c, u, d) { super(a, o, s, i), this._elementRef = n, this._platform = r, this._autofillMonitor = c, this._formField = d, this._uid = "mat-input-" + sP++, this.focused = !1, this.stateChanges = new Qt, this.controlType = "mat-input", this.autofilled = !1, this._disabled = !1, this._type = "text", this._readonly = !1, this._neverEmptyInputTypes = ["date", "datetime", "datetime-local", "month", "time", "week"].filter(m => Sw().has(m)), this._iOSKeyupListener = m => { const b = m.target; !b.value && 0 === b.selectionStart && 0 === b.selectionEnd && (b.setSelectionRange(1, 1), b.setSelectionRange(0, 0)) }; const f = this._elementRef.nativeElement, h = f.nodeName.toLowerCase(); this._inputValueAccessor = l || f, this._previousNativeValue = this.value, this.id = this.id, r.IOS && u.runOutsideAngular(() => { n.nativeElement.addEventListener("keyup", this._iOSKeyupListener) }), this._isServer = !this._platform.isBrowser, this._isNativeSelect = "select" === h, this._isTextarea = "textarea" === h, this._isInFormField = !!d, this._isNativeSelect && (this.controlType = f.multiple ? "mat-native-select-multiple" : "mat-native-select") } get disabled() { return this.ngControl && null !== this.ngControl.disabled ? this.ngControl.disabled : this._disabled } set disabled(n) { this._disabled = Wi(n), this.focused && (this.focused = !1, this.stateChanges.next()) } get id() { return this._id } set id(n) { this._id = n || this._uid } get required() { return this._required ?? this.ngControl?.control?.hasValidator(Mc.required) ?? !1 } set required(n) { this._required = Wi(n) } get type() { return this._type } set type(n) { this._type = n || "text", this._validateType(), !this._isTextarea && Sw().has(this._type) && (this._elementRef.nativeElement.type = this._type) } get value() { return this._inputValueAccessor.value } set value(n) { n !== this.value && (this._inputValueAccessor.value = n, this.stateChanges.next()) } get readonly() { return this._readonly } set readonly(n) { this._readonly = Wi(n) } ngAfterViewInit() { this._platform.isBrowser && this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(n => { this.autofilled = n.isAutofilled, this.stateChanges.next() }) } ngOnChanges() { this.stateChanges.next() } ngOnDestroy() { this.stateChanges.complete(), this._platform.isBrowser && this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement), this._platform.IOS && this._elementRef.nativeElement.removeEventListener("keyup", this._iOSKeyupListener) } ngDoCheck() { this.ngControl && this.updateErrorState(), this._dirtyCheckNativeValue(), this._dirtyCheckPlaceholder() } focus(n) { this._elementRef.nativeElement.focus(n) } _focusChanged(n) { n !== this.focused && (this.focused = n, this.stateChanges.next()) } _onInput() { } _dirtyCheckPlaceholder() { const n = this._formField, r = n && "legacy" === n.appearance && !n._hasLabel?.() ? null : this.placeholder; if (r !== this._previousPlaceholder) { const i = this._elementRef.nativeElement; this._previousPlaceholder = r, r ? i.setAttribute("placeholder", r) : i.removeAttribute("placeholder") } } _dirtyCheckNativeValue() { const n = this._elementRef.nativeElement.value; this._previousNativeValue !== n && (this._previousNativeValue = n, this.stateChanges.next()) } _validateType() { oP.indexOf(this._type) } _isNeverEmpty() { return this._neverEmptyInputTypes.indexOf(this._type) > -1 } _isBadInput() { let n = this._elementRef.nativeElement.validity; return n && n.badInput } get empty() { return !(this._isNeverEmpty() || this._elementRef.nativeElement.value || this._isBadInput() || this.autofilled) } get shouldLabelFloat() { if (this._isNativeSelect) { const n = this._elementRef.nativeElement, r = n.options[0]; return this.focused || n.multiple || !this.empty || !!(n.selectedIndex > -1 && r && r.label) } return this.focused || !this.empty } setDescribedByIds(n) { n.length ? this._elementRef.nativeElement.setAttribute("aria-describedby", n.join(" ")) : this._elementRef.nativeElement.removeAttribute("aria-describedby") } onContainerClick() { this.focused || this.focus() } _isInlineSelect() { const n = this._elementRef.nativeElement; return this._isNativeSelect && (n.multiple || n.size > 1) } } return t.\u0275fac = function (n) { return new (n || t)(T(Tt), T(gi), T(Fr, 10), T(Lc, 8), T(ya, 8), T(Xw), T(iP, 10), T(rP), T(Xe), T(hD, 8)) }, t.\u0275dir = te({ type: t, selectors: [["input", "matInput", ""], ["textarea", "matInput", ""], ["select", "matNativeControl", ""], ["input", "matNativeControl", ""], ["textarea", "matNativeControl", ""]], hostAttrs: [1, "mat-input-element", "mat-form-field-autofill-control"], hostVars: 12, hostBindings: function (n, r) { 1 & n && St("focus", function () { return r._focusChanged(!0) })("blur", function () { return r._focusChanged(!1) })("input", function () { return r._onInput() }), 2 & n && (Ef("disabled", r.disabled)("required", r.required), mn("id", r.id)("data-placeholder", r.placeholder)("name", r.name || null)("readonly", r.readonly && !r._isNativeSelect || null)("aria-invalid", r.empty && r.required ? null : r.errorState)("aria-required", r.required), En("mat-input-server", r._isServer)("mat-native-select-inline", r._isInlineSelect())) }, inputs: { disabled: "disabled", id: "id", placeholder: "placeholder", name: "name", required: "required", type: "type", errorStateMatcher: "errorStateMatcher", userAriaDescribedBy: ["aria-describedby", "userAriaDescribedBy"], value: "value", readonly: "readonly" }, exportAs: ["matInput"], features: [ct([{ provide: Xh, useExisting: t }]), je, yr] }), t })(), cP = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Ot({ type: t }), t.\u0275inj = At({ providers: [Xw], imports: [pD, em, Zi, pD, em] }), t })(); class uP { constructor(e, n) { this.open = e, this.close = n || e } isManual() { return "manual" === this.open || "manual" === this.close } } const dP = { hover: ["mouseover", "mouseout"], focus: ["focusin", "focusout"] }; const ht = typeof window < "u" && window || {}; var qc = (() => { return (t = qc || (qc = {})).isBs3 = "bs3", t.isBs4 = "bs4", t.isBs5 = "bs5", qc; var t })(); let On; function tm() { if (typeof ht.document > "u") return "bs4"; const t = ht.document.createElement("span"); t.innerText = "testing bs version", t.classList.add("d-none"), t.classList.add("pl-1"), ht.document.head.appendChild(t); const e = t.getBoundingClientRect(), n = ht.getComputedStyle(t).paddingLeft; return !e || e && 0 !== e.top ? (ht.document.head.removeChild(t), "bs3") : n && parseFloat(n) ? (ht.document.head.removeChild(t), "bs4") : (ht.document.head.removeChild(t), "bs5") } function Wc() { return typeof ht > "u" || (typeof ht.__theme > "u" ? (On || (On = tm()), "bs3" === On) : "bs3" === ht.__theme) } function bD() { return !Wc() && (On || (On = tm()), "bs4" === On) } function Ta() { return { isBs3: Wc(), isBs4: bD(), isBs5: !Wc() && !bD() && (On || (On = tm()), "bs5" === On) } } class yD { static reflow(e) { } static getStyles(e) { let n = e.ownerDocument.defaultView; return (!n || !n.opener) && (n = ht), n.getComputedStyle(e) } static stackOverflowConfig() { const e = function gP() { const t = Ta(), e = Object.keys(t).find(n => t[n]); return qc[e] }(); return { crossorigin: "bs3" !== e ? "anonymous" : void 0, integrity: "bs5" === e ? "sha384-KyZXEAg3QhqLMpG8r+8fhAXLRk2vvoC2f3B09zVXn8CA5QIVfZOJ3BCsw2P0p/We" : "bs4" === e ? "sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" : void 0, cdnLink: "bs5" === e ? "https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/css/bootstrap.min.css" : "bs4" === e ? "https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" : "https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" } } } typeof console > "u" || console; const xa = { schedule(t) { let e = requestAnimationFrame, n = cancelAnimationFrame; const { delegate: r } = xa; r && (e = r.requestAnimationFrame, n = r.cancelAnimationFrame); const i = e(o => { n = void 0, t(o) }); return new ln(() => n?.(i)) }, requestAnimationFrame(...t) { const { delegate: e } = xa; return (e?.requestAnimationFrame || requestAnimationFrame)(...t) }, cancelAnimationFrame(...t) { const { delegate: e } = xa; return (e?.cancelAnimationFrame || cancelAnimationFrame)(...t) }, delegate: void 0 }, vP = new class _P extends Lw { flush(e) { this._active = !0; const n = this._scheduled; this._scheduled = void 0; const { actions: r } = this; let i; e = e || r.shift(); do { if (i = e.execute(e.state, e.delay)) break } while ((e = r[0]) && e.id === n && r.shift()); if (this._active = !1, i) { for (; (e = r[0]) && e.id === n && r.shift();)e.unsubscribe(); throw i } } }(class yP extends Pw { constructor(e, n) { super(e, n), this.scheduler = e, this.work = n } requestAsyncId(e, n, r = 0) { return null !== r && r > 0 ? super.requestAsyncId(e, n, r) : (e.actions.push(this), e._scheduled || (e._scheduled = xa.requestAnimationFrame(() => e.flush(void 0)))) } recycleAsyncId(e, n, r = 0) { if (null != r && r > 0 || null == r && this.delay > 0) return super.recycleAsyncId(e, n, r); e.actions.some(i => i.id === n) || (xa.cancelAnimationFrame(n), e._scheduled = void 0) } }); var Zc = (() => { return (t = Zc || (Zc = {})).top = "top", t.bottom = "bottom", t.left = "left", t.right = "right", t.auto = "auto", t.end = "right", t.start = "left", t["top left"] = "top left", t["top right"] = "top right", t["right top"] = "right top", t["right bottom"] = "right bottom", t["bottom right"] = "bottom right", t["bottom left"] = "bottom left", t["left bottom"] = "left bottom", t["left top"] = "left top", t["top start"] = "top left", t["top end"] = "top right", t["end top"] = "right top", t["end bottom"] = "right bottom", t["bottom end"] = "bottom right", t["bottom start"] = "bottom left", t["start bottom"] = "start bottom", t["start top"] = "left top", Zc; var t })(), ka = (() => { return (t = ka || (ka = {})).top = "top", t.bottom = "bottom", t.left = "start", t.right = "end", t.auto = "auto", t.end = "end", t.start = "start", t["top left"] = "top start", t["top right"] = "top end", t["right top"] = "end top", t["right bottom"] = "end bottom", t["bottom right"] = "bottom end", t["bottom left"] = "bottom start", t["left bottom"] = "start bottom", t["left top"] = "start top", t["top start"] = "top start", t["top end"] = "top end", t["end top"] = "end top", t["end bottom"] = "end bottom", t["bottom end"] = "bottom end", t["bottom start"] = "bottom start", t["start bottom"] = "start bottom", t["start top"] = "start top", ka; var t })(); function Ki(t, e) { if (1 !== t.nodeType) return []; const r = t.ownerDocument.defaultView?.getComputedStyle(t, null); return e ? r && r[e] : r } function nm(t) { if (!t) return document.documentElement; let r, n = t?.offsetParent; for (; null === n && t.nextElementSibling && r !== t.nextElementSibling;)r = t.nextElementSibling, n = r.offsetParent; const i = n && n.nodeName; return i && "BODY" !== i && "HTML" !== i ? n && -1 !== ["TH", "TD", "TABLE"].indexOf(n.nodeName) && "static" === Ki(n, "position") ? nm(n) : n : r ? r.ownerDocument.documentElement : document.documentElement } function rm(t) { return null !== t.parentNode ? rm(t.parentNode) : t } function Kc(t, e) { if (!(t && t.nodeType && e && e.nodeType)) return document.documentElement; const n = t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_FOLLOWING, r = n ? t : e, i = n ? e : t, o = document.createRange(); o.setStart(r, 0), o.setEnd(i, 0); const s = o.commonAncestorContainer; if (t !== s && e !== s || r.contains(i)) return function wP(t) { const { nodeName: e } = t; return "BODY" !== e && ("HTML" === e || nm(t.firstElementChild) === t) }(s) ? s : nm(s); const a = rm(t); return a.host ? Kc(a.host, e) : Kc(t, rm(e).host) } function vD(t) { if (!t || !t.parentElement) return document.documentElement; let e = t.parentElement; for (; e?.parentElement && "none" === Ki(e, "transform");)e = e.parentElement; return e || document.documentElement } function wD(t, e) { const n = "x" === e ? "Left" : "Top", r = "Left" === n ? "Right" : "Bottom"; return parseFloat(t[`border${n}Width`]) + parseFloat(t[`border${r}Width`]) } function DD(t, e, n, r) { return Math.max(e[`offset${t}`], e[`scroll${t}`], n[`client${t}`], n[`offset${t}`], n[`scroll${t}`], 0) } function ED(t) { const e = t.body, n = t.documentElement; return { height: DD("Height", e, n), width: DD("Width", e, n) } } function Aa(t) { return { ...t, right: (t.left || 0) + t.width, bottom: (t.top || 0) + t.height } } function mt(t) { return "number" == typeof t || "[object Number]" === Object.prototype.toString.call(t) } function CD(t) { const e = t.getBoundingClientRect(); if (!(e && mt(e.top) && mt(e.left) && mt(e.bottom) && mt(e.right))) return e; const n = { left: e.left, top: e.top, width: e.right - e.left, height: e.bottom - e.top }, r = "HTML" === t.nodeName ? ED(t.ownerDocument) : void 0, i = r?.width || t.clientWidth || mt(e.right) && mt(n.left) && e.right - n.left || 0, o = r?.height || t.clientHeight || mt(e.bottom) && mt(n.top) && e.bottom - n.top || 0; let s = t.offsetWidth - i, a = t.offsetHeight - o; if (s || a) { const l = Ki(t); s -= wD(l, "x"), a -= wD(l, "y"), n.width -= s, n.height -= a } return Aa(n) } function im(t) { return "HTML" === t.nodeName ? t : t.parentNode || t.host } function om(t) { if (!t) return document.body; switch (t.nodeName) { case "HTML": case "BODY": return t.ownerDocument.body; case "#document": return t.body }const { overflow: e, overflowX: n, overflowY: r } = Ki(t); return /(auto|scroll|overlay)/.test(String(e) + String(r) + String(n)) ? t : om(im(t)) } function sm(t, e, n = !1) { const r = "HTML" === e.nodeName, i = CD(t), o = CD(e), a = (om(t), Ki(e)), l = parseFloat(a.borderTopWidth), c = parseFloat(a.borderLeftWidth); n && r && (o.top = Math.max(o.top ?? 0, 0), o.left = Math.max(o.left ?? 0, 0)); const u = Aa({ top: (i.top ?? 0) - (o.top ?? 0) - l, left: (i.left ?? 0) - (o.left ?? 0) - c, width: i.width, height: i.height }); if (u.marginTop = 0, u.marginLeft = 0, r) { const d = parseFloat(a.marginTop), f = parseFloat(a.marginLeft); mt(u.top) && (u.top -= l - d), mt(u.bottom) && (u.bottom -= l - d), mt(u.left) && (u.left -= c - f), mt(u.right) && (u.right -= c - f), u.marginTop = d, u.marginLeft = f } return u } function MD(t, e = "top") { const n = "top" === e ? "scrollTop" : "scrollLeft", r = t.nodeName; if ("BODY" === r || "HTML" === r) { const i = t.ownerDocument.documentElement; return (t.ownerDocument.scrollingElement || i)[n] } return t[n] } function TD(t) { const e = t.nodeName; return "BODY" !== e && "HTML" !== e && ("fixed" === Ki(t, "position") || TD(im(t))) } function am(t, e, n = 0, r, i = !1) { let o = { top: 0, left: 0 }; const s = i ? vD(t) : Kc(t, e); if ("viewport" === r) o = function EP(t, e = !1) { const n = t.ownerDocument.documentElement, r = sm(t, n), i = Math.max(n.clientWidth, window.innerWidth || 0), o = Math.max(n.clientHeight, window.innerHeight || 0), s = e ? 0 : MD(n), a = e ? 0 : MD(n, "left"); return Aa({ top: s - Number(r?.top) + Number(r?.marginTop), left: a - Number(r?.left) + Number(r?.marginLeft), width: i, height: o }) }(s, i); else { let a; "scrollParent" === r ? (a = om(im(e)), "BODY" === a.nodeName && (a = t.ownerDocument.documentElement)) : a = "window" === r ? t.ownerDocument.documentElement : r; const l = sm(a, s, i); if (l && "HTML" === a.nodeName && !TD(s)) { const { height: c, width: u } = ED(t.ownerDocument); mt(o.top) && mt(l.top) && mt(l.marginTop) && (o.top += l.top - l.marginTop), mt(o.top) && (o.bottom = Number(c) + Number(l.top)), mt(o.left) && mt(l.left) && mt(l.marginLeft) && (o.left += l.left - l.marginLeft), mt(o.top) && (o.right = Number(u) + Number(l.left)) } else l && (o = l) } return mt(o.left) && (o.left += n), mt(o.top) && (o.top += n), mt(o.right) && (o.right -= n), mt(o.bottom) && (o.bottom -= n), o } function CP({ width: t, height: e }) { return t * e } function xD(t, e, n, r, i = ["top", "bottom", "right", "left"], o = "viewport", s = 0) { if (-1 === t.indexOf("auto")) return t; const a = am(n, r, s, o), l = { top: { width: a?.width ?? 0, height: (e?.top ?? 0) - (a?.top ?? 0) }, right: { width: (a?.right ?? 0) - (e?.right ?? 0), height: a?.height ?? 0 }, bottom: { width: a?.width ?? 0, height: (a?.bottom ?? 0) - (e?.bottom ?? 0) }, left: { width: (e.left ?? 0) - (a?.left ?? 0), height: a?.height ?? 0 } }, c = Object.keys(l).map(h => ({ position: h, ...l[h], area: CP(l[h]) })).sort((h, m) => m.area - h.area); let u = c.filter(({ width: h, height: m }) => h >= n.clientWidth && m >= n.clientHeight); u = u.filter(({ position: h }) => i.some(m => m === h)); const d = u.length > 0 ? u[0].position : c[0].position, f = t.split(" ")[1]; return n.className = n.className.replace(/bs-tooltip-auto/g, `bs-tooltip-${Ta().isBs5 ? ka[d] : d}`), d + (f ? `-${f}` : "") } const Qc = (t, e = 0) => t ? parseFloat(t) : e; function kD(t) { const n = t.ownerDocument.defaultView?.getComputedStyle(t), r = Qc(n?.marginTop) + Qc(n?.marginBottom), i = Qc(n?.marginLeft) + Qc(n?.marginRight); return { width: Number(t.offsetWidth) + i, height: Number(t.offsetHeight) + r } } function AD(t, e, n) { return sm(e, n ? vD(t) : Kc(t, e), n) } function lm(t, e, n) { const r = n.split(" ")[0], i = kD(t), o = { width: i.width, height: i.height }, s = -1 !== ["right", "left"].indexOf(r), a = s ? "top" : "left", l = s ? "left" : "top", c = s ? "height" : "width", u = s ? "width" : "height"; return o[a] = (e[a] ?? 0) + e[c] / 2 - i[c] / 2, o[l] = r === l ? (e[l] ?? 0) - i[u] : e[function TP(t) { const e = { left: "right", right: "left", bottom: "top", top: "bottom" }; return t.replace(/left|right|bottom|top/g, n => e[n]) }(l)] ?? 0, o } function SD(t, e) { return !!t.modifiers[e]?.enabled } const kP = { top: ["top", "top start", "top end"], bottom: ["bottom", "bottom start", "bottom end"], start: ["start", "start top", "start bottom"], end: ["end", "end top", "end bottom"] }; function Yc(t, e) { return !!Ta().isBs5 && kP[e].includes(t) } function ID(t, e, n) { !t || !e || Object.keys(e).forEach(r => { let i = ""; -1 !== ["width", "height", "top", "right", "bottom", "left"].indexOf(r) && function DP(t) { return "" !== t && !isNaN(parseFloat(t)) && isFinite(Number(t)) }(e[r]) && (i = "px"), n ? n.setStyle(t, r, `${String(e[r])}${i}`) : t.style[r] = String(e[r]) + i }) } function IP(t) { let e = t.offsets.target; const n = t.instance.target.querySelector(".arrow"); if (!n) return t; const r = -1 !== ["left", "right"].indexOf(t.placement.split(" ")[0]), i = r ? "height" : "width", o = r ? "Top" : "Left", s = o.toLowerCase(), a = r ? "left" : "top", l = r ? "bottom" : "right", c = kD(n)[i], u = t.placement.split(" ")[1]; (t.offsets.host[l] ?? 0) - c < (e[s] ?? 0) && (e[s] -= (e[s] ?? 0) - ((t.offsets.host[l] ?? 0) - c)), Number(t.offsets.host[s]) + Number(c) > (e[l] ?? 0) && (e[s] += Number(t.offsets.host[s]) + Number(c) - Number(e[l])), e = Aa(e); const d = Ki(t.instance.target), f = parseFloat(d[`margin${o}`]) || 0, h = parseFloat(d[`border${o}Width`]) || 0; let m; if (u) { const w = parseFloat(d.borderRadius) || 0, C = Number(f + h + w); m = s === u ? Number(t.offsets.host[s]) + C : Number(t.offsets.host[s]) + Number(t.offsets.host[i] - C) } else m = Number(t.offsets.host[s]) + Number(t.offsets.host[i] / 2 - c / 2); let b = m - (e[s] ?? 0) - f - h; return b = Math.max(Math.min(e[i] - (c + 5), b), 0), t.offsets.arrow = { [s]: Math.round(b), [a]: "" }, t.instance.arrow = n, t } function FP(t) { if (t.offsets.target = Aa(t.offsets.target), !SD(t.options, "flip")) return t.offsets.target = { ...t.offsets.target, ...lm(t.instance.target, t.offsets.host, t.placement) }, t; const e = am(t.instance.target, t.instance.host, 0, "viewport", !1); let n = t.placement.split(" ")[0], r = t.placement.split(" ")[1] || ""; const a = xD("auto", t.offsets.host, t.instance.target, t.instance.host, t.options.allowedPositions), l = [n, a]; return l.forEach((c, u) => { if (n !== c || l.length === u + 1) return; n = t.placement.split(" ")[0]; const d = "left" === n && Math.floor(t.offsets.target.right ?? 0) > Math.floor(t.offsets.host.left ?? 0) || "right" === n && Math.floor(t.offsets.target.left ?? 0) < Math.floor(t.offsets.host.right ?? 0) || "top" === n && Math.floor(t.offsets.target.bottom ?? 0) > Math.floor(t.offsets.host.top ?? 0) || "bottom" === n && Math.floor(t.offsets.target.top ?? 0) < Math.floor(t.offsets.host.bottom ?? 0), f = Math.floor(t.offsets.target.left ?? 0) < Math.floor(e.left ?? 0), h = Math.floor(t.offsets.target.right ?? 0) > Math.floor(e.right ?? 0), m = Math.floor(t.offsets.target.top ?? 0) < Math.floor(e.top ?? 0), b = Math.floor(t.offsets.target.bottom ?? 0) > Math.floor(e.bottom ?? 0), w = "left" === n && f || "right" === n && h || "top" === n && m || "bottom" === n && b, C = -1 !== ["top", "bottom"].indexOf(n), I = C && "left" === r && f || C && "right" === r && h || !C && "left" === r && m || !C && "right" === r && b; (d || w || I) && ((d || w) && (n = l[u + 1]), I && (r = function xP(t) { return "right" === t ? "left" : "left" === t ? "right" : t }(r)), t.placement = n + (r ? ` ${r}` : ""), t.offsets.target = { ...t.offsets.target, ...lm(t.instance.target, t.offsets.host, t.placement) }) }), t } function OP(t) { if (!SD(t.options, "preventOverflow")) return t; const e = "transform", n = t.instance.target.style, { top: r, left: i, [e]: o } = n; n.top = "", n.left = "", n[e] = ""; const s = am(t.instance.target, t.instance.host, 0, t.options.modifiers.preventOverflow?.boundariesElement || "scrollParent", !1); n.top = r, n.left = i, n[e] = o; const l = { primary(c) { let u = t.offsets.target[c]; return (t.offsets.target[c] ?? 0) < (s[c] ?? 0) && (u = Math.max(t.offsets.target[c] ?? 0, s[c] ?? 0)), { [c]: u } }, secondary(c) { const u = "right" === c, d = u ? "left" : "top"; let h = t.offsets.target[d]; return (t.offsets.target[c] ?? 0) > (s[c] ?? 0) && (h = Math.min(t.offsets.target[d] ?? 0, (s[c] ?? 0) - t.offsets.target[u ? "width" : "height"])), { [d]: h } } }; return ["left", "right", "top", "bottom"].forEach(c => { const u = -1 !== ["left", "top", "start"].indexOf(c) ? l.primary : l.secondary; t.offsets.target = { ...t.offsets.target, ...u(c) } }), t } function RP(t) { const e = t.placement, n = e.split(" ")[0], r = e.split(" ")[1]; if (r) { const { host: i, target: o } = t.offsets, s = -1 !== ["bottom", "top"].indexOf(n), a = s ? "left" : "top", l = s ? "width" : "height", c = { start: { [a]: i[a] }, end: { [a]: (i[a] ?? 0) + i[l] - o[l] } }; t.offsets.target = { ...o, [a]: a === r ? c.start[a] : c.end[a] } } return t } const LP = new class PP { position(e, n) { return this.offset(e, n) } offset(e, n) { return AD(n, e) } positionElements(e, n, r, i, o) { const s = [FP, RP, OP, IP], l = function NP(t, e, n, r) { if (!t || !e) return; const i = AD(t, e); !n.match(/^(auto)*\s*(left|right|top|bottom|start|end)*$/) && !n.match(/^(left|right|top|bottom|start|end)*(?: (left|right|top|bottom|start|end))*$/) && (n = "auto"); const o = !!n.match(/auto/g); let s = n.match(/auto\s(left|right|top|bottom|start|end)/) ? n.split(" ")[1] || "auto" : n; const a = s.match(/^(left|right|top|bottom|start|end)* ?(?!\1)(left|right|top|bottom|start|end)?/); return a && (s = a[1] + (a[2] ? ` ${a[2]}` : "")), -1 !== ["left right", "right left", "top bottom", "bottom top"].indexOf(s) && (s = "auto"), s = xD(s, i, t, e, r ? r.allowedPositions : void 0), { options: r || { modifiers: {} }, instance: { target: t, host: e, arrow: void 0 }, offsets: { target: lm(t, i, s), host: i, arrow: void 0 }, positionFixed: !1, placement: s, placementAuto: o } }(n, e, Zc[r], o); if (l) return s.reduce((c, u) => u(c), l) } }; function VP(t, e, n, r, i, o) { const s = LP.positionElements(t, e, n, r, i); if (!s) return; const a = function MP(t) { return { width: t.offsets.target.width, height: t.offsets.target.height, left: Math.floor(t.offsets.target.left ?? 0), top: Math.round(t.offsets.target.top ?? 0), bottom: Math.round(t.offsets.target.bottom ?? 0), right: Math.floor(t.offsets.target.right ?? 0) } }(s); ID(e, { "will-change": "transform", top: "0px", left: "0px", transform: `translate3d(${a.left}px, ${a.top}px, 0px)` }, o), s.instance.arrow && ID(s.instance.arrow, s.offsets.arrow, o), function SP(t, e) { const n = t.instance.target; let r = n.className; const i = Ta().isBs5 ? ka[t.placement] : t.placement; t.placementAuto && (r = r.replace(/bs-popover-auto/g, `bs-popover-${i}`), r = r.replace(/ms-2|me-2|mb-2|mt-2/g, ""), r = r.replace(/bs-tooltip-auto/g, `bs-tooltip-${i}`), r = r.replace(/\sauto/g, ` ${i}`), -1 !== r.indexOf("popover") && (r = r + " " + function AP(t) { return Ta().isBs5 ? Yc(t, "end") ? "ms-2" : Yc(t, "start") ? "me-2" : Yc(t, "top") ? "mb-2" : Yc(t, "bottom") ? "mt-2" : "" : "" }(i)), -1 !== r.indexOf("popover") && -1 === r.indexOf("popover-auto") && (r += " popover-auto"), -1 !== r.indexOf("tooltip") && -1 === r.indexOf("tooltip-auto") && (r += " tooltip-auto")), r = r.replace(/left|right|top|bottom|end|start/g, `${i.split(" ")[0]}`), e ? e.setAttribute(n, "class", r) : n.className = r }(s, o) } let cm = (() => { class t { constructor(n, r, i) { this.update$$ = new Qt, this.positionElements = new Map, this.isDisabled = !1, Y0(i) && n.runOutsideAngular(() => { this.triggerEvent$ = me(Ca(window, "scroll", { passive: !0 }), Ca(window, "resize", { passive: !0 }), Iw(0, vP), this.update$$), this.triggerEvent$.subscribe(() => { this.isDisabled || this.positionElements.forEach(o => { VP(Xc(o.target), Xc(o.element), o.attachment, o.appendToBody, this.options, r.createRenderer(null, null)) }) }) }) } position(n) { this.addPositionElement(n) } get event$() { return this.triggerEvent$ } disable() { this.isDisabled = !0 } enable() { this.isDisabled = !1 } addPositionElement(n) { this.positionElements.set(Xc(n.element), n) } calcPosition() { this.update$$.next(null) } deletePositionElement(n) { this.positionElements.delete(Xc(n)) } setOptions(n) { this.options = n } } return t.\u0275fac = function (n) { return new (n || t)(B(Xe), B(Xo), B(Jl)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); function Xc(t) { return "string" == typeof t ? document.querySelector(t) : t instanceof Tt ? t.nativeElement : t ?? null } function um(t) { return !!t && (t instanceof qe || Ce(t.lift) && Ce(t.subscribe)) } class Sa { constructor(e, n, r) { this.nodes = e, this.viewRef = n, this.componentRef = r } } class BP { constructor(e, n, r, i, o, s, a, l, c) { this._viewContainerRef = e, this._renderer = n, this._elementRef = r, this._injector = i, this._componentFactoryResolver = o, this._ngZone = s, this._applicationRef = a, this._posService = l, this._document = c, this.onBeforeShow = new Ye, this.onShown = new Ye, this.onBeforeHide = new Ye, this.onHidden = new Ye, this._providers = [], this._isHiding = !1, this.containerDefaultSelector = "body", this._listenOpts = {}, this._globalListener = Function.prototype } get isShown() { return !this._isHiding && !!this._componentRef } attach(e) { return this._componentFactory = this._componentFactoryResolver.resolveComponentFactory(e), this } to(e) { return this.container = e || this.container, this } position(e) { return e ? (this.attachment = e.attachment || this.attachment, this._elementRef = e.target || this._elementRef, this) : this } provide(e) { return this._providers.push(e), this } show(e = {}) { if (this._subscribePositioning(), this._innerComponent = void 0, !this._componentRef) { this.onBeforeShow.emit(), this._contentRef = this._getContentRef(e.content, e.context, e.initialState); const n = tn.create({ providers: this._providers, parent: this._injector }); if (!this._componentFactory) return; if (this._componentRef = this._componentFactory.create(n, this._contentRef.nodes), this._applicationRef.attachView(this._componentRef.hostView), this.instance = this._componentRef.instance, Object.assign(this._componentRef.instance, e), this.container instanceof Tt && this.container.nativeElement.appendChild(this._componentRef.location.nativeElement), "string" == typeof this.container && typeof this._document < "u") { const r = this._document.querySelector(this.container) || this._document.querySelector(this.containerDefaultSelector); if (!r) return; r.appendChild(this._componentRef.location.nativeElement) } !this.container && this._elementRef && this._elementRef.nativeElement.parentElement && this._elementRef.nativeElement.parentElement.appendChild(this._componentRef.location.nativeElement), this._contentRef.componentRef && (this._innerComponent = this._contentRef.componentRef.instance, this._contentRef.componentRef.changeDetectorRef.markForCheck(), this._contentRef.componentRef.changeDetectorRef.detectChanges()), this._componentRef.changeDetectorRef.markForCheck(), this._componentRef.changeDetectorRef.detectChanges(), this.onShown.emit(e.id ? { id: e.id } : this._componentRef.instance) } return this._registerOutsideClick(), this._componentRef } hide(e) { if (!this._componentRef) return this; this._posService.deletePositionElement(this._componentRef.location), this.onBeforeHide.emit(this._componentRef.instance); const n = this._componentRef.location.nativeElement; return n.parentNode?.removeChild(n), this._contentRef?.componentRef?.destroy(), this._viewContainerRef && this._contentRef?.viewRef && this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._contentRef.viewRef)), this._contentRef?.viewRef?.destroy(), this._contentRef = void 0, this._componentRef = void 0, this._removeGlobalListener(), this.onHidden.emit(e ? { id: e } : null), this } toggle() { this.isShown ? this.hide() : this.show() } dispose() { this.isShown && this.hide(), this._unsubscribePositioning(), this._unregisterListenersFn && this._unregisterListenersFn() } listen(e) { this.triggers = e.triggers || this.triggers, this._listenOpts.outsideClick = e.outsideClick, this._listenOpts.outsideEsc = e.outsideEsc, e.target = e.target || this._elementRef?.nativeElement; const n = this._listenOpts.hide = () => e.hide ? e.hide() : void this.hide(), r = this._listenOpts.show = o => { e.show ? e.show(o) : this.show(o), o() }; return this._renderer && (this._unregisterListenersFn = function fP(t, e) { const n = function gD(t, e = dP) { const n = (t || "").trim(); if (0 === n.length) return []; const r = n.split(/\s+/).map(o => o.split(":")).map(o => { const s = e[o[0]] || o; return new uP(s[0], s[1]) }), i = r.filter(o => o.isManual()); if (i.length > 1) throw new Error("Triggers parse error: only one manual trigger is allowed"); if (1 === i.length && r.length > 1) throw new Error("Triggers parse error: manual trigger can't be mixed with other triggers"); return r }(e.triggers), r = e.target; if (1 === n.length && n[0].isManual()) return Function.prototype; const i = [], o = [], s = () => { o.forEach(a => i.push(a())), o.length = 0 }; return n.forEach(a => { const l = a.open === a.close, c = l ? e.toggle : e.show; if (!l && a.close && e.hide) { const u = t.listen(r, a.close, e.hide); o.push(() => u) } c && i.push(t.listen(r, a.open, () => c(s))) }), () => { i.forEach(a => a()) } }(this._renderer, { target: e.target, triggers: e.triggers, show: r, hide: n, toggle: o => { this.isShown ? n() : r(o) } })), this } _removeGlobalListener() { this._globalListener && (this._globalListener(), this._globalListener = Function.prototype) } attachInline(e, n) { return e && n && (this._inlineViewRef = e.createEmbeddedView(n)), this } _registerOutsideClick() { if (this._componentRef && this._componentRef.location) { if (this._listenOpts.outsideClick) { const e = this._componentRef.location.nativeElement; setTimeout(() => { this._renderer && this._elementRef && (this._globalListener = function hP(t, e) { return e.outsideClick ? t.listen("document", "click", n => { e.target && e.target.contains(n.target) || e.targets && e.targets.some(r => r.contains(n.target)) || e.hide && e.hide() }) : Function.prototype }(this._renderer, { targets: [e, this._elementRef.nativeElement], outsideClick: this._listenOpts.outsideClick, hide: () => this._listenOpts.hide && this._listenOpts.hide() })) }) } this._listenOpts.outsideEsc && this._renderer && this._elementRef && (this._globalListener = function mP(t, e) { return e.outsideEsc ? t.listen("document", "keyup.esc", n => { e.target && e.target.contains(n.target) || e.targets && e.targets.some(r => r.contains(n.target)) || e.hide && e.hide() }) : Function.prototype }(this._renderer, { targets: [this._componentRef.location.nativeElement, this._elementRef.nativeElement], outsideEsc: this._listenOpts.outsideEsc, hide: () => this._listenOpts.hide && this._listenOpts.hide() })) } } getInnerComponent() { return this._innerComponent } _subscribePositioning() { this._zoneSubscription || !this.attachment || (this.onShown.subscribe(() => { this._posService.position({ element: this._componentRef?.location, target: this._elementRef, attachment: this.attachment, appendToBody: "body" === this.container }) }), this._zoneSubscription = this._ngZone.onStable.subscribe(() => { !this._componentRef || this._posService.calcPosition() })) } _unsubscribePositioning() { !this._zoneSubscription || (this._zoneSubscription.unsubscribe(), this._zoneSubscription = void 0) } _getContentRef(e, n, r) { if (!e) return new Sa([]); if (e instanceof xr) { if (this._viewContainerRef) { const s = this._viewContainerRef.createEmbeddedView(e, n); return s.markForCheck(), new Sa([s.rootNodes], s) } const o = e.createEmbeddedView({}); return this._applicationRef.attachView(o), new Sa([o.rootNodes], o) } if ("function" == typeof e) { const o = this._componentFactoryResolver.resolveComponentFactory(e), s = tn.create({ providers: this._providers, parent: this._injector }), a = o.create(s); return Object.assign(a.instance, r), this._applicationRef.attachView(a.hostView), new Sa([[a.location.nativeElement]], a.hostView, a) } const i = this._renderer ? [this._renderer.createText(`${e}`)] : []; return new Sa([i]) } } let FD = (() => { class t { constructor(n, r, i, o, s, a) { this._componentFactoryResolver = n, this._ngZone = r, this._injector = i, this._posService = o, this._applicationRef = s, this._document = a } createLoader(n, r, i) { return new BP(r, i, n, this._injector, this._componentFactoryResolver, this._ngZone, this._applicationRef, this._posService, this._document) } } return t.\u0275fac = function (n) { return new (n || t)(B(Vi), B(Xe), B(tn), B(cm), B(aa), B(Gt)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); function jP(t, e, n, r, i) { return (o, s) => { let a = n, l = e, c = 0; o.subscribe(et(s, u => { const d = c++; l = a ? t(l, u, d) : (a = !0, u), r && s.next(l) }, i && (() => { a && s.next(l), s.complete() }))) } } const zP = (t, e) => (t.push(e), t); const GP = ["ulElement"], qP = ["liElements"]; function WP(t, e) { } function ZP(t, e) { if (1 & t && ur(0, "span", 4), 2 & t) { const n = e.match, r = e.query; Ae("innerHtml", lt().highlight(n, r), tg) } } function KP(t, e) { if (1 & t && (Fe(0, "li", 10, 11), Kt(2), Le()), 2 & t) { const n = lt().$implicit; Qe(2), Wo(n) } } function QP(t, e) { } const ND = function (t, e, n, r) { return { item: t, index: e, match: n, query: r } }; function YP(t, e) { if (1 & t) { const n = Ws(); Fe(0, "li", 12, 11), St("mouseenter", function () { Ii(n); const i = lt().$implicit; return Fi(lt(2).selectActive(i)) }), Fe(2, "a", 13), St("click", function (i) { Ii(n); const o = lt().$implicit; return Fi(lt(2).selectMatch(o, i)) }), it(3, QP, 0, 0, "ng-template", 0), Le()() } if (2 & t) { const n = lt(), r = n.$implicit, i = n.index, o = lt(2), s = Go(2); En("active", o.isActive(r)), Ae("id", o.popupId + "-" + i)("@typeaheadAnimation", o.animationState), Qe(3), Ae("ngTemplateOutlet", o.itemTemplate || s)("ngTemplateOutletContext", Wl(6, ND, r.item, i, r, o.query)) } } function XP(t, e) { if (1 & t && (it(0, KP, 3, 1, "li", 8), it(1, YP, 4, 11, "li", 9)), 2 & t) { const n = e.$implicit; Ae("ngIf", n.isHeader()), Qe(1), Ae("ngIf", !n.isHeader()) } } function JP(t, e) { if (1 & t && (Fe(0, "ul", 5, 6), it(2, XP, 2, 2, "ng-template", 7), Le()), 2 & t) { const n = lt(); Zs("overflow-y", n.needScrollbar ? "scroll" : "auto")("height", n.needScrollbar ? n.guiHeight : "auto"), Qe(2), Ae("ngForOf", n.matches) } } function eL(t, e) { if (1 & t && (Fe(0, "h6", 10), Kt(1), Le()), 2 & t) { const n = lt().$implicit; Qe(1), Wo(n) } } function tL(t, e) { } function nL(t, e) { if (1 & t) { const n = Ws(); Fe(0, "button", 15, 11), St("click", function (i) { Ii(n); const o = lt().$implicit; return Fi(lt(2).selectMatch(o, i)) })("mouseenter", function () { Ii(n); const i = lt().$implicit; return Fi(lt(2).selectActive(i)) }), it(2, tL, 0, 0, "ng-template", 0), Le() } if (2 & t) { const n = lt(), r = n.$implicit, i = n.index, o = lt(2), s = Go(2); En("active", o.isActive(r)), Ae("id", o.popupId + "-" + i)("@typeaheadAnimation", o.animationState), Qe(2), Ae("ngTemplateOutlet", o.itemTemplate || s)("ngTemplateOutletContext", Wl(6, ND, r.item, i, r, o.query)) } } function rL(t, e) { if (1 & t && (it(0, eL, 2, 1, "h6", 8), it(1, nL, 3, 11, "ng-template", 14)), 2 & t) { const n = e.$implicit; Ae("ngIf", n.isHeader()), Qe(1), Ae("ngIf", !n.isHeader()) } } function iL(t, e) { 1 & t && it(0, rL, 2, 2, "ng-template", 7), 2 & t && Ae("ngForOf", lt().matches) } const oL = function (t, e, n, r) { return { matches: t, itemTemplate: e, query: n, $implicit: r } }, sL = { \u00c1: "A", \u0102: "A", \u1eae: "A", \u1eb6: "A", \u1eb0: "A", \u1eb2: "A", \u1eb4: "A", \u01cd: "A", \u00c2: "A", \u1ea4: "A", \u1eac: "A", \u1ea6: "A", \u1ea8: "A", \u1eaa: "A", \u00c4: "A", \u01de: "A", \u0226: "A", \u01e0: "A", \u1ea0: "A", \u0200: "A", \u00c0: "A", \u1ea2: "A", \u0202: "A", \u0100: "A", \u0104: "A", \u00c5: "A", \u01fa: "A", \u1e00: "A", \u023a: "A", \u00c3: "A", \ua732: "AA", \u00c6: "AE", \u01fc: "AE", \u01e2: "AE", \ua734: "AO", \ua736: "AU", \ua738: "AV", \ua73a: "AV", \ua73c: "AY", \u1e02: "B", \u1e04: "B", \u0181: "B", \u1e06: "B", \u0243: "B", \u0182: "B", \u0106: "C", \u010c: "C", \u00c7: "C", \u1e08: "C", \u0108: "C", \u010a: "C", \u0187: "C", \u023b: "C", \u010e: "D", \u1e10: "D", \u1e12: "D", \u1e0a: "D", \u1e0c: "D", \u018a: "D", \u1e0e: "D", \u01f2: "D", \u01c5: "D", \u0110: "D", \u018b: "D", \u01f1: "DZ", \u01c4: "DZ", \u00c9: "E", \u0114: "E", \u011a: "E", \u0228: "E", \u1e1c: "E", \u00ca: "E", \u1ebe: "E", \u1ec6: "E", \u1ec0: "E", \u1ec2: "E", \u1ec4: "E", \u1e18: "E", \u00cb: "E", \u0116: "E", \u1eb8: "E", \u0204: "E", \u00c8: "E", \u1eba: "E", \u0206: "E", \u0112: "E", \u1e16: "E", \u1e14: "E", \u0118: "E", \u0246: "E", \u1ebc: "E", \u1e1a: "E", \ua76a: "ET", \u1e1e: "F", \u0191: "F", \u01f4: "G", \u011e: "G", \u01e6: "G", \u0122: "G", \u011c: "G", \u0120: "G", \u0193: "G", \u1e20: "G", \u01e4: "G", \u1e2a: "H", \u021e: "H", \u1e28: "H", \u0124: "H", \u2c67: "H", \u1e26: "H", \u1e22: "H", \u1e24: "H", \u0126: "H", \u00cd: "I", \u012c: "I", \u01cf: "I", \u00ce: "I", \u00cf: "I", \u1e2e: "I", \u0130: "I", \u1eca: "I", \u0208: "I", \u00cc: "I", \u1ec8: "I", \u020a: "I", \u012a: "I", \u012e: "I", \u0197: "I", \u0128: "I", \u1e2c: "I", \ua779: "D", \ua77b: "F", \ua77d: "G", \ua782: "R", \ua784: "S", \ua786: "T", \ua76c: "IS", \u0134: "J", \u0248: "J", \u1e30: "K", \u01e8: "K", \u0136: "K", \u2c69: "K", \ua742: "K", \u1e32: "K", \u0198: "K", \u1e34: "K", \ua740: "K", \ua744: "K", \u0139: "L", \u023d: "L", \u013d: "L", \u013b: "L", \u1e3c: "L", \u1e36: "L", \u1e38: "L", \u2c60: "L", \ua748: "L", \u1e3a: "L", \u013f: "L", \u2c62: "L", \u01c8: "L", \u0141: "L", \u01c7: "LJ", \u1e3e: "M", \u1e40: "M", \u1e42: "M", \u2c6e: "M", \u0143: "N", \u0147: "N", \u0145: "N", \u1e4a: "N", \u1e44: "N", \u1e46: "N", \u01f8: "N", \u019d: "N", \u1e48: "N", \u0220: "N", \u01cb: "N", \u00d1: "N", \u01ca: "NJ", \u00d3: "O", \u014e: "O", \u01d1: "O", \u00d4: "O", \u1ed0: "O", \u1ed8: "O", \u1ed2: "O", \u1ed4: "O", \u1ed6: "O", \u00d6: "O", \u022a: "O", \u022e: "O", \u0230: "O", \u1ecc: "O", \u0150: "O", \u020c: "O", \u00d2: "O", \u1ece: "O", \u01a0: "O", \u1eda: "O", \u1ee2: "O", \u1edc: "O", \u1ede: "O", \u1ee0: "O", \u020e: "O", \ua74a: "O", \ua74c: "O", \u014c: "O", \u1e52: "O", \u1e50: "O", \u019f: "O", \u01ea: "O", \u01ec: "O", \u00d8: "O", \u01fe: "O", \u00d5: "O", \u1e4c: "O", \u1e4e: "O", \u022c: "O", \u01a2: "OI", \ua74e: "OO", \u0190: "E", \u0186: "O", \u0222: "OU", \u1e54: "P", \u1e56: "P", \ua752: "P", \u01a4: "P", \ua754: "P", \u2c63: "P", \ua750: "P", \ua758: "Q", \ua756: "Q", \u0154: "R", \u0158: "R", \u0156: "R", \u1e58: "R", \u1e5a: "R", \u1e5c: "R", \u0210: "R", \u0212: "R", \u1e5e: "R", \u024c: "R", \u2c64: "R", \ua73e: "C", \u018e: "E", \u015a: "S", \u1e64: "S", \u0160: "S", \u1e66: "S", \u015e: "S", \u015c: "S", \u0218: "S", \u1e60: "S", \u1e62: "S", \u1e68: "S", \u0164: "T", \u0162: "T", \u1e70: "T", \u021a: "T", \u023e: "T", \u1e6a: "T", \u1e6c: "T", \u01ac: "T", \u1e6e: "T", \u01ae: "T", \u0166: "T", \u2c6f: "A", \ua780: "L", \u019c: "M", \u0245: "V", \ua728: "TZ", \u00da: "U", \u016c: "U", \u01d3: "U", \u00db: "U", \u1e76: "U", \u00dc: "U", \u01d7: "U", \u01d9: "U", \u01db: "U", \u01d5: "U", \u1e72: "U", \u1ee4: "U", \u0170: "U", \u0214: "U", \u00d9: "U", \u1ee6: "U", \u01af: "U", \u1ee8: "U", \u1ef0: "U", \u1eea: "U", \u1eec: "U", \u1eee: "U", \u0216: "U", \u016a: "U", \u1e7a: "U", \u0172: "U", \u016e: "U", \u0168: "U", \u1e78: "U", \u1e74: "U", \ua75e: "V", \u1e7e: "V", \u01b2: "V", \u1e7c: "V", \ua760: "VY", \u1e82: "W", \u0174: "W", \u1e84: "W", \u1e86: "W", \u1e88: "W", \u1e80: "W", \u2c72: "W", \u1e8c: "X", \u1e8a: "X", \u00dd: "Y", \u0176: "Y", \u0178: "Y", \u1e8e: "Y", \u1ef4: "Y", \u1ef2: "Y", \u01b3: "Y", \u1ef6: "Y", \u1efe: "Y", \u0232: "Y", \u024e: "Y", \u1ef8: "Y", \u0179: "Z", \u017d: "Z", \u1e90: "Z", \u2c6b: "Z", \u017b: "Z", \u1e92: "Z", \u0224: "Z", \u1e94: "Z", \u01b5: "Z", \u0132: "IJ", \u0152: "OE", \u1d00: "A", \u1d01: "AE", \u0299: "B", \u1d03: "B", \u1d04: "C", \u1d05: "D", \u1d07: "E", \ua730: "F", \u0262: "G", \u029b: "G", \u029c: "H", \u026a: "I", \u0281: "R", \u1d0a: "J", \u1d0b: "K", \u029f: "L", \u1d0c: "L", \u1d0d: "M", \u0274: "N", \u1d0f: "O", \u0276: "OE", \u1d10: "O", \u1d15: "OU", \u1d18: "P", \u0280: "R", \u1d0e: "N", \u1d19: "R", \ua731: "S", \u1d1b: "T", \u2c7b: "E", \u1d1a: "R", \u1d1c: "U", \u1d20: "V", \u1d21: "W", \u028f: "Y", \u1d22: "Z", \u00e1: "a", \u0103: "a", \u1eaf: "a", \u1eb7: "a", \u1eb1: "a", \u1eb3: "a", \u1eb5: "a", \u01ce: "a", \u00e2: "a", \u1ea5: "a", \u1ead: "a", \u1ea7: "a", \u1ea9: "a", \u1eab: "a", \u00e4: "a", \u01df: "a", \u0227: "a", \u01e1: "a", \u1ea1: "a", \u0201: "a", \u00e0: "a", \u1ea3: "a", \u0203: "a", \u0101: "a", \u0105: "a", \u1d8f: "a", \u1e9a: "a", \u00e5: "a", \u01fb: "a", \u1e01: "a", \u2c65: "a", \u00e3: "a", \ua733: "aa", \u00e6: "ae", \u01fd: "ae", \u01e3: "ae", \ua735: "ao", \ua737: "au", \ua739: "av", \ua73b: "av", \ua73d: "ay", \u1e03: "b", \u1e05: "b", \u0253: "b", \u1e07: "b", \u1d6c: "b", \u1d80: "b", \u0180: "b", \u0183: "b", \u0275: "o", \u0107: "c", \u010d: "c", \u00e7: "c", \u1e09: "c", \u0109: "c", \u0255: "c", \u010b: "c", \u0188: "c", \u023c: "c", \u010f: "d", \u1e11: "d", \u1e13: "d", \u0221: "d", \u1e0b: "d", \u1e0d: "d", \u0257: "d", \u1d91: "d", \u1e0f: "d", \u1d6d: "d", \u1d81: "d", \u0111: "d", \u0256: "d", \u018c: "d", \u0131: "i", \u0237: "j", \u025f: "j", \u0284: "j", \u01f3: "dz", \u01c6: "dz", \u00e9: "e", \u0115: "e", \u011b: "e", \u0229: "e", \u1e1d: "e", \u00ea: "e", \u1ebf: "e", \u1ec7: "e", \u1ec1: "e", \u1ec3: "e", \u1ec5: "e", \u1e19: "e", \u00eb: "e", \u0117: "e", \u1eb9: "e", \u0205: "e", \u00e8: "e", \u1ebb: "e", \u0207: "e", \u0113: "e", \u1e17: "e", \u1e15: "e", \u2c78: "e", \u0119: "e", \u1d92: "e", \u0247: "e", \u1ebd: "e", \u1e1b: "e", \ua76b: "et", \u1e1f: "f", \u0192: "f", \u1d6e: "f", \u1d82: "f", \u01f5: "g", \u011f: "g", \u01e7: "g", \u0123: "g", \u011d: "g", \u0121: "g", \u0260: "g", \u1e21: "g", \u1d83: "g", \u01e5: "g", \u1e2b: "h", \u021f: "h", \u1e29: "h", \u0125: "h", \u2c68: "h", \u1e27: "h", \u1e23: "h", \u1e25: "h", \u0266: "h", \u1e96: "h", \u0127: "h", \u0195: "hv", \u00ed: "i", \u012d: "i", \u01d0: "i", \u00ee: "i", \u00ef: "i", \u1e2f: "i", \u1ecb: "i", \u0209: "i", \u00ec: "i", \u1ec9: "i", \u020b: "i", \u012b: "i", \u012f: "i", \u1d96: "i", \u0268: "i", \u0129: "i", \u1e2d: "i", \ua77a: "d", \ua77c: "f", \u1d79: "g", \ua783: "r", \ua785: "s", \ua787: "t", \ua76d: "is", \u01f0: "j", \u0135: "j", \u029d: "j", \u0249: "j", \u1e31: "k", \u01e9: "k", \u0137: "k", \u2c6a: "k", \ua743: "k", \u1e33: "k", \u0199: "k", \u1e35: "k", \u1d84: "k", \ua741: "k", \ua745: "k", \u013a: "l", \u019a: "l", \u026c: "l", \u013e: "l", \u013c: "l", \u1e3d: "l", \u0234: "l", \u1e37: "l", \u1e39: "l", \u2c61: "l", \ua749: "l", \u1e3b: "l", \u0140: "l", \u026b: "l", \u1d85: "l", \u026d: "l", \u0142: "l", \u01c9: "lj", \u017f: "s", \u1e9c: "s", \u1e9b: "s", \u1e9d: "s", \u1e3f: "m", \u1e41: "m", \u1e43: "m", \u0271: "m", \u1d6f: "m", \u1d86: "m", \u0144: "n", \u0148: "n", \u0146: "n", \u1e4b: "n", \u0235: "n", \u1e45: "n", \u1e47: "n", \u01f9: "n", \u0272: "n", \u1e49: "n", \u019e: "n", \u1d70: "n", \u1d87: "n", \u0273: "n", \u00f1: "n", \u01cc: "nj", \u00f3: "o", \u014f: "o", \u01d2: "o", \u00f4: "o", \u1ed1: "o", \u1ed9: "o", \u1ed3: "o", \u1ed5: "o", \u1ed7: "o", \u00f6: "o", \u022b: "o", \u022f: "o", \u0231: "o", \u1ecd: "o", \u0151: "o", \u020d: "o", \u00f2: "o", \u1ecf: "o", \u01a1: "o", \u1edb: "o", \u1ee3: "o", \u1edd: "o", \u1edf: "o", \u1ee1: "o", \u020f: "o", \ua74b: "o", \ua74d: "o", \u2c7a: "o", \u014d: "o", \u1e53: "o", \u1e51: "o", \u01eb: "o", \u01ed: "o", \u00f8: "o", \u01ff: "o", \u00f5: "o", \u1e4d: "o", \u1e4f: "o", \u022d: "o", \u01a3: "oi", \ua74f: "oo", \u025b: "e", \u1d93: "e", \u0254: "o", \u1d97: "o", \u0223: "ou", \u1e55: "p", \u1e57: "p", \ua753: "p", \u01a5: "p", \u1d71: "p", \u1d88: "p", \ua755: "p", \u1d7d: "p", \ua751: "p", \ua759: "q", \u02a0: "q", \u024b: "q", \ua757: "q", \u0155: "r", \u0159: "r", \u0157: "r", \u1e59: "r", \u1e5b: "r", \u1e5d: "r", \u0211: "r", \u027e: "r", \u1d73: "r", \u0213: "r", \u1e5f: "r", \u027c: "r", \u1d72: "r", \u1d89: "r", \u024d: "r", \u027d: "r", \u2184: "c", \ua73f: "c", \u0258: "e", \u027f: "r", \u015b: "s", \u1e65: "s", \u0161: "s", \u1e67: "s", \u015f: "s", \u015d: "s", \u0219: "s", \u1e61: "s", \u1e63: "s", \u1e69: "s", \u0282: "s", \u1d74: "s", \u1d8a: "s", \u023f: "s", \u0261: "g", \u1d11: "o", \u1d13: "o", \u1d1d: "u", \u0165: "t", \u0163: "t", \u1e71: "t", \u021b: "t", \u0236: "t", \u1e97: "t", \u2c66: "t", \u1e6b: "t", \u1e6d: "t", \u01ad: "t", \u1e6f: "t", \u1d75: "t", \u01ab: "t", \u0288: "t", \u0167: "t", \u1d7a: "th", \u0250: "a", \u1d02: "ae", \u01dd: "e", \u1d77: "g", \u0265: "h", \u02ae: "h", \u02af: "h", \u1d09: "i", \u029e: "k", \ua781: "l", \u026f: "m", \u0270: "m", \u1d14: "oe", \u0279: "r", \u027b: "r", \u027a: "r", \u2c79: "r", \u0287: "t", \u028c: "v", \u028d: "w", \u028e: "y", \ua729: "tz", \u00fa: "u", \u016d: "u", \u01d4: "u", \u00fb: "u", \u1e77: "u", \u00fc: "u", \u01d8: "u", \u01da: "u", \u01dc: "u", \u01d6: "u", \u1e73: "u", \u1ee5: "u", \u0171: "u", \u0215: "u", \u00f9: "u", \u1ee7: "u", \u01b0: "u", \u1ee9: "u", \u1ef1: "u", \u1eeb: "u", \u1eed: "u", \u1eef: "u", \u0217: "u", \u016b: "u", \u1e7b: "u", \u0173: "u", \u1d99: "u", \u016f: "u", \u0169: "u", \u1e79: "u", \u1e75: "u", \u1d6b: "ue", \ua778: "um", \u2c74: "v", \ua75f: "v", \u1e7f: "v", \u028b: "v", \u1d8c: "v", \u2c71: "v", \u1e7d: "v", \ua761: "vy", \u1e83: "w", \u0175: "w", \u1e85: "w", \u1e87: "w", \u1e89: "w", \u1e81: "w", \u2c73: "w", \u1e98: "w", \u1e8d: "x", \u1e8b: "x", \u1d8d: "x", \u00fd: "y", \u0177: "y", \u00ff: "y", \u1e8f: "y", \u1ef5: "y", \u1ef3: "y", \u01b4: "y", \u1ef7: "y", \u1eff: "y", \u0233: "y", \u1e99: "y", \u024f: "y", \u1ef9: "y", \u017a: "z", \u017e: "z", \u1e91: "z", \u0291: "z", \u2c6c: "z", \u017c: "z", \u1e93: "z", \u0225: "z", \u1e95: "z", \u1d76: "z", \u1d8e: "z", \u0290: "z", \u01b6: "z", \u0240: "z", \ufb00: "ff", \ufb03: "ffi", \ufb04: "ffl", \ufb01: "fi", \ufb02: "fl", \u0133: "ij", \u0153: "oe", \ufb06: "st", \u2090: "a", \u2091: "e", \u1d62: "i", \u2c7c: "j", \u2092: "o", \u1d63: "r", \u1d64: "u", \u1d65: "v", \u2093: "x" }; class Jc { constructor(e, n = e, r = !1) { this.item = e, this.value = n, this.header = r } isHeader() { return this.header } toString() { return this.value } } function Ia(t) { return t ? t.replace(/[^A-Za-z0-9[\] ]/g, function (e) { return sL[e] || e }) : "" } function dm(t, e = " ", n = "", r) { let i = []; if (r) { const s = t.split(new RegExp(`([${r}]+)`, "g")), a = s[s.length - 1]; a > "" && (e && n ? i = OD(a, e, n) : i.push(a)) } else i = OD(t, e, n); return i } function OD(t, e, n) { const r = [], o = t.split(new RegExp(`(?:[${n}])([^${n}]+)(?:[${n}])|([^${e}]+)`, "g")), s = o.length; let a; const l = new RegExp(`[${n}]+`, "g"); for (let c = 0; c < s; c += 1)a = o[c], a && a.length && a !== e && r.push(a.replace(l, "")); return r } function Qi(t, e) { if (!e || "object" != typeof t) return t.toString(); if (e.endsWith("()")) return t[e.slice(0, e.length - 2)]().toString(); const r = e.replace(/\[(\w+)\]/g, ".$1").replace(/^\./, "").split("."); for (const i of r) i in t && (t = t[i]); return t ? t.toString() : "" } const RD = "220ms cubic-bezier(0, 0, 0.2, 1)", aL = sD("typeaheadAnimation", [Qh("animated-down", yi({ height: "*", overflow: "hidden" })), Gc("* => animated-down", [yi({ height: 0, overflow: "hidden" }), Uc(RD)]), Qh("animated-up", yi({ height: "*", overflow: "hidden" })), Gc("* => animated-up", [yi({ height: "*", overflow: "hidden" }), Uc(RD)]), Gc("* => unanimated", Uc("0s"))]); let lL = 0, cL = (() => { class t { constructor(n, r, i, o) { this.positionService = n, this.renderer = r, this.element = i, this.changeDetectorRef = o, this.activeChangeEvent = new Ye, this.isFocused = !1, this.positionServiceSubscription = new ln, this.height = 0, this.popupId = "ngb-typeahead-" + lL++, this._matches = [], this.renderer.setAttribute(this.element.nativeElement, "id", this.popupId), this.positionServiceSubscription.add(this.positionService.event$?.subscribe(() => { if (this.isAnimated) return this.animationState = this.isTopPosition ? "animated-up" : "animated-down", void this.changeDetectorRef.detectChanges(); this.animationState = "unanimated", this.changeDetectorRef.detectChanges() })) } get isBs4() { return !Wc() } get typeaheadTemplateMethods() { return { selectMatch: this.selectMatch.bind(this), selectActive: this.selectActive.bind(this), isActive: this.isActive.bind(this) } } get active() { return this._active } set active(n) { this._active = n, this.activeChanged() } get matches() { return this._matches } set matches(n) { if (this.positionService.setOptions({ modifiers: { flip: { enabled: this.adaptivePosition } }, allowedPositions: ["top", "bottom"] }), this._matches = n, this.needScrollbar = this.typeaheadScrollable && this.typeaheadOptionsInScrollableView < this.matches.length, this.typeaheadScrollable && setTimeout(() => { this.setScrollableMode() }), this.typeaheadIsFirstItemActive && this._matches.length > 0 && (this.setActive(this._matches[0]), this._active?.isHeader() && this.nextActiveMatch()), this._active && !this.typeaheadIsFirstItemActive) { const r = this._matches.find(i => i.value === this._active?.value); if (r) return void this.selectActive(r); this.active = void 0 } } get isTopPosition() { return this.element.nativeElement.classList.contains("top") } get optionsListTemplate() { return this.parent ? this.parent.optionsListTemplate : void 0 } get isAnimated() { return !!this.parent && this.parent.isAnimated } get adaptivePosition() { return !!this.parent && this.parent.adaptivePosition } get typeaheadScrollable() { return !!this.parent && this.parent.typeaheadScrollable } get typeaheadOptionsInScrollableView() { return this.parent ? this.parent.typeaheadOptionsInScrollableView : 5 } get typeaheadIsFirstItemActive() { return !this.parent || this.parent.typeaheadIsFirstItemActive } get itemTemplate() { return this.parent ? this.parent.typeaheadItemTemplate : void 0 } get canSelectItemsOnBlur() { return !!this.parent?.selectItemOnBlur } selectActiveMatch(n) { this._active && this.parent?.typeaheadSelectFirstItem && this.selectMatch(this._active), !this.parent?.typeaheadSelectFirstItem && n && this.selectMatch(this._active) } activeChanged() { if (!this._active) return; const n = this.matches.indexOf(this._active); this.activeChangeEvent.emit(`${this.popupId}-${n}`) } prevActiveMatch() { if (!this._active) return; const n = this.matches.indexOf(this._active); this.setActive(this.matches[n - 1 < 0 ? this.matches.length - 1 : n - 1]), this._active.isHeader() && this.prevActiveMatch(), this.typeaheadScrollable && this.scrollPrevious(n) } nextActiveMatch() { const n = this._active ? this.matches.indexOf(this._active) : -1; this.setActive(this.matches[n + 1 > this.matches.length - 1 ? 0 : n + 1]), this._active?.isHeader() && this.nextActiveMatch(), this.typeaheadScrollable && this.scrollNext(n) } selectActive(n) { this.isFocused = !0, this.setActive(n) } highlight(n, r) { let s, a, i = n.value, o = (this.parent && this.parent.typeaheadLatinize ? Ia(i) : i).toLowerCase(); if ("object" == typeof r) { const l = r.length; for (let c = 0; c < l; c += 1)s = o.indexOf(r[c]), a = r[c].length, s >= 0 && a > 0 && (i = `${i.substring(0, s)}<strong>${i.substring(s, s + a)}</strong>${i.substring(s + a)}`, o = `${o.substring(0, s)}        ${" ".repeat(a)}         ${o.substring(s + a)}`) } else r && (s = o.indexOf(r), a = r.length, s >= 0 && a > 0 && (i = `${i.substring(0, s)}<strong>${i.substring(s, s + a)}</strong>${i.substring(s + a)}`)); return i } focusLost() { this.isFocused = !1, this.canSelectItemsOnBlur || this.setActive(void 0) } isActive(n) { return this.active === n } selectMatch(n, r) { return r && (r.stopPropagation(), r.preventDefault()), this.parent?.changeModel(n), setTimeout(() => this.parent?.typeaheadOnSelect.emit(n), 0), !1 } setScrollableMode() { if (this.ulElement || (this.ulElement = this.element), this.liElements?.first) { const n = yD.getStyles(this.ulElement.nativeElement), r = yD.getStyles(this.liElements.first.nativeElement), i = parseFloat((n["padding-bottom"] ? n["padding-bottom"] : "").replace("px", "")), o = parseFloat((n["padding-top"] ? n["padding-top"] : "0").replace("px", "")), s = parseFloat((r.height ? r.height : "0").replace("px", "")); this.guiHeight = `${this.typeaheadOptionsInScrollableView * s + o + i}px` } this.renderer.setStyle(this.element.nativeElement, "visibility", "visible") } scrollPrevious(n) { if (0 !== n) { if (this.liElements && this.ulElement) { const r = this.liElements.toArray()[n - 1]; r && !this.isScrolledIntoView(r.nativeElement) && (this.ulElement.nativeElement.scrollTop = r.nativeElement.offsetTop) } } else this.scrollToBottom() } scrollNext(n) { if (n + 1 > this.matches.length - 1) this.scrollToTop(); else if (this.liElements && this.ulElement) { const r = this.liElements.toArray()[n + 1]; r && !this.isScrolledIntoView(r.nativeElement) && (this.ulElement.nativeElement.scrollTop = r.nativeElement.offsetTop - Number(this.ulElement.nativeElement.offsetHeight) + Number(r.nativeElement.offsetHeight)) } } ngOnDestroy() { this.positionServiceSubscription.unsubscribe() } setActive(n) { let r; this._active = n, null == this._active || this._active.isHeader() || (r = n), this.parent?.typeaheadOnPreview.emit(r) } isScrolledIntoView(n) { if (!this.ulElement) return !1; const r = this.ulElement.nativeElement.scrollTop, i = r + Number(this.ulElement.nativeElement.offsetHeight), o = n.offsetTop; return o + n.offsetHeight <= i && o >= r } scrollToBottom() { !this.ulElement?.nativeElement || (this.ulElement.nativeElement.scrollTop = this.ulElement.nativeElement.scrollHeight) } scrollToTop() { !this.ulElement?.nativeElement || (this.ulElement.nativeElement.scrollTop = 0) } } return t.\u0275fac = function (n) { return new (n || t)(T(cm), T(Qr), T(Tt), T(ts)) }, t.\u0275cmp = uo({ type: t, selectors: [["typeahead-container"]], viewQuery: function (n, r) { if (1 & n && (ji(GP, 5), ji(qP, 5)), 2 & n) { let i; rn(i = on()) && (r.ulElement = i.first), rn(i = on()) && (r.liElements = i) } }, hostAttrs: [1, "dropdown", "open", "bottom", 2, "position", "absolute", "display", "block"], hostVars: 9, hostBindings: function (n, r) { 1 & n && St("mouseleave", function () { return r.focusLost() })("blur", function () { return r.focusLost() }), 2 & n && (mn("role", r.isBs4 ? "listbox" : null), Zs("height", r.isBs4 && r.needScrollbar ? r.guiHeight : "auto")("visibility", "inherit"), En("dropdown-menu", r.isBs4)("dropup", r.dropup)) }, outputs: { activeChangeEvent: "activeChange" }, decls: 7, vars: 7, consts: [[3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["bsItemTemplate", ""], ["bs3Template", ""], ["bs4Template", ""], [3, "innerHtml"], ["role", "listbox", 1, "dropdown-menu"], ["ulElement", ""], ["ngFor", "", 3, "ngForOf"], ["class", "dropdown-header", 4, "ngIf"], ["role", "option", 3, "id", "active", "mouseenter", 4, "ngIf"], [1, "dropdown-header"], ["liElements", ""], ["role", "option", 3, "id", "mouseenter"], ["href", "#", "tabindex", "-1", 3, "click"], [3, "ngIf"], ["role", "option", 1, "dropdown-item", 3, "id", "click", "mouseenter"]], template: function (n, r) { if (1 & n && (it(0, WP, 0, 0, "ng-template", 0), it(1, ZP, 1, 1, "ng-template", null, 1, Kl), it(3, JP, 3, 5, "ng-template", null, 2, Kl), it(5, iL, 1, 1, "ng-template", null, 3, Kl)), 2 & n) { const i = Go(2), o = Go(4), s = Go(6); Ae("ngTemplateOutlet", r.optionsListTemplate || (r.isBs4 ? s : o))("ngTemplateOutletContext", Wl(2, oL, r.matches, r.itemTemplate || i, r.query, r.typeaheadTemplateMethods)) } }, dependencies: [z0, pc, Z0], styles: [".dropdown[_nghost-%COMP%]{z-index:1000}.dropdown-menu[_nghost-%COMP%], .dropdown-menu[_ngcontent-%COMP%]{overflow-y:auto;height:100px}"], data: { animation: [aL] } }), t })(), PD = (() => { class t { constructor() { this.adaptivePosition = !1, this.isAnimated = !1, this.hideResultsOnBlur = !0, this.cancelRequestOnFocusLost = !1, this.selectFirstItem = !0, this.isFirstItemActive = !0, this.minLength = 1, this.selectItemOnBlur = !1 } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(), uL = (() => { class t { constructor(n, r, i, o, s, a, l) { this.changeDetection = i, this.element = o, this.ngControl = s, this.renderer = a, this.typeaheadMinLength = 1, this.adaptivePosition = !1, this.isAnimated = !1, this.typeaheadWaitMs = 0, this.typeaheadLatinize = !0, this.typeaheadSingleWords = !0, this.typeaheadWordDelimiters = " ", this.typeaheadMultipleSearchDelimiters = ",", this.typeaheadPhraseDelimiters = "'\"", this.typeaheadScrollable = !1, this.typeaheadOptionsInScrollableView = 5, this.typeaheadSelectFirstItem = !0, this.typeaheadIsFirstItemActive = !0, this.typeaheadLoading = new Ye, this.typeaheadNoResults = new Ye, this.typeaheadOnSelect = new Ye, this.typeaheadOnPreview = new Ye, this.typeaheadOnBlur = new Ye, this.dropup = !1, this.isOpen = !1, this.list = "list", this.isActiveItemChanged = !1, this.isFocused = !1, this.cancelRequestOnFocusLost = !1, this.selectItemOnBlur = !1, this.keyUpEventEmitter = new Ye, this.placement = "bottom left", this._matches = [], this._subscriptions = [], this._outsideClickListener = () => { }, this._typeahead = n.createLoader(o, l, a).provide({ provide: PD, useValue: r }), Object.assign(this, { typeaheadHideResultsOnBlur: r.hideResultsOnBlur, cancelRequestOnFocusLost: r.cancelRequestOnFocusLost, typeaheadSelectFirstItem: r.selectFirstItem, typeaheadIsFirstItemActive: r.isFirstItemActive, typeaheadMinLength: r.minLength, adaptivePosition: r.adaptivePosition, isAnimated: r.isAnimated, selectItemOnBlur: r.selectItemOnBlur }) } get matches() { return this._matches } ngOnInit() { this.typeaheadOptionsLimit = this.typeaheadOptionsLimit || 20, this.typeaheadMinLength = void 0 === this.typeaheadMinLength ? 1 : this.typeaheadMinLength, void 0 === this.typeaheadAsync && !um(this.typeahead) && (this.typeaheadAsync = !1), um(this.typeahead) && (this.typeaheadAsync = !0), this.typeaheadAsync ? this.asyncActions() : this.syncActions(), this.checkDelimitersConflict() } onInput(n) { const r = void 0 !== n.target.value ? n.target.value : void 0 !== n.target.textContent ? n.target.textContent : n.target.innerText; null != r && r.trim().length >= this.typeaheadMinLength ? (this.typeaheadLoading.emit(!0), this.keyUpEventEmitter.emit(n.target.value)) : (this.typeaheadLoading.emit(!1), this.typeaheadNoResults.emit(!1), this.hide()) } onChange(n) { if (this._container) { if (27 === n.keyCode || "Escape" === n.key) return void this.hide(); if (38 === n.keyCode || "ArrowUp" === n.key) return this.isActiveItemChanged = !0, void this._container.prevActiveMatch(); if (40 === n.keyCode || "ArrowDown" === n.key) return this.isActiveItemChanged = !0, void this._container.nextActiveMatch(); if (13 === n.keyCode || "Enter" === n.key) return void this._container.selectActiveMatch() } } onFocus() { this.isFocused = !0, setTimeout(() => { 0 === this.typeaheadMinLength && (this.typeaheadLoading.emit(!0), this.keyUpEventEmitter.emit(this.element.nativeElement.value || "")) }, 0) } onBlur() { this.isFocused = !1, this._container && !this._container.isFocused && this.typeaheadOnBlur.emit(this._container.active), !this.container && 0 === this._matches?.length && this.typeaheadOnBlur.emit(new Jc(this.element.nativeElement.value, this.element.nativeElement.value, !1)) } onKeydown(n) { if (this._container && ((9 === n.keyCode || "Tab" === n.key) && this.onBlur(), 9 === n.keyCode || "Tab" === n.key || 13 === n.keyCode || "Enter" === n.key)) { if (n.preventDefault(), this.typeaheadSelectFirstItem) return void this._container.selectActiveMatch(); this.typeaheadSelectFirstItem || (this._container.selectActiveMatch(this.isActiveItemChanged), this.isActiveItemChanged = !1, this.hide()) } } changeModel(n) { if (!n) return; let r; if (this.typeaheadMultipleSearch && this._allEnteredValue) { const i = this._allEnteredValue.split(new RegExp(`([${this.typeaheadMultipleSearchDelimiters}]+)`)); this._allEnteredValue = i.slice(0, i.length - 1).concat(n.value).join(""), r = this._allEnteredValue } else r = n.value; this.ngControl.viewToModelUpdate(r), this.ngControl.control?.setValue(r), this.changeDetection.markForCheck(), this.hide() } show() { if (this._typeahead.attach(cL).to(this.container).position({ attachment: (this.dropup ? "top" : "bottom") + " left" }).show({ typeaheadRef: this, placement: this.placement, animation: !1, dropup: this.dropup }), this._outsideClickListener = this.renderer.listen("document", "click", r => { 0 === this.typeaheadMinLength && this.element.nativeElement.contains(r.target) || !this.typeaheadHideResultsOnBlur || this.element.nativeElement.contains(r.target) || this.onOutsideClick() }), !this._typeahead.instance || !this.ngControl.control) return; this._container = this._typeahead.instance, this._container.parent = this; const n = (this.typeaheadLatinize ? Ia(this.ngControl.control.value) : this.ngControl.control.value).toString().toLowerCase(); this._container.query = this.tokenizeQuery(n), this._container.matches = this._matches, this.element.nativeElement.focus(), this._container.activeChangeEvent.subscribe(r => { this.activeDescendant = r, this.changeDetection.markForCheck() }), this.isOpen = !0 } hide() { this._typeahead.isShown && (this._typeahead.hide(), this._outsideClickListener(), this._container = void 0, this.isOpen = !1, this.changeDetection.markForCheck()), this.typeaheadOnPreview.emit() } onOutsideClick() { this._container && !this._container.isFocused && this.hide() } ngOnDestroy() { for (const n of this._subscriptions) n.unsubscribe(); this._typeahead.dispose() } asyncActions() { this._subscriptions.push(this.keyUpEventEmitter.pipe(jc(this.typeaheadWaitMs), function HP(t, e, n) { const r = Ce(t) || e || n ? { next: t, error: e, complete: n } : t; return r ? Wt((i, o) => { var s; null === (s = r.subscribe) || void 0 === s || s.call(r); let a = !0; i.subscribe(et(o, l => { var c; null === (c = r.next) || void 0 === c || c.call(r, l), o.next(l) }, () => { var l; a = !1, null === (l = r.complete) || void 0 === l || l.call(r), o.complete() }, l => { var c; a = !1, null === (c = r.error) || void 0 === c || c.call(r, l), o.error(l) }, () => { var l, c; a && (null === (l = r.unsubscribe) || void 0 === l || l.call(r)), null === (c = r.finalize) || void 0 === c || c.call(r) })) }) : Vr }(n => this._allEnteredValue = n), bv(() => this.typeahead ? this.typeahead : xt)).subscribe(n => { this.finalizeAsyncCall(n) })) } syncActions() { this._subscriptions.push(this.keyUpEventEmitter.pipe(jc(this.typeaheadWaitMs), st(n => { this._allEnteredValue = n; const r = this.normalizeQuery(n); return this.typeahead ? (um(this.typeahead) ? this.typeahead : le(this.typeahead)).pipe(Fw(o => !!o && this.testMatch(this.normalizeOption(o), r)), function UP() { return Wt((t, e) => { (function $P(t, e) { return Wt(jP(t, e, arguments.length >= 2, !1, !0)) })(zP, [])(t).subscribe(e) }) }()) : xt })).subscribe(n => { this.finalizeAsyncCall(n) })) } normalizeOption(n) { const r = Qi(n, this.typeaheadOptionField); return (this.typeaheadLatinize ? Ia(r) : r).toLowerCase() } tokenizeQuery(n) { let r = n; return this.typeaheadMultipleSearch && this.typeaheadSingleWords ? this.haveCommonCharacters(`${this.typeaheadPhraseDelimiters}${this.typeaheadWordDelimiters}`, this.typeaheadMultipleSearchDelimiters) || (r = dm(r, this.typeaheadWordDelimiters, this.typeaheadPhraseDelimiters, this.typeaheadMultipleSearchDelimiters)) : r = this.typeaheadSingleWords ? dm(r, this.typeaheadWordDelimiters, this.typeaheadPhraseDelimiters) : dm(r, void 0, void 0, this.typeaheadMultipleSearchDelimiters), r } normalizeQuery(n) { let r = (this.typeaheadLatinize ? Ia(n) : n).toString().toLowerCase(); return r = this.tokenizeQuery(r), r } testMatch(n, r) { let i; if ("object" == typeof r) { i = r.length; for (let o = 0; o < i; o += 1)if (r[o].length > 0 && n.indexOf(r[o]) < 0) return !1; return !0 } return n.indexOf(r) >= 0 } finalizeAsyncCall(n) { if (this.prepareMatches(n || []), this.typeaheadLoading.emit(!1), this.typeaheadNoResults.emit(!this.hasMatches()), this.hasMatches()) { if (this.isFocused || !this.cancelRequestOnFocusLost) if (this._container && this.ngControl.control) { const i = ((this.typeaheadLatinize ? Ia(this.ngControl.control.value) : this.ngControl.control.value) || "").toString().toLowerCase(); this._container.query = this.tokenizeQuery(i), this._container.matches = this._matches } else this.show() } else this.hide() } prepareMatches(n) { const r = n.slice(0, this.typeaheadOptionsLimit), i = this.typeaheadOrderBy ? this.orderMatches(r) : r; if (this.typeaheadGroupField) { let o = []; i.map(a => Qi(a, this.typeaheadGroupField)).filter((a, l, c) => c.indexOf(a) === l).forEach(a => { o.push(new Jc(a, a, !0)), o = o.concat(i.filter(l => Qi(l, this.typeaheadGroupField) === a).map(l => new Jc(l, Qi(l, this.typeaheadOptionField)))) }), this._matches = o } else this._matches = i.map(o => new Jc(o, Qi(o, this.typeaheadOptionField))) } orderMatches(n) { if (!n.length) return n; if (null != this.typeaheadOrderBy && "object" == typeof this.typeaheadOrderBy && 0 === Object.keys(this.typeaheadOrderBy).length) return console.error("Field and direction properties for typeaheadOrderBy have to be set according to documentation!"), n; const { field: r, direction: i } = this.typeaheadOrderBy || {}; return !i || "asc" !== i && "desc" !== i ? (console.error('typeaheadOrderBy direction has to equal "asc" or "desc". Please follow the documentation.'), n) : "string" == typeof n[0] ? "asc" === i ? n.sort() : n.sort().reverse() : r && "string" == typeof r ? n.sort((o, s) => { const a = Qi(o, r), l = Qi(s, r); return a < l ? "asc" === i ? -1 : 1 : a > l ? "asc" === i ? 1 : -1 : 0 }) : (console.error("typeaheadOrderBy field has to set according to the documentation."), n) } hasMatches() { return this._matches.length > 0 } checkDelimitersConflict() { if (this.typeaheadMultipleSearch && this.typeaheadSingleWords && this.haveCommonCharacters(`${this.typeaheadPhraseDelimiters}${this.typeaheadWordDelimiters}`, this.typeaheadMultipleSearchDelimiters)) throw new Error(`Delimiters used in typeaheadMultipleSearchDelimiters must be different\n          from delimiters used in typeaheadWordDelimiters (current value: ${this.typeaheadWordDelimiters}) and\n          typeaheadPhraseDelimiters (current value: ${this.typeaheadPhraseDelimiters}).\n          Please refer to the documentation`) } haveCommonCharacters(n, r) { for (let i = 0; i < n.length; i++)if (n.charAt(i).indexOf(r) > -1) return !0; return !1 } } return t.\u0275fac = function (n) { return new (n || t)(T(FD), T(PD), T(ts), T(Tt), T(Fr), T(Qr), T(hr)) }, t.\u0275dir = te({ type: t, selectors: [["", "typeahead", ""]], hostVars: 4, hostBindings: function (n, r) { 1 & n && St("input", function (o) { return r.onInput(o) })("keyup", function (o) { return r.onChange(o) })("click", function () { return r.onFocus() })("focus", function () { return r.onFocus() })("blur", function () { return r.onBlur() })("keydown", function (o) { return r.onKeydown(o) }), 2 & n && mn("aria-activedescendant", r.activeDescendant)("aria-owns", r.isOpen ? r._container.popupId : null)("aria-expanded", r.isOpen)("aria-autocomplete", r.list) }, inputs: { typeahead: "typeahead", typeaheadMinLength: "typeaheadMinLength", adaptivePosition: "adaptivePosition", isAnimated: "isAnimated", typeaheadWaitMs: "typeaheadWaitMs", typeaheadOptionsLimit: "typeaheadOptionsLimit", typeaheadOptionField: "typeaheadOptionField", typeaheadGroupField: "typeaheadGroupField", typeaheadOrderBy: "typeaheadOrderBy", typeaheadAsync: "typeaheadAsync", typeaheadLatinize: "typeaheadLatinize", typeaheadSingleWords: "typeaheadSingleWords", typeaheadWordDelimiters: "typeaheadWordDelimiters", typeaheadMultipleSearch: "typeaheadMultipleSearch", typeaheadMultipleSearchDelimiters: "typeaheadMultipleSearchDelimiters", typeaheadPhraseDelimiters: "typeaheadPhraseDelimiters", typeaheadItemTemplate: "typeaheadItemTemplate", optionsListTemplate: "optionsListTemplate", typeaheadScrollable: "typeaheadScrollable", typeaheadOptionsInScrollableView: "typeaheadOptionsInScrollableView", typeaheadHideResultsOnBlur: "typeaheadHideResultsOnBlur", typeaheadSelectFirstItem: "typeaheadSelectFirstItem", typeaheadIsFirstItemActive: "typeaheadIsFirstItemActive", container: "container", dropup: "dropup" }, outputs: { typeaheadLoading: "typeaheadLoading", typeaheadNoResults: "typeaheadNoResults", typeaheadOnSelect: "typeaheadOnSelect", typeaheadOnPreview: "typeaheadOnPreview", typeaheadOnBlur: "typeaheadOnBlur" }, exportAs: ["bs-typeahead"] }), t })(), dL = (() => { class t { static forRoot() { return { ngModule: t, providers: [FD, cm] } } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Ot({ type: t }), t.\u0275inj = At({ imports: [bc] }), t })(); function fL(t, e) { 1 & t && (Fe(0, "mat-error"), Kt(1, " Please enter a valid email address "), Le()) } function hL(t, e) { 1 & t && (Fe(0, "mat-error"), Kt(1, " Email is "), Fe(2, "strong"), Kt(3, "required"), Le()()) } function mL(t, e) { 1 & t && (Fe(0, "mat-error"), Kt(1, " Password is "), Fe(2, "strong"), Kt(3, "required"), Le()()) } function pL(t, e) { 1 & t && (Fe(0, "mat-error"), Kt(1, " Country is "), Fe(2, "strong"), Kt(3, "required"), Le()()) } let gL = (() => { class t { constructor(n) { this.formBuilder = n, this.countries = ["Afghanistan", "\xc5land Islands", "Albania", "Algeria", "American Samoa", "AndorrA", "Angola", "Anguilla", "Antarctica", "Antigua and Barbuda", "Argentina", "Armenia", "Aruba", "Australia", "Austria", "Azerbaijan", "Bahamas", "Bahrain", "Bangladesh", "Barbados", "Belarus", "Belgium", "Belize", "Benin", "Bermuda", "Bhutan", "Bolivia", "Bosnia and Herzegovina", "Botswana", "Bouvet Island", "Brazil", "British Indian Ocean Territory", "Brunei Darussalam", "Bulgaria", "Burkina Faso", "Burundi", "Cambodia", "Cameroon", "Canada", "Cape Verde", "Cayman Islands", "Central African Republic", "Chad", "Chile", "China", "Christmas Island", "Cocos (Keeling) Islands", "Colombia", "Comoros", "Congo", "Congo, The Democratic Republic of the", "Cook Islands", "Costa Rica", "Cote D'Ivoire", "Croatia", "Cuba", "Cyprus", "Czech Republic", "Denmark", "Djibouti", "Dominica", "Dominican Republic", "Ecuador", "Egypt", "El Salvador", "Equatorial Guinea", "Eritrea", "Estonia", "Ethiopia", "Falkland Islands (Malvinas)", "Faroe Islands", "Fiji", "Finland", "France", "French Guiana", "French Polynesia", "French Southern Territories", "Gabon", "Gambia", "Georgia", "Germany", "Ghana", "Gibraltar", "Greece", "Greenland", "Grenada", "Guadeloupe", "Guam", "Guatemala", "Guernsey", "Guinea", "Guinea-Bissau", "Guyana", "Haiti", "Heard Island and Mcdonald Islands", "Holy See (Vatican City State)", "Honduras", "Hong Kong", "Hungary", "Iceland", "India", "Indonesia", "Iran, Islamic Republic Of", "Iraq", "Ireland", "Isle of Man", "Israel", "Italy", "Jamaica", "Japan", "Jersey", "Jordan", "Kazakhstan", "Kenya", "Kiribati", "Korea, Democratic People'S Republic of", "Korea, Republic of", "Kuwait", "Kyrgyzstan", "Lao People'S Democratic Republic", "Latvia", "Lebanon", "Lesotho", "Liberia", "Libyan Arab Jamahiriya", "Liechtenstein", "Lithuania", "Luxembourg", "Macao", "Macedonia, The Former Yugoslav Republic of", "Madagascar", "Malawi", "Malaysia", "Maldives", "Mali", "Malta", "Marshall Islands", "Martinique", "Mauritania", "Mauritius", "Mayotte", "Mexico", "Micronesia, Federated States of", "Moldova, Republic of", "Monaco", "Mongolia", "Montserrat", "Morocco", "Mozambique", "Myanmar", "Namibia", "Nauru", "Nepal", "Netherlands", "Netherlands Antilles", "New Caledonia", "New Zealand", "Nicaragua", "Niger", "Nigeria", "Niue", "Norfolk Island", "Northern Mariana Islands", "Norway", "Oman", "Pakistan", "Palau", "Palestinian Territory, Occupied", "Panama", "Papua New Guinea", "Paraguay", "Peru", "Philippines", "Pitcairn", "Poland", "Portugal", "Puerto Rico", "Qatar", "Reunion", "Romania", "Russian Federation", "RWANDA", "Saint Helena", "Saint Kitts and Nevis", "Saint Lucia", "Saint Pierre and Miquelon", "Saint Vincent and the Grenadines", "Samoa", "San Marino", "Sao Tome and Principe", "Saudi Arabia", "Senegal", "Serbia and Montenegro", "Seychelles", "Sierra Leone", "Singapore", "Slovakia", "Slovenia", "Solomon Islands", "Somalia", "South Africa", "South Georgia and the South Sandwich Islands", "Spain", "Sri Lanka", "Sudan", "Suriname", "Svalbard and Jan Mayen", "Swaziland", "Sweden", "Switzerland", "Syrian Arab Republic", "Taiwan, Province of China", "Tajikistan", "Tanzania, United Republic of", "Thailand", "Timor-Leste", "Togo", "Tokelau", "Tonga", "Trinidad and Tobago", "Tunisia", "Turkey", "Turkmenistan", "Turks and Caicos Islands", "Tuvalu", "Uganda", "Ukraine", "United Arab Emirates", "United Kingdom", "United States", "United States Minor Outlying Islands", "Uruguay", "Uzbekistan", "Vanuatu", "Venezuela", "Viet Nam", "Virgin Islands, British", "Virgin Islands, U.S.", "Wallis and Futuna", "Western Sahara", "Yemen", "Zambia", "Zimbabwe"], this.submitColor = "unset", this.formSubmitted = new Ye, this.loginForm = this.formBuilder.group({ email: ["", [Mc.required]], password: ["", [Mc.required]], country: ["", [Mc.required]] }) } loginUser() { this.formSubmitted.emit(this.loginForm.value) } } return t.\u0275fac = function (n) { return new (n || t)(T(fO)) }, t.\u0275cmp = uo({ type: t, selectors: [["app-login"]], inputs: { submitColor: "submitColor" }, outputs: { formSubmitted: "formSubmitted" }, decls: 19, vars: 9, consts: [[1, "login-form", 3, "formGroup"], ["appearance", "fill", 1, "full-width"], ["type", "email", "matInput", "", "formControlName", "email", "placeholder", "Ex. pat@example.com"], [4, "ngIf"], ["type", "password", "matInput", "", "formControlName", "password", "placeholder", "Ex. pat@example.com"], ["type", "text", "matInput", "", "formControlName", "country", "placeholder", "Select Country", 3, "typeahead", "isAnimated"], ["mat-flat-button", "", 1, "mt-8", 3, "click"]], template: function (n, r) { if (1 & n && (Fe(0, "form", 0)(1, "mat-form-field", 1)(2, "mat-label"), Kt(3, "Email"), Le(), ur(4, "input", 2), it(5, fL, 2, 0, "mat-error", 3), it(6, hL, 4, 0, "mat-error", 3), Le(), Fe(7, "mat-form-field", 1)(8, "mat-label"), Kt(9, "Password"), Le(), ur(10, "input", 4), it(11, mL, 4, 0, "mat-error", 3), Le(), Fe(12, "mat-form-field", 1)(13, "mat-label"), Kt(14, "Country"), Le(), ur(15, "input", 5), it(16, pL, 4, 0, "mat-error", 3), Le(), Fe(17, "button", 6), St("click", function () { return r.loginUser() }), Kt(18, " Login "), Le()()), 2 & n) { let i, o, s, a; Ae("formGroup", r.loginForm), Qe(5), Ae("ngIf", (null == (i = r.loginForm.get("email")) ? null : i.hasError("email")) && !(null != (i = r.loginForm.get("email")) && i.hasError("required"))), Qe(1), Ae("ngIf", null == (o = r.loginForm.get("email")) ? null : o.hasError("required")), Qe(5), Ae("ngIf", null == (s = r.loginForm.get("password")) ? null : s.hasError("required")), Qe(4), Ae("typeahead", r.countries)("isAnimated", !0), Qe(1), Ae("ngIf", null == (a = r.loginForm.get("password")) ? null : a.hasError("required")), Qe(1), Zs("background-color", r.submitColor) } }, dependencies: [pc, lw, Cc, Gv, qv, ya, Hh, yR, WR, nP, Jh, lP, uL], styles: ['@import"https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/css/bootstrap.min.css";.login-form{min-width:150px;max-width:500px;width:100%}.full-width{width:100%}.d-flex{display:flex;flex-direction:column;width:200px}.mt-8{margin-top:8px}\n', ".mat-badge-content{font-weight:600;font-size:12px;font-family:Roboto,Helvetica Neue,sans-serif}.mat-badge-small .mat-badge-content{font-size:9px}.mat-badge-large .mat-badge-content{font-size:24px}.mat-h1,.mat-headline,.mat-typography .mat-h1,.mat-typography .mat-headline,.mat-typography h1{font:400 24px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h2,.mat-title,.mat-typography .mat-h2,.mat-typography .mat-title,.mat-typography h2{font:500 20px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h3,.mat-subheading-2,.mat-typography .mat-h3,.mat-typography .mat-subheading-2,.mat-typography h3{font:400 16px/28px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h4,.mat-subheading-1,.mat-typography .mat-h4,.mat-typography .mat-subheading-1,.mat-typography h4{font:400 15px/24px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h5,.mat-typography .mat-h5,.mat-typography h5{font:400 11.62px/20px Roboto,Helvetica Neue,sans-serif;margin:0 0 12px}.mat-h6,.mat-typography .mat-h6,.mat-typography h6{font:400 9.38px/20px Roboto,Helvetica Neue,sans-serif;margin:0 0 12px}.mat-body-strong,.mat-body-2,.mat-typography .mat-body-strong,.mat-typography .mat-body-2{font:500 14px/24px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-body,.mat-body-1,.mat-typography .mat-body,.mat-typography .mat-body-1,.mat-typography{font:400 14px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-body p,.mat-body-1 p,.mat-typography .mat-body p,.mat-typography .mat-body-1 p,.mat-typography p{margin:0 0 12px}.mat-small,.mat-caption,.mat-typography .mat-small,.mat-typography .mat-caption{font:400 12px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-display-4,.mat-typography .mat-display-4{font:300 112px/112px Roboto,Helvetica Neue,sans-serif;letter-spacing:-.05em;margin:0 0 56px}.mat-display-3,.mat-typography .mat-display-3{font:400 56px/56px Roboto,Helvetica Neue,sans-serif;letter-spacing:-.02em;margin:0 0 64px}.mat-display-2,.mat-typography .mat-display-2{font:400 45px/48px Roboto,Helvetica Neue,sans-serif;letter-spacing:-.005em;margin:0 0 64px}.mat-display-1,.mat-typography .mat-display-1{font:400 34px/40px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 64px}.mat-bottom-sheet-container{font:400 14px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-button,.mat-raised-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button,.mat-fab,.mat-mini-fab{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px;font-weight:500}.mat-button-toggle,.mat-card{font-family:Roboto,Helvetica Neue,sans-serif}.mat-card-title{font-size:24px;font-weight:500}.mat-card-header .mat-card-title{font-size:20px}.mat-card-subtitle,.mat-card-content{font-size:14px}.mat-checkbox{font-family:Roboto,Helvetica Neue,sans-serif}.mat-checkbox-layout .mat-checkbox-label{line-height:24px}.mat-chip{font-size:14px;font-weight:500}.mat-chip .mat-chip-trailing-icon.mat-icon,.mat-chip .mat-chip-remove.mat-icon{font-size:18px}.mat-table{font-family:Roboto,Helvetica Neue,sans-serif}.mat-header-cell{font-size:12px;font-weight:500}.mat-cell,.mat-footer-cell{font-size:14px}.mat-calendar{font-family:Roboto,Helvetica Neue,sans-serif}.mat-calendar-body{font-size:13px}.mat-calendar-body-label,.mat-calendar-period-button{font-size:14px;font-weight:500}.mat-calendar-table-header th{font-size:11px;font-weight:400}.mat-dialog-title{font:500 20px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-expansion-panel-header{font-family:Roboto,Helvetica Neue,sans-serif;font-size:15px;font-weight:400}.mat-expansion-panel-content{font:400 14px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-form-field{font-size:inherit;font-weight:400;line-height:1.125;font-family:Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-form-field-wrapper{padding-bottom:1.34375em}.mat-form-field-prefix .mat-icon,.mat-form-field-suffix .mat-icon{font-size:150%;line-height:1.125}.mat-form-field-prefix .mat-icon-button,.mat-form-field-suffix .mat-icon-button{height:1.5em;width:1.5em}.mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-suffix .mat-icon-button .mat-icon{height:1.125em;line-height:1.125}.mat-form-field-infix{padding:.5em 0;border-top:.84375em solid rgba(0,0,0,0)}.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.34375em) scale(.75);width:133.3333333333%}.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.34374em) scale(.75);width:133.3333433333%}.mat-form-field-label-wrapper{top:-.84375em;padding-top:.84375em}.mat-form-field-label{top:1.34375em}.mat-form-field-underline{bottom:1.34375em}.mat-form-field-subscript-wrapper{font-size:75%;margin-top:.6666666667em;top:calc(100% - 1.7916666667em)}.mat-form-field-appearance-legacy .mat-form-field-wrapper{padding-bottom:1.25em}.mat-form-field-appearance-legacy .mat-form-field-infix{padding:.4375em 0}.mat-form-field-appearance-legacy.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.001px);width:133.3333333333%}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.00101px);width:133.3333433333%}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.00102px);width:133.3333533333%}.mat-form-field-appearance-legacy .mat-form-field-label{top:1.28125em}.mat-form-field-appearance-legacy .mat-form-field-underline{bottom:1.25em}.mat-form-field-appearance-legacy .mat-form-field-subscript-wrapper{margin-top:.5416666667em;top:calc(100% - 1.6666666667em)}@media print{.mat-form-field-appearance-legacy.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28122em) scale(.75)}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28121em) scale(.75)}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.2812em) scale(.75)}}.mat-form-field-appearance-fill .mat-form-field-infix{padding:.25em 0 .75em}.mat-form-field-appearance-fill .mat-form-field-label{top:1.09375em;margin-top:-.5em}.mat-form-field-appearance-fill.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-fill.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-.59375em) scale(.75);width:133.3333333333%}.mat-form-field-appearance-fill.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-.59374em) scale(.75);width:133.3333433333%}.mat-form-field-appearance-outline .mat-form-field-infix{padding:1em 0}.mat-form-field-appearance-outline .mat-form-field-label{top:1.84375em;margin-top:-.25em}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-outline.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.59375em) scale(.75);width:133.3333333333%}.mat-form-field-appearance-outline.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.59374em) scale(.75);width:133.3333433333%}.mat-grid-tile-header,.mat-grid-tile-footer{font-size:14px}.mat-grid-tile-header .mat-line,.mat-grid-tile-footer .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-grid-tile-header .mat-line:nth-child(n+2),.mat-grid-tile-footer .mat-line:nth-child(n+2){font-size:12px}input.mat-input-element{margin-top:-.0625em}.mat-menu-item{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px;font-weight:400}.mat-paginator,.mat-paginator-page-size .mat-select-trigger{font-family:Roboto,Helvetica Neue,sans-serif;font-size:12px}.mat-radio-button,.mat-select{font-family:Roboto,Helvetica Neue,sans-serif}.mat-select-trigger{height:1.125em}.mat-slide-toggle-content{font-family:Roboto,Helvetica Neue,sans-serif}.mat-slider-thumb-label-text{font-family:Roboto,Helvetica Neue,sans-serif;font-size:12px;font-weight:500}.mat-stepper-vertical,.mat-stepper-horizontal{font-family:Roboto,Helvetica Neue,sans-serif}.mat-step-label{font-size:14px;font-weight:400}.mat-step-sub-label-error{font-weight:400}.mat-step-label-error{font-size:14px}.mat-step-label-selected{font-size:14px;font-weight:500}.mat-tab-group{font-family:Roboto,Helvetica Neue,sans-serif}.mat-tab-label,.mat-tab-link{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px;font-weight:500}.mat-toolbar,.mat-toolbar h1,.mat-toolbar h2,.mat-toolbar h3,.mat-toolbar h4,.mat-toolbar h5,.mat-toolbar h6{font:500 20px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0}.mat-tooltip{font-family:Roboto,Helvetica Neue,sans-serif;font-size:10px;padding-top:6px;padding-bottom:6px}.mat-tooltip-handset{font-size:14px;padding-top:8px;padding-bottom:8px}.mat-list-item,.mat-list-option{font-family:Roboto,Helvetica Neue,sans-serif}.mat-list-base .mat-list-item{font-size:16px}.mat-list-base .mat-list-item .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base .mat-list-item .mat-line:nth-child(n+2){font-size:14px}.mat-list-base .mat-list-option{font-size:16px}.mat-list-base .mat-list-option .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base .mat-list-option .mat-line:nth-child(n+2){font-size:14px}.mat-list-base .mat-subheader{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px;font-weight:500}.mat-list-base[dense] .mat-list-item{font-size:12px}.mat-list-base[dense] .mat-list-item .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base[dense] .mat-list-item .mat-line:nth-child(n+2){font-size:12px}.mat-list-base[dense] .mat-list-option{font-size:12px}.mat-list-base[dense] .mat-list-option .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base[dense] .mat-list-option .mat-line:nth-child(n+2){font-size:12px}.mat-list-base[dense] .mat-subheader{font-family:Roboto,Helvetica Neue,sans-serif;font-size:12px;font-weight:500}.mat-option{font-family:Roboto,Helvetica Neue,sans-serif;font-size:16px}.mat-optgroup-label{font:500 14px/24px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-simple-snackbar{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px}.mat-simple-snackbar-action{line-height:1;font-family:inherit;font-size:inherit;font-weight:500}.mat-tree{font-family:Roboto,Helvetica Neue,sans-serif}.mat-tree-node,.mat-nested-tree-node{font-weight:400;font-size:14px}.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale3d(0,0,0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}.cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:rgba(0,0,0,0);transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:content-box!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:content-box!important;height:0!important}@keyframes cdk-text-field-autofill-start{}@keyframes cdk-text-field-autofill-end{}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator,.mat-mdc-focus-indicator{position:relative}.mat-ripple-element{background-color:#0000001a}.mat-option{color:#000000de}.mat-option:hover:not(.mat-option-disabled),.mat-option:focus:not(.mat-option-disabled){background:rgba(0,0,0,.04)}.mat-option.mat-selected:not(.mat-option-multiple):not(.mat-option-disabled){background:rgba(0,0,0,.04)}.mat-option.mat-active{background:rgba(0,0,0,.04);color:#000000de}.mat-option.mat-option-disabled{color:#00000061}.mat-primary .mat-option.mat-selected:not(.mat-option-disabled){color:#673ab7}.mat-accent .mat-option.mat-selected:not(.mat-option-disabled){color:#ffd740}.mat-warn .mat-option.mat-selected:not(.mat-option-disabled){color:#f44336}.mat-optgroup-label{color:#0000008a}.mat-optgroup-disabled .mat-optgroup-label{color:#00000061}.mat-pseudo-checkbox{color:#0000008a}.mat-pseudo-checkbox:after{color:#fafafa}.mat-pseudo-checkbox-disabled{color:#b0b0b0}.mat-primary .mat-pseudo-checkbox-checked,.mat-primary .mat-pseudo-checkbox-indeterminate{background:#673ab7}.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox-indeterminate,.mat-accent .mat-pseudo-checkbox-checked,.mat-accent .mat-pseudo-checkbox-indeterminate{background:#ffd740}.mat-warn .mat-pseudo-checkbox-checked,.mat-warn .mat-pseudo-checkbox-indeterminate{background:#f44336}.mat-pseudo-checkbox-checked.mat-pseudo-checkbox-disabled,.mat-pseudo-checkbox-indeterminate.mat-pseudo-checkbox-disabled{background:#b0b0b0}.mat-app-background{background-color:#fafafa;color:#000000de}.mat-elevation-z0{box-shadow:0 0 #0003,0 0 #00000024,0 0 #0000001f}.mat-elevation-z1{box-shadow:0 2px 1px -1px #0003,0 1px 1px #00000024,0 1px 3px #0000001f}.mat-elevation-z2{box-shadow:0 3px 1px -2px #0003,0 2px 2px #00000024,0 1px 5px #0000001f}.mat-elevation-z3{box-shadow:0 3px 3px -2px #0003,0 3px 4px #00000024,0 1px 8px #0000001f}.mat-elevation-z4{box-shadow:0 2px 4px -1px #0003,0 4px 5px #00000024,0 1px 10px #0000001f}.mat-elevation-z5{box-shadow:0 3px 5px -1px #0003,0 5px 8px #00000024,0 1px 14px #0000001f}.mat-elevation-z6{box-shadow:0 3px 5px -1px #0003,0 6px 10px #00000024,0 1px 18px #0000001f}.mat-elevation-z7{box-shadow:0 4px 5px -2px #0003,0 7px 10px 1px #00000024,0 2px 16px 1px #0000001f}.mat-elevation-z8{box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f}.mat-elevation-z9{box-shadow:0 5px 6px -3px #0003,0 9px 12px 1px #00000024,0 3px 16px 2px #0000001f}.mat-elevation-z10{box-shadow:0 6px 6px -3px #0003,0 10px 14px 1px #00000024,0 4px 18px 3px #0000001f}.mat-elevation-z11{box-shadow:0 6px 7px -4px #0003,0 11px 15px 1px #00000024,0 4px 20px 3px #0000001f}.mat-elevation-z12{box-shadow:0 7px 8px -4px #0003,0 12px 17px 2px #00000024,0 5px 22px 4px #0000001f}.mat-elevation-z13{box-shadow:0 7px 8px -4px #0003,0 13px 19px 2px #00000024,0 5px 24px 4px #0000001f}.mat-elevation-z14{box-shadow:0 7px 9px -4px #0003,0 14px 21px 2px #00000024,0 5px 26px 4px #0000001f}.mat-elevation-z15{box-shadow:0 8px 9px -5px #0003,0 15px 22px 2px #00000024,0 6px 28px 5px #0000001f}.mat-elevation-z16{box-shadow:0 8px 10px -5px #0003,0 16px 24px 2px #00000024,0 6px 30px 5px #0000001f}.mat-elevation-z17{box-shadow:0 8px 11px -5px #0003,0 17px 26px 2px #00000024,0 6px 32px 5px #0000001f}.mat-elevation-z18{box-shadow:0 9px 11px -5px #0003,0 18px 28px 2px #00000024,0 7px 34px 6px #0000001f}.mat-elevation-z19{box-shadow:0 9px 12px -6px #0003,0 19px 29px 2px #00000024,0 7px 36px 6px #0000001f}.mat-elevation-z20{box-shadow:0 10px 13px -6px #0003,0 20px 31px 3px #00000024,0 8px 38px 7px #0000001f}.mat-elevation-z21{box-shadow:0 10px 13px -6px #0003,0 21px 33px 3px #00000024,0 8px 40px 7px #0000001f}.mat-elevation-z22{box-shadow:0 10px 14px -6px #0003,0 22px 35px 3px #00000024,0 8px 42px 7px #0000001f}.mat-elevation-z23{box-shadow:0 11px 14px -7px #0003,0 23px 36px 3px #00000024,0 9px 44px 8px #0000001f}.mat-elevation-z24{box-shadow:0 11px 15px -7px #0003,0 24px 38px 3px #00000024,0 9px 46px 8px #0000001f}.mat-theme-loaded-marker{display:none}.mat-autocomplete-panel{background:#fff;color:#000000de}.mat-autocomplete-panel:not([class*=mat-elevation-z]){box-shadow:0 2px 4px -1px #0003,0 4px 5px #00000024,0 1px 10px #0000001f}.mat-autocomplete-panel .mat-option.mat-selected:not(.mat-active):not(:hover){background:#fff}.mat-autocomplete-panel .mat-option.mat-selected:not(.mat-active):not(:hover):not(.mat-option-disabled){color:#000000de}.mat-badge{position:relative}.mat-badge.mat-badge{overflow:visible}.mat-badge-hidden .mat-badge-content{display:none}.mat-badge-content{position:absolute;text-align:center;display:inline-block;border-radius:50%;transition:transform .2s ease-in-out;transform:scale(.6);overflow:hidden;white-space:nowrap;text-overflow:ellipsis;pointer-events:none}.ng-animate-disabled .mat-badge-content,.mat-badge-content._mat-animation-noopable{transition:none}.mat-badge-content.mat-badge-active{transform:none}.mat-badge-small .mat-badge-content{width:16px;height:16px;line-height:16px}.mat-badge-small.mat-badge-above .mat-badge-content{top:-8px}.mat-badge-small.mat-badge-below .mat-badge-content{bottom:-8px}.mat-badge-small.mat-badge-before .mat-badge-content{left:-16px}[dir=rtl] .mat-badge-small.mat-badge-before .mat-badge-content{left:auto;right:-16px}.mat-badge-small.mat-badge-after .mat-badge-content{right:-16px}[dir=rtl] .mat-badge-small.mat-badge-after .mat-badge-content{right:auto;left:-16px}.mat-badge-small.mat-badge-overlap.mat-badge-before .mat-badge-content{left:-8px}[dir=rtl] .mat-badge-small.mat-badge-overlap.mat-badge-before .mat-badge-content{left:auto;right:-8px}.mat-badge-small.mat-badge-overlap.mat-badge-after .mat-badge-content{right:-8px}[dir=rtl] .mat-badge-small.mat-badge-overlap.mat-badge-after .mat-badge-content{right:auto;left:-8px}.mat-badge-medium .mat-badge-content{width:22px;height:22px;line-height:22px}.mat-badge-medium.mat-badge-above .mat-badge-content{top:-11px}.mat-badge-medium.mat-badge-below .mat-badge-content{bottom:-11px}.mat-badge-medium.mat-badge-before .mat-badge-content{left:-22px}[dir=rtl] .mat-badge-medium.mat-badge-before .mat-badge-content{left:auto;right:-22px}.mat-badge-medium.mat-badge-after .mat-badge-content{right:-22px}[dir=rtl] .mat-badge-medium.mat-badge-after .mat-badge-content{right:auto;left:-22px}.mat-badge-medium.mat-badge-overlap.mat-badge-before .mat-badge-content{left:-11px}[dir=rtl] .mat-badge-medium.mat-badge-overlap.mat-badge-before .mat-badge-content{left:auto;right:-11px}.mat-badge-medium.mat-badge-overlap.mat-badge-after .mat-badge-content{right:-11px}[dir=rtl] .mat-badge-medium.mat-badge-overlap.mat-badge-after .mat-badge-content{right:auto;left:-11px}.mat-badge-large .mat-badge-content{width:28px;height:28px;line-height:28px}.mat-badge-large.mat-badge-above .mat-badge-content{top:-14px}.mat-badge-large.mat-badge-below .mat-badge-content{bottom:-14px}.mat-badge-large.mat-badge-before .mat-badge-content{left:-28px}[dir=rtl] .mat-badge-large.mat-badge-before .mat-badge-content{left:auto;right:-28px}.mat-badge-large.mat-badge-after .mat-badge-content{right:-28px}[dir=rtl] .mat-badge-large.mat-badge-after .mat-badge-content{right:auto;left:-28px}.mat-badge-large.mat-badge-overlap.mat-badge-before .mat-badge-content{left:-14px}[dir=rtl] .mat-badge-large.mat-badge-overlap.mat-badge-before .mat-badge-content{left:auto;right:-14px}.mat-badge-large.mat-badge-overlap.mat-badge-after .mat-badge-content{right:-14px}[dir=rtl] .mat-badge-large.mat-badge-overlap.mat-badge-after .mat-badge-content{right:auto;left:-14px}.mat-badge-content{color:#fff;background:#673ab7}.cdk-high-contrast-active .mat-badge-content{outline:solid 1px;border-radius:0}.mat-badge-accent .mat-badge-content{background:#ffd740;color:#000000de}.mat-badge-warn .mat-badge-content{color:#fff;background:#f44336}.mat-badge-disabled .mat-badge-content{background:#b9b9b9;color:#00000061}.mat-bottom-sheet-container{box-shadow:0 8px 10px -5px #0003,0 16px 24px 2px #00000024,0 6px 30px 5px #0000001f;background:#fff;color:#000000de}.mat-button,.mat-icon-button,.mat-stroked-button{color:inherit;background:rgba(0,0,0,0)}.mat-button.mat-primary,.mat-icon-button.mat-primary,.mat-stroked-button.mat-primary{color:#673ab7}.mat-button.mat-accent,.mat-icon-button.mat-accent,.mat-stroked-button.mat-accent{color:#ffd740}.mat-button.mat-warn,.mat-icon-button.mat-warn,.mat-stroked-button.mat-warn{color:#f44336}.mat-button.mat-primary.mat-button-disabled,.mat-button.mat-accent.mat-button-disabled,.mat-button.mat-warn.mat-button-disabled,.mat-button.mat-button-disabled.mat-button-disabled,.mat-icon-button.mat-primary.mat-button-disabled,.mat-icon-button.mat-accent.mat-button-disabled,.mat-icon-button.mat-warn.mat-button-disabled,.mat-icon-button.mat-button-disabled.mat-button-disabled,.mat-stroked-button.mat-primary.mat-button-disabled,.mat-stroked-button.mat-accent.mat-button-disabled,.mat-stroked-button.mat-warn.mat-button-disabled,.mat-stroked-button.mat-button-disabled.mat-button-disabled{color:#00000042}.mat-button.mat-primary .mat-button-focus-overlay,.mat-icon-button.mat-primary .mat-button-focus-overlay,.mat-stroked-button.mat-primary .mat-button-focus-overlay{background-color:#673ab7}.mat-button.mat-accent .mat-button-focus-overlay,.mat-icon-button.mat-accent .mat-button-focus-overlay,.mat-stroked-button.mat-accent .mat-button-focus-overlay{background-color:#ffd740}.mat-button.mat-warn .mat-button-focus-overlay,.mat-icon-button.mat-warn .mat-button-focus-overlay,.mat-stroked-button.mat-warn .mat-button-focus-overlay{background-color:#f44336}.mat-button.mat-button-disabled .mat-button-focus-overlay,.mat-icon-button.mat-button-disabled .mat-button-focus-overlay,.mat-stroked-button.mat-button-disabled .mat-button-focus-overlay{background-color:#0000}.mat-button .mat-ripple-element,.mat-icon-button .mat-ripple-element,.mat-stroked-button .mat-ripple-element{opacity:.1;background-color:currentColor}.mat-button-focus-overlay{background:#000}.mat-stroked-button:not(.mat-button-disabled){border-color:#0000001f}.mat-flat-button,.mat-raised-button,.mat-fab,.mat-mini-fab{color:#000000de;background-color:#fff}.mat-flat-button.mat-primary,.mat-raised-button.mat-primary,.mat-fab.mat-primary,.mat-mini-fab.mat-primary{color:#fff}.mat-flat-button.mat-accent,.mat-raised-button.mat-accent,.mat-fab.mat-accent,.mat-mini-fab.mat-accent{color:#000000de}.mat-flat-button.mat-warn,.mat-raised-button.mat-warn,.mat-fab.mat-warn,.mat-mini-fab.mat-warn{color:#fff}.mat-flat-button.mat-primary.mat-button-disabled,.mat-flat-button.mat-accent.mat-button-disabled,.mat-flat-button.mat-warn.mat-button-disabled,.mat-flat-button.mat-button-disabled.mat-button-disabled,.mat-raised-button.mat-primary.mat-button-disabled,.mat-raised-button.mat-accent.mat-button-disabled,.mat-raised-button.mat-warn.mat-button-disabled,.mat-raised-button.mat-button-disabled.mat-button-disabled,.mat-fab.mat-primary.mat-button-disabled,.mat-fab.mat-accent.mat-button-disabled,.mat-fab.mat-warn.mat-button-disabled,.mat-fab.mat-button-disabled.mat-button-disabled,.mat-mini-fab.mat-primary.mat-button-disabled,.mat-mini-fab.mat-accent.mat-button-disabled,.mat-mini-fab.mat-warn.mat-button-disabled,.mat-mini-fab.mat-button-disabled.mat-button-disabled{color:#00000042}.mat-flat-button.mat-primary,.mat-raised-button.mat-primary,.mat-fab.mat-primary,.mat-mini-fab.mat-primary{background-color:#673ab7}.mat-flat-button.mat-accent,.mat-raised-button.mat-accent,.mat-fab.mat-accent,.mat-mini-fab.mat-accent{background-color:#ffd740}.mat-flat-button.mat-warn,.mat-raised-button.mat-warn,.mat-fab.mat-warn,.mat-mini-fab.mat-warn{background-color:#f44336}.mat-flat-button.mat-primary.mat-button-disabled,.mat-flat-button.mat-accent.mat-button-disabled,.mat-flat-button.mat-warn.mat-button-disabled,.mat-flat-button.mat-button-disabled.mat-button-disabled,.mat-raised-button.mat-primary.mat-button-disabled,.mat-raised-button.mat-accent.mat-button-disabled,.mat-raised-button.mat-warn.mat-button-disabled,.mat-raised-button.mat-button-disabled.mat-button-disabled,.mat-fab.mat-primary.mat-button-disabled,.mat-fab.mat-accent.mat-button-disabled,.mat-fab.mat-warn.mat-button-disabled,.mat-fab.mat-button-disabled.mat-button-disabled,.mat-mini-fab.mat-primary.mat-button-disabled,.mat-mini-fab.mat-accent.mat-button-disabled,.mat-mini-fab.mat-warn.mat-button-disabled,.mat-mini-fab.mat-button-disabled.mat-button-disabled{background-color:#0000001f}.mat-flat-button.mat-primary .mat-ripple-element,.mat-raised-button.mat-primary .mat-ripple-element,.mat-fab.mat-primary .mat-ripple-element,.mat-mini-fab.mat-primary .mat-ripple-element{background-color:#ffffff1a}.mat-flat-button.mat-accent .mat-ripple-element,.mat-raised-button.mat-accent .mat-ripple-element,.mat-fab.mat-accent .mat-ripple-element,.mat-mini-fab.mat-accent .mat-ripple-element{background-color:#0000001a}.mat-flat-button.mat-warn .mat-ripple-element,.mat-raised-button.mat-warn .mat-ripple-element,.mat-fab.mat-warn .mat-ripple-element,.mat-mini-fab.mat-warn .mat-ripple-element{background-color:#ffffff1a}.mat-stroked-button:not([class*=mat-elevation-z]),.mat-flat-button:not([class*=mat-elevation-z]){box-shadow:0 0 #0003,0 0 #00000024,0 0 #0000001f}.mat-raised-button:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px #0003,0 2px 2px #00000024,0 1px 5px #0000001f}.mat-raised-button:not(.mat-button-disabled):active:not([class*=mat-elevation-z]){box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f}.mat-raised-button.mat-button-disabled:not([class*=mat-elevation-z]){box-shadow:0 0 #0003,0 0 #00000024,0 0 #0000001f}.mat-fab:not([class*=mat-elevation-z]),.mat-mini-fab:not([class*=mat-elevation-z]){box-shadow:0 3px 5px -1px #0003,0 6px 10px #00000024,0 1px 18px #0000001f}.mat-fab:not(.mat-button-disabled):active:not([class*=mat-elevation-z]),.mat-mini-fab:not(.mat-button-disabled):active:not([class*=mat-elevation-z]){box-shadow:0 7px 8px -4px #0003,0 12px 17px 2px #00000024,0 5px 22px 4px #0000001f}.mat-fab.mat-button-disabled:not([class*=mat-elevation-z]),.mat-mini-fab.mat-button-disabled:not([class*=mat-elevation-z]){box-shadow:0 0 #0003,0 0 #00000024,0 0 #0000001f}.mat-button-toggle-standalone:not([class*=mat-elevation-z]),.mat-button-toggle-group:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px #0003,0 2px 2px #00000024,0 1px 5px #0000001f}.mat-button-toggle-standalone.mat-button-toggle-appearance-standard:not([class*=mat-elevation-z]),.mat-button-toggle-group-appearance-standard:not([class*=mat-elevation-z]){box-shadow:none}.mat-button-toggle{color:#00000061}.mat-button-toggle .mat-button-toggle-focus-overlay{background-color:#0000001f}.mat-button-toggle-appearance-standard{color:#000000de;background:#fff}.mat-button-toggle-appearance-standard .mat-button-toggle-focus-overlay{background-color:#000}.mat-button-toggle-group-appearance-standard .mat-button-toggle+.mat-button-toggle{border-left:solid 1px #e0e0e0}[dir=rtl] .mat-button-toggle-group-appearance-standard .mat-button-toggle+.mat-button-toggle{border-left:none;border-right:solid 1px #e0e0e0}.mat-button-toggle-group-appearance-standard.mat-button-toggle-vertical .mat-button-toggle+.mat-button-toggle{border-left:none;border-right:none;border-top:solid 1px #e0e0e0}.mat-button-toggle-checked{background-color:#e0e0e0;color:#0000008a}.mat-button-toggle-checked.mat-button-toggle-appearance-standard{color:#000000de}.mat-button-toggle-disabled{color:#00000042;background-color:#eee}.mat-button-toggle-disabled.mat-button-toggle-appearance-standard{background:#fff}.mat-button-toggle-disabled.mat-button-toggle-checked{background-color:#bdbdbd}.mat-button-toggle-standalone.mat-button-toggle-appearance-standard,.mat-button-toggle-group-appearance-standard{border:solid 1px #e0e0e0}.mat-button-toggle-appearance-standard .mat-button-toggle-label-content{line-height:48px}.mat-card{background:#fff;color:#000000de}.mat-card:not([class*=mat-elevation-z]){box-shadow:0 2px 1px -1px #0003,0 1px 1px #00000024,0 1px 3px #0000001f}.mat-card.mat-card-flat:not([class*=mat-elevation-z]){box-shadow:0 0 #0003,0 0 #00000024,0 0 #0000001f}.mat-card-subtitle{color:#0000008a}.mat-checkbox-frame{border-color:#0000008a}.mat-checkbox-checkmark{fill:#fafafa}.mat-checkbox-checkmark-path{stroke:#fafafa!important}.mat-checkbox-mixedmark{background-color:#fafafa}.mat-checkbox-indeterminate.mat-primary .mat-checkbox-background,.mat-checkbox-checked.mat-primary .mat-checkbox-background{background-color:#673ab7}.mat-checkbox-indeterminate.mat-accent .mat-checkbox-background,.mat-checkbox-checked.mat-accent .mat-checkbox-background{background-color:#ffd740}.mat-checkbox-indeterminate.mat-warn .mat-checkbox-background,.mat-checkbox-checked.mat-warn .mat-checkbox-background{background-color:#f44336}.mat-checkbox-disabled.mat-checkbox-checked .mat-checkbox-background,.mat-checkbox-disabled.mat-checkbox-indeterminate .mat-checkbox-background{background-color:#b0b0b0}.mat-checkbox-disabled:not(.mat-checkbox-checked) .mat-checkbox-frame{border-color:#b0b0b0}.mat-checkbox-disabled .mat-checkbox-label{color:#00000061}.mat-checkbox .mat-ripple-element{background-color:#000}.mat-checkbox-checked:not(.mat-checkbox-disabled).mat-primary .mat-ripple-element,.mat-checkbox:active:not(.mat-checkbox-disabled).mat-primary .mat-ripple-element{background:#673ab7}.mat-checkbox-checked:not(.mat-checkbox-disabled).mat-accent .mat-ripple-element,.mat-checkbox:active:not(.mat-checkbox-disabled).mat-accent .mat-ripple-element{background:#ffd740}.mat-checkbox-checked:not(.mat-checkbox-disabled).mat-warn .mat-ripple-element,.mat-checkbox:active:not(.mat-checkbox-disabled).mat-warn .mat-ripple-element{background:#f44336}.mat-chip.mat-standard-chip{background-color:#e0e0e0;color:#000000de}.mat-chip.mat-standard-chip .mat-chip-remove{color:#000000de;opacity:.4}.mat-chip.mat-standard-chip:not(.mat-chip-disabled):active{box-shadow:0 3px 3px -2px #0003,0 3px 4px #00000024,0 1px 8px #0000001f}.mat-chip.mat-standard-chip:not(.mat-chip-disabled) .mat-chip-remove:hover{opacity:.54}.mat-chip.mat-standard-chip.mat-chip-disabled{opacity:.4}.mat-chip.mat-standard-chip:after{background:#000}.mat-chip.mat-standard-chip.mat-chip-selected.mat-primary{background-color:#673ab7;color:#fff}.mat-chip.mat-standard-chip.mat-chip-selected.mat-primary .mat-chip-remove{color:#fff;opacity:.4}.mat-chip.mat-standard-chip.mat-chip-selected.mat-primary .mat-ripple-element{background-color:#ffffff1a}.mat-chip.mat-standard-chip.mat-chip-selected.mat-warn{background-color:#f44336;color:#fff}.mat-chip.mat-standard-chip.mat-chip-selected.mat-warn .mat-chip-remove{color:#fff;opacity:.4}.mat-chip.mat-standard-chip.mat-chip-selected.mat-warn .mat-ripple-element{background-color:#ffffff1a}.mat-chip.mat-standard-chip.mat-chip-selected.mat-accent{background-color:#ffd740;color:#000000de}.mat-chip.mat-standard-chip.mat-chip-selected.mat-accent .mat-chip-remove{color:#000000de;opacity:.4}.mat-chip.mat-standard-chip.mat-chip-selected.mat-accent .mat-ripple-element{background-color:#0000001a}.mat-table{background:#fff}.mat-table thead,.mat-table tbody,.mat-table tfoot,mat-header-row,mat-row,mat-footer-row,[mat-header-row],[mat-row],[mat-footer-row],.mat-table-sticky{background:inherit}mat-row,mat-header-row,mat-footer-row,th.mat-header-cell,td.mat-cell,td.mat-footer-cell{border-bottom-color:#0000001f}.mat-header-cell{color:#0000008a}.mat-cell,.mat-footer-cell{color:#000000de}.mat-calendar-arrow{fill:#0000008a}.mat-datepicker-toggle,.mat-datepicker-content .mat-calendar-next-button,.mat-datepicker-content .mat-calendar-previous-button{color:#0000008a}.mat-calendar-table-header-divider:after{background:rgba(0,0,0,.12)}.mat-calendar-table-header,.mat-calendar-body-label{color:#0000008a}.mat-calendar-body-cell-content,.mat-date-range-input-separator{color:#000000de;border-color:#0000}.mat-calendar-body-disabled>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){color:#00000061}.mat-form-field-disabled .mat-date-range-input-separator{color:#00000061}.mat-calendar-body-in-preview{color:#0000003d}.mat-calendar-body-today:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){border-color:#00000061}.mat-calendar-body-disabled>.mat-calendar-body-today:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){border-color:#0000002e}.mat-calendar-body-in-range:before{background:rgba(103,58,183,.2)}.mat-calendar-body-comparison-identical,.mat-calendar-body-in-comparison-range:before{background:rgba(249,171,0,.2)}.mat-calendar-body-comparison-bridge-start:before,[dir=rtl] .mat-calendar-body-comparison-bridge-end:before{background:linear-gradient(to right,rgba(103,58,183,.2) 50%,rgba(249,171,0,.2) 50%)}.mat-calendar-body-comparison-bridge-end:before,[dir=rtl] .mat-calendar-body-comparison-bridge-start:before{background:linear-gradient(to left,rgba(103,58,183,.2) 50%,rgba(249,171,0,.2) 50%)}.mat-calendar-body-in-range>.mat-calendar-body-comparison-identical,.mat-calendar-body-in-comparison-range.mat-calendar-body-in-range:after{background:#a8dab5}.mat-calendar-body-comparison-identical.mat-calendar-body-selected,.mat-calendar-body-in-comparison-range>.mat-calendar-body-selected{background:#46a35e}.mat-calendar-body-selected{background-color:#673ab7;color:#fff}.mat-calendar-body-disabled>.mat-calendar-body-selected{background-color:#673ab766}.mat-calendar-body-today.mat-calendar-body-selected{box-shadow:inset 0 0 0 1px #fff}.cdk-keyboard-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.cdk-program-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:#673ab74d}@media (hover: hover){.mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:#673ab74d}}.mat-datepicker-content{box-shadow:0 2px 4px -1px #0003,0 4px 5px #00000024,0 1px 10px #0000001f;background-color:#fff;color:#000000de}.mat-datepicker-content.mat-accent .mat-calendar-body-in-range:before{background:rgba(255,215,64,.2)}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-identical,.mat-datepicker-content.mat-accent .mat-calendar-body-in-comparison-range:before{background:rgba(249,171,0,.2)}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-bridge-start:before,.mat-datepicker-content.mat-accent [dir=rtl] .mat-calendar-body-comparison-bridge-end:before{background:linear-gradient(to right,rgba(255,215,64,.2) 50%,rgba(249,171,0,.2) 50%)}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-bridge-end:before,.mat-datepicker-content.mat-accent [dir=rtl] .mat-calendar-body-comparison-bridge-start:before{background:linear-gradient(to left,rgba(255,215,64,.2) 50%,rgba(249,171,0,.2) 50%)}.mat-datepicker-content.mat-accent .mat-calendar-body-in-range>.mat-calendar-body-comparison-identical,.mat-datepicker-content.mat-accent .mat-calendar-body-in-comparison-range.mat-calendar-body-in-range:after{background:#a8dab5}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-identical.mat-calendar-body-selected,.mat-datepicker-content.mat-accent .mat-calendar-body-in-comparison-range>.mat-calendar-body-selected{background:#46a35e}.mat-datepicker-content.mat-accent .mat-calendar-body-selected{background-color:#ffd740;color:#000000de}.mat-datepicker-content.mat-accent .mat-calendar-body-disabled>.mat-calendar-body-selected{background-color:#ffd74066}.mat-datepicker-content.mat-accent .mat-calendar-body-today.mat-calendar-body-selected{box-shadow:inset 0 0 0 1px #000000de}.mat-datepicker-content.mat-accent .cdk-keyboard-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-datepicker-content.mat-accent .cdk-program-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:#ffd7404d}@media (hover: hover){.mat-datepicker-content.mat-accent .mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:#ffd7404d}}.mat-datepicker-content.mat-warn .mat-calendar-body-in-range:before{background:rgba(244,67,54,.2)}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-identical,.mat-datepicker-content.mat-warn .mat-calendar-body-in-comparison-range:before{background:rgba(249,171,0,.2)}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-bridge-start:before,.mat-datepicker-content.mat-warn [dir=rtl] .mat-calendar-body-comparison-bridge-end:before{background:linear-gradient(to right,rgba(244,67,54,.2) 50%,rgba(249,171,0,.2) 50%)}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-bridge-end:before,.mat-datepicker-content.mat-warn [dir=rtl] .mat-calendar-body-comparison-bridge-start:before{background:linear-gradient(to left,rgba(244,67,54,.2) 50%,rgba(249,171,0,.2) 50%)}.mat-datepicker-content.mat-warn .mat-calendar-body-in-range>.mat-calendar-body-comparison-identical,.mat-datepicker-content.mat-warn .mat-calendar-body-in-comparison-range.mat-calendar-body-in-range:after{background:#a8dab5}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-identical.mat-calendar-body-selected,.mat-datepicker-content.mat-warn .mat-calendar-body-in-comparison-range>.mat-calendar-body-selected{background:#46a35e}.mat-datepicker-content.mat-warn .mat-calendar-body-selected{background-color:#f44336;color:#fff}.mat-datepicker-content.mat-warn .mat-calendar-body-disabled>.mat-calendar-body-selected{background-color:#f4433666}.mat-datepicker-content.mat-warn .mat-calendar-body-today.mat-calendar-body-selected{box-shadow:inset 0 0 0 1px #fff}.mat-datepicker-content.mat-warn .cdk-keyboard-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-datepicker-content.mat-warn .cdk-program-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:#f443364d}@media (hover: hover){.mat-datepicker-content.mat-warn .mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:#f443364d}}.mat-datepicker-content-touch{box-shadow:0 11px 15px -7px #0003,0 24px 38px 3px #00000024,0 9px 46px 8px #0000001f}.mat-datepicker-toggle-active{color:#673ab7}.mat-datepicker-toggle-active.mat-accent{color:#ffd740}.mat-datepicker-toggle-active.mat-warn{color:#f44336}.mat-date-range-input-inner[disabled]{color:#00000061}.mat-dialog-container{box-shadow:0 11px 15px -7px #0003,0 24px 38px 3px #00000024,0 9px 46px 8px #0000001f;background:#fff;color:#000000de}.mat-divider{border-top-color:#0000001f}.mat-divider-vertical{border-right-color:#0000001f}.mat-expansion-panel{background:#fff;color:#000000de}.mat-expansion-panel:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px #0003,0 2px 2px #00000024,0 1px 5px #0000001f}.mat-action-row{border-top-color:#0000001f}.mat-expansion-panel .mat-expansion-panel-header.cdk-keyboard-focused:not([aria-disabled=true]),.mat-expansion-panel .mat-expansion-panel-header.cdk-program-focused:not([aria-disabled=true]),.mat-expansion-panel:not(.mat-expanded) .mat-expansion-panel-header:hover:not([aria-disabled=true]){background:rgba(0,0,0,.04)}@media (hover: none){.mat-expansion-panel:not(.mat-expanded):not([aria-disabled=true]) .mat-expansion-panel-header:hover{background:#fff}}.mat-expansion-panel-header-title{color:#000000de}.mat-expansion-panel-header-description,.mat-expansion-indicator:after{color:#0000008a}.mat-expansion-panel-header[aria-disabled=true]{color:#00000042}.mat-expansion-panel-header[aria-disabled=true] .mat-expansion-panel-header-title,.mat-expansion-panel-header[aria-disabled=true] .mat-expansion-panel-header-description{color:inherit}.mat-expansion-panel-header{height:48px}.mat-expansion-panel-header.mat-expanded{height:64px}.mat-form-field-label,.mat-hint{color:#0009}.mat-form-field.mat-focused .mat-form-field-label{color:#673ab7}.mat-form-field.mat-focused .mat-form-field-label.mat-accent{color:#ffd740}.mat-form-field.mat-focused .mat-form-field-label.mat-warn{color:#f44336}.mat-focused .mat-form-field-required-marker{color:#ffd740}.mat-form-field-ripple{background-color:#000000de}.mat-form-field.mat-focused .mat-form-field-ripple{background-color:#673ab7}.mat-form-field.mat-focused .mat-form-field-ripple.mat-accent{background-color:#ffd740}.mat-form-field.mat-focused .mat-form-field-ripple.mat-warn{background-color:#f44336}.mat-form-field-type-mat-native-select.mat-focused:not(.mat-form-field-invalid) .mat-form-field-infix:after{color:#673ab7}.mat-form-field-type-mat-native-select.mat-focused:not(.mat-form-field-invalid).mat-accent .mat-form-field-infix:after{color:#ffd740}.mat-form-field-type-mat-native-select.mat-focused:not(.mat-form-field-invalid).mat-warn .mat-form-field-infix:after{color:#f44336}.mat-form-field.mat-form-field-invalid .mat-form-field-label,.mat-form-field.mat-form-field-invalid .mat-form-field-label.mat-accent,.mat-form-field.mat-form-field-invalid .mat-form-field-label .mat-form-field-required-marker{color:#f44336}.mat-form-field.mat-form-field-invalid .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple.mat-accent{background-color:#f44336}.mat-error{color:#f44336}.mat-form-field-appearance-legacy .mat-form-field-label,.mat-form-field-appearance-legacy .mat-hint{color:#0000008a}.mat-form-field-appearance-legacy .mat-form-field-underline{background-color:#0000006b}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-image:linear-gradient(to right,rgba(0,0,0,.42) 0%,rgba(0,0,0,.42) 33%,transparent 0%);background-size:4px 100%;background-repeat:repeat-x}.mat-form-field-appearance-standard .mat-form-field-underline{background-color:#0000006b}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-image:linear-gradient(to right,rgba(0,0,0,.42) 0%,rgba(0,0,0,.42) 33%,transparent 0%);background-size:4px 100%;background-repeat:repeat-x}.mat-form-field-appearance-fill .mat-form-field-flex{background-color:#0000000a}.mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-flex{background-color:#00000005}.mat-form-field-appearance-fill .mat-form-field-underline:before{background-color:#0000006b}.mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-label{color:#00000061}.mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-underline:before{background-color:#0000}.mat-form-field-appearance-outline .mat-form-field-outline{color:#0000001f}.mat-form-field-appearance-outline .mat-form-field-outline-thick{color:#000000de}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick{color:#673ab7}.mat-form-field-appearance-outline.mat-focused.mat-accent .mat-form-field-outline-thick{color:#ffd740}.mat-form-field-appearance-outline.mat-focused.mat-warn .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid.mat-form-field-invalid .mat-form-field-outline-thick{color:#f44336}.mat-form-field-appearance-outline.mat-form-field-disabled .mat-form-field-label{color:#00000061}.mat-form-field-appearance-outline.mat-form-field-disabled .mat-form-field-outline{color:#0000000f}.mat-icon.mat-primary{color:#673ab7}.mat-icon.mat-accent{color:#ffd740}.mat-icon.mat-warn{color:#f44336}.mat-form-field-type-mat-native-select .mat-form-field-infix:after{color:#0000008a}.mat-input-element:disabled,.mat-form-field-type-mat-native-select.mat-form-field-disabled .mat-form-field-infix:after{color:#00000061}.mat-input-element{caret-color:#673ab7}.mat-input-element::placeholder{color:#0000006b}.mat-input-element::-moz-placeholder{color:#0000006b}.mat-input-element::-webkit-input-placeholder{color:#0000006b}.mat-input-element:-ms-input-placeholder{color:#0000006b}.mat-form-field.mat-accent .mat-input-element{caret-color:#ffd740}.mat-form-field.mat-warn .mat-input-element,.mat-form-field-invalid .mat-input-element{caret-color:#f44336}.mat-form-field-type-mat-native-select.mat-form-field-invalid .mat-form-field-infix:after{color:#f44336}.mat-list-base .mat-list-item,.mat-list-base .mat-list-option{color:#000000de}.mat-list-base .mat-subheader{color:#0000008a}.mat-list-base .mat-list-item-disabled{background-color:#eee;color:#00000061}.mat-list-option:hover,.mat-list-option:focus,.mat-nav-list .mat-list-item:hover,.mat-nav-list .mat-list-item:focus,.mat-action-list .mat-list-item:hover,.mat-action-list .mat-list-item:focus{background:rgba(0,0,0,.04)}.mat-list-single-selected-option,.mat-list-single-selected-option:hover,.mat-list-single-selected-option:focus{background:rgba(0,0,0,.12)}.mat-menu-panel{background:#fff}.mat-menu-panel:not([class*=mat-elevation-z]){box-shadow:0 2px 4px -1px #0003,0 4px 5px #00000024,0 1px 10px #0000001f}.mat-menu-item{background:rgba(0,0,0,0);color:#000000de}.mat-menu-item[disabled],.mat-menu-item[disabled] .mat-menu-submenu-icon,.mat-menu-item[disabled] .mat-icon-no-color{color:#00000061}.mat-menu-item .mat-icon-no-color,.mat-menu-submenu-icon{color:#0000008a}.mat-menu-item:hover:not([disabled]),.mat-menu-item.cdk-program-focused:not([disabled]),.mat-menu-item.cdk-keyboard-focused:not([disabled]),.mat-menu-item-highlighted:not([disabled]){background:rgba(0,0,0,.04)}.mat-paginator{background:#fff}.mat-paginator,.mat-paginator-page-size .mat-select-trigger{color:#0000008a}.mat-paginator-decrement,.mat-paginator-increment{border-top:2px solid rgba(0,0,0,.54);border-right:2px solid rgba(0,0,0,.54)}.mat-paginator-first,.mat-paginator-last{border-top:2px solid rgba(0,0,0,.54)}.mat-icon-button[disabled] .mat-paginator-decrement,.mat-icon-button[disabled] .mat-paginator-increment,.mat-icon-button[disabled] .mat-paginator-first,.mat-icon-button[disabled] .mat-paginator-last{border-color:#00000061}.mat-paginator-container{min-height:56px}.mat-progress-bar-background{fill:#d5cae9}.mat-progress-bar-buffer{background-color:#d5cae9}.mat-progress-bar-fill:after{background-color:#673ab7}.mat-progress-bar.mat-accent .mat-progress-bar-background{fill:#fbf1cc}.mat-progress-bar.mat-accent .mat-progress-bar-buffer{background-color:#fbf1cc}.mat-progress-bar.mat-accent .mat-progress-bar-fill:after{background-color:#ffd740}.mat-progress-bar.mat-warn .mat-progress-bar-background{fill:#f9ccc9}.mat-progress-bar.mat-warn .mat-progress-bar-buffer{background-color:#f9ccc9}.mat-progress-bar.mat-warn .mat-progress-bar-fill:after{background-color:#f44336}.mat-progress-spinner circle,.mat-spinner circle{stroke:#673ab7}.mat-progress-spinner.mat-accent circle,.mat-spinner.mat-accent circle{stroke:#ffd740}.mat-progress-spinner.mat-warn circle,.mat-spinner.mat-warn circle{stroke:#f44336}.mat-radio-outer-circle{border-color:#0000008a}.mat-radio-button.mat-primary.mat-radio-checked .mat-radio-outer-circle{border-color:#673ab7}.mat-radio-button.mat-primary .mat-radio-inner-circle,.mat-radio-button.mat-primary .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple),.mat-radio-button.mat-primary.mat-radio-checked .mat-radio-persistent-ripple,.mat-radio-button.mat-primary:active .mat-radio-persistent-ripple{background-color:#673ab7}.mat-radio-button.mat-accent.mat-radio-checked .mat-radio-outer-circle{border-color:#ffd740}.mat-radio-button.mat-accent .mat-radio-inner-circle,.mat-radio-button.mat-accent .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple),.mat-radio-button.mat-accent.mat-radio-checked .mat-radio-persistent-ripple,.mat-radio-button.mat-accent:active .mat-radio-persistent-ripple{background-color:#ffd740}.mat-radio-button.mat-warn.mat-radio-checked .mat-radio-outer-circle{border-color:#f44336}.mat-radio-button.mat-warn .mat-radio-inner-circle,.mat-radio-button.mat-warn .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple),.mat-radio-button.mat-warn.mat-radio-checked .mat-radio-persistent-ripple,.mat-radio-button.mat-warn:active .mat-radio-persistent-ripple{background-color:#f44336}.mat-radio-button.mat-radio-disabled.mat-radio-checked .mat-radio-outer-circle,.mat-radio-button.mat-radio-disabled .mat-radio-outer-circle{border-color:#00000061}.mat-radio-button.mat-radio-disabled .mat-radio-ripple .mat-ripple-element,.mat-radio-button.mat-radio-disabled .mat-radio-inner-circle{background-color:#00000061}.mat-radio-button.mat-radio-disabled .mat-radio-label-content{color:#00000061}.mat-radio-button .mat-ripple-element{background-color:#000}.mat-select-value{color:#000000de}.mat-select-placeholder{color:#0000006b}.mat-select-disabled .mat-select-value{color:#00000061}.mat-select-arrow{color:#0000008a}.mat-select-panel{background:#fff}.mat-select-panel:not([class*=mat-elevation-z]){box-shadow:0 2px 4px -1px #0003,0 4px 5px #00000024,0 1px 10px #0000001f}.mat-select-panel .mat-option.mat-selected:not(.mat-option-multiple){background:rgba(0,0,0,.12)}.mat-form-field.mat-focused.mat-primary .mat-select-arrow{color:#673ab7}.mat-form-field.mat-focused.mat-accent .mat-select-arrow{color:#ffd740}.mat-form-field.mat-focused.mat-warn .mat-select-arrow,.mat-form-field .mat-select.mat-select-invalid .mat-select-arrow{color:#f44336}.mat-form-field .mat-select.mat-select-disabled .mat-select-arrow{color:#00000061}.mat-drawer-container{background-color:#fafafa;color:#000000de}.mat-drawer{background-color:#fff;color:#000000de}.mat-drawer.mat-drawer-push{background-color:#fff}.mat-drawer:not(.mat-drawer-side){box-shadow:0 8px 10px -5px #0003,0 16px 24px 2px #00000024,0 6px 30px 5px #0000001f}.mat-drawer-side{border-right:solid 1px rgba(0,0,0,.12)}.mat-drawer-side.mat-drawer-end,[dir=rtl] .mat-drawer-side{border-left:solid 1px rgba(0,0,0,.12);border-right:none}[dir=rtl] .mat-drawer-side.mat-drawer-end{border-left:none;border-right:solid 1px rgba(0,0,0,.12)}.mat-drawer-backdrop.mat-drawer-shown{background-color:#0009}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb{background-color:#ffd740}.mat-slide-toggle.mat-checked .mat-slide-toggle-bar{background-color:#ffd7408a}.mat-slide-toggle.mat-checked .mat-ripple-element{background-color:#ffd740}.mat-slide-toggle.mat-primary.mat-checked .mat-slide-toggle-thumb{background-color:#673ab7}.mat-slide-toggle.mat-primary.mat-checked .mat-slide-toggle-bar{background-color:#673ab78a}.mat-slide-toggle.mat-primary.mat-checked .mat-ripple-element{background-color:#673ab7}.mat-slide-toggle.mat-warn.mat-checked .mat-slide-toggle-thumb{background-color:#f44336}.mat-slide-toggle.mat-warn.mat-checked .mat-slide-toggle-bar{background-color:#f443368a}.mat-slide-toggle.mat-warn.mat-checked .mat-ripple-element{background-color:#f44336}.mat-slide-toggle:not(.mat-checked) .mat-ripple-element{background-color:#000}.mat-slide-toggle-thumb{box-shadow:0 2px 1px -1px #0003,0 1px 1px #00000024,0 1px 3px #0000001f;background-color:#fafafa}.mat-slide-toggle-bar{background-color:#00000061}.mat-slider-track-background{background-color:#00000042}.mat-slider.mat-primary .mat-slider-track-fill,.mat-slider.mat-primary .mat-slider-thumb,.mat-slider.mat-primary .mat-slider-thumb-label{background-color:#673ab7}.mat-slider.mat-primary .mat-slider-thumb-label-text{color:#fff}.mat-slider.mat-primary .mat-slider-focus-ring{background-color:#673ab733}.mat-slider.mat-accent .mat-slider-track-fill,.mat-slider.mat-accent .mat-slider-thumb,.mat-slider.mat-accent .mat-slider-thumb-label{background-color:#ffd740}.mat-slider.mat-accent .mat-slider-thumb-label-text{color:#000000de}.mat-slider.mat-accent .mat-slider-focus-ring{background-color:#ffd74033}.mat-slider.mat-warn .mat-slider-track-fill,.mat-slider.mat-warn .mat-slider-thumb,.mat-slider.mat-warn .mat-slider-thumb-label{background-color:#f44336}.mat-slider.mat-warn .mat-slider-thumb-label-text{color:#fff}.mat-slider.mat-warn .mat-slider-focus-ring{background-color:#f4433633}.mat-slider:hover .mat-slider-track-background,.mat-slider.cdk-focused .mat-slider-track-background{background-color:#00000061}.mat-slider.mat-slider-disabled .mat-slider-track-background,.mat-slider.mat-slider-disabled .mat-slider-track-fill,.mat-slider.mat-slider-disabled .mat-slider-thumb,.mat-slider.mat-slider-disabled:hover .mat-slider-track-background{background-color:#00000042}.mat-slider.mat-slider-min-value .mat-slider-focus-ring{background-color:#0000001f}.mat-slider.mat-slider-min-value.mat-slider-thumb-label-showing .mat-slider-thumb,.mat-slider.mat-slider-min-value.mat-slider-thumb-label-showing .mat-slider-thumb-label{background-color:#000000de}.mat-slider.mat-slider-min-value.mat-slider-thumb-label-showing.cdk-focused .mat-slider-thumb,.mat-slider.mat-slider-min-value.mat-slider-thumb-label-showing.cdk-focused .mat-slider-thumb-label{background-color:#00000042}.mat-slider.mat-slider-min-value:not(.mat-slider-thumb-label-showing) .mat-slider-thumb{border-color:#00000042;background-color:#0000}.mat-slider.mat-slider-min-value:not(.mat-slider-thumb-label-showing):hover .mat-slider-thumb,.mat-slider.mat-slider-min-value:not(.mat-slider-thumb-label-showing).cdk-focused .mat-slider-thumb{border-color:#00000061}.mat-slider.mat-slider-min-value:not(.mat-slider-thumb-label-showing):hover.mat-slider-disabled .mat-slider-thumb,.mat-slider.mat-slider-min-value:not(.mat-slider-thumb-label-showing).cdk-focused.mat-slider-disabled .mat-slider-thumb{border-color:#00000042}.mat-slider-has-ticks .mat-slider-wrapper:after{border-color:#000000b3}.mat-slider-horizontal .mat-slider-ticks{background-image:repeating-linear-gradient(to right,rgba(0,0,0,.7),rgba(0,0,0,.7) 2px,transparent 0,transparent);background-image:-moz-repeating-linear-gradient(.0001deg,rgba(0,0,0,.7),rgba(0,0,0,.7) 2px,transparent 0,transparent)}.mat-slider-vertical .mat-slider-ticks{background-image:repeating-linear-gradient(to bottom,rgba(0,0,0,.7),rgba(0,0,0,.7) 2px,transparent 0,transparent)}.mat-step-header.cdk-keyboard-focused,.mat-step-header.cdk-program-focused,.mat-step-header:hover:not([aria-disabled]),.mat-step-header:hover[aria-disabled=false]{background-color:#0000000a}.mat-step-header:hover[aria-disabled=true]{cursor:default}@media (hover: none){.mat-step-header:hover{background:none}}.mat-step-header .mat-step-label,.mat-step-header .mat-step-optional{color:#0000008a}.mat-step-header .mat-step-icon{background-color:#0000008a;color:#fff}.mat-step-header .mat-step-icon-selected,.mat-step-header .mat-step-icon-state-done,.mat-step-header .mat-step-icon-state-edit{background-color:#673ab7;color:#fff}.mat-step-header.mat-accent .mat-step-icon{color:#000000de}.mat-step-header.mat-accent .mat-step-icon-selected,.mat-step-header.mat-accent .mat-step-icon-state-done,.mat-step-header.mat-accent .mat-step-icon-state-edit{background-color:#ffd740;color:#000000de}.mat-step-header.mat-warn .mat-step-icon{color:#fff}.mat-step-header.mat-warn .mat-step-icon-selected,.mat-step-header.mat-warn .mat-step-icon-state-done,.mat-step-header.mat-warn .mat-step-icon-state-edit{background-color:#f44336;color:#fff}.mat-step-header .mat-step-icon-state-error{background-color:#0000;color:#f44336}.mat-step-header .mat-step-label.mat-step-label-active{color:#000000de}.mat-step-header .mat-step-label.mat-step-label-error{color:#f44336}.mat-stepper-horizontal,.mat-stepper-vertical{background-color:#fff}.mat-stepper-vertical-line:before{border-left-color:#0000001f}.mat-horizontal-stepper-header:before,.mat-horizontal-stepper-header:after,.mat-stepper-horizontal-line{border-top-color:#0000001f}.mat-horizontal-stepper-header{height:72px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header,.mat-vertical-stepper-header{padding:24px}.mat-stepper-vertical-line:before{top:-16px;bottom:-16px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:after,.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:before{top:36px}.mat-stepper-label-position-bottom .mat-stepper-horizontal-line{top:36px}.mat-sort-header-arrow{color:#757575}.mat-tab-nav-bar,.mat-tab-header{border-bottom:1px solid rgba(0,0,0,.12)}.mat-tab-group-inverted-header .mat-tab-nav-bar,.mat-tab-group-inverted-header .mat-tab-header{border-top:1px solid rgba(0,0,0,.12);border-bottom:none}.mat-tab-label,.mat-tab-link{color:#000000de}.mat-tab-label.mat-tab-disabled,.mat-tab-link.mat-tab-disabled{color:#00000061}.mat-tab-header-pagination-chevron{border-color:#000000de}.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#00000061}.mat-tab-group[class*=mat-background-]>.mat-tab-header,.mat-tab-nav-bar[class*=mat-background-]{border-bottom:none;border-top:none}.mat-tab-group.mat-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#d1c4e94d}.mat-tab-group.mat-primary .mat-ink-bar,.mat-tab-nav-bar.mat-primary .mat-ink-bar{background-color:#673ab7}.mat-tab-group.mat-primary.mat-background-primary>.mat-tab-header .mat-ink-bar,.mat-tab-group.mat-primary.mat-background-primary>.mat-tab-link-container .mat-ink-bar,.mat-tab-nav-bar.mat-primary.mat-background-primary>.mat-tab-header .mat-ink-bar,.mat-tab-nav-bar.mat-primary.mat-background-primary>.mat-tab-link-container .mat-ink-bar{background-color:#fff}.mat-tab-group.mat-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ffe57f4d}.mat-tab-group.mat-accent .mat-ink-bar,.mat-tab-nav-bar.mat-accent .mat-ink-bar{background-color:#ffd740}.mat-tab-group.mat-accent.mat-background-accent>.mat-tab-header .mat-ink-bar,.mat-tab-group.mat-accent.mat-background-accent>.mat-tab-link-container .mat-ink-bar,.mat-tab-nav-bar.mat-accent.mat-background-accent>.mat-tab-header .mat-ink-bar,.mat-tab-nav-bar.mat-accent.mat-background-accent>.mat-tab-link-container .mat-ink-bar{background-color:#000000de}.mat-tab-group.mat-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ffcdd24d}.mat-tab-group.mat-warn .mat-ink-bar,.mat-tab-nav-bar.mat-warn .mat-ink-bar{background-color:#f44336}.mat-tab-group.mat-warn.mat-background-warn>.mat-tab-header .mat-ink-bar,.mat-tab-group.mat-warn.mat-background-warn>.mat-tab-link-container .mat-ink-bar,.mat-tab-nav-bar.mat-warn.mat-background-warn>.mat-tab-header .mat-ink-bar,.mat-tab-nav-bar.mat-warn.mat-background-warn>.mat-tab-link-container .mat-ink-bar{background-color:#fff}.mat-tab-group.mat-background-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#d1c4e94d}.mat-tab-group.mat-background-primary>.mat-tab-header,.mat-tab-group.mat-background-primary>.mat-tab-link-container,.mat-tab-group.mat-background-primary>.mat-tab-header-pagination,.mat-tab-nav-bar.mat-background-primary>.mat-tab-header,.mat-tab-nav-bar.mat-background-primary>.mat-tab-link-container,.mat-tab-nav-bar.mat-background-primary>.mat-tab-header-pagination{background-color:#673ab7}.mat-tab-group.mat-background-primary>.mat-tab-header .mat-tab-label,.mat-tab-group.mat-background-primary>.mat-tab-link-container .mat-tab-link,.mat-tab-nav-bar.mat-background-primary>.mat-tab-header .mat-tab-label,.mat-tab-nav-bar.mat-background-primary>.mat-tab-link-container .mat-tab-link{color:#fff}.mat-tab-group.mat-background-primary>.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-group.mat-background-primary>.mat-tab-link-container .mat-tab-link.mat-tab-disabled,.mat-tab-nav-bar.mat-background-primary>.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-nav-bar.mat-background-primary>.mat-tab-link-container .mat-tab-link.mat-tab-disabled{color:#fff6}.mat-tab-group.mat-background-primary>.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-primary>.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-primary>.mat-tab-link-container .mat-focus-indicator:before,.mat-tab-group.mat-background-primary>.mat-tab-header .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-primary>.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary>.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary>.mat-tab-link-container .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-primary>.mat-tab-header .mat-focus-indicator:before{border-color:#fff}.mat-tab-group.mat-background-primary>.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-primary>.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary>.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary>.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#fff;opacity:.4}.mat-tab-group.mat-background-primary>.mat-tab-header .mat-ripple-element,.mat-tab-group.mat-background-primary>.mat-tab-link-container .mat-ripple-element,.mat-tab-group.mat-background-primary>.mat-tab-header-pagination .mat-ripple-element,.mat-tab-nav-bar.mat-background-primary>.mat-tab-header .mat-ripple-element,.mat-tab-nav-bar.mat-background-primary>.mat-tab-link-container .mat-ripple-element,.mat-tab-nav-bar.mat-background-primary>.mat-tab-header-pagination .mat-ripple-element{background-color:#fff;opacity:.12}.mat-tab-group.mat-background-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ffe57f4d}.mat-tab-group.mat-background-accent>.mat-tab-header,.mat-tab-group.mat-background-accent>.mat-tab-link-container,.mat-tab-group.mat-background-accent>.mat-tab-header-pagination,.mat-tab-nav-bar.mat-background-accent>.mat-tab-header,.mat-tab-nav-bar.mat-background-accent>.mat-tab-link-container,.mat-tab-nav-bar.mat-background-accent>.mat-tab-header-pagination{background-color:#ffd740}.mat-tab-group.mat-background-accent>.mat-tab-header .mat-tab-label,.mat-tab-group.mat-background-accent>.mat-tab-link-container .mat-tab-link,.mat-tab-nav-bar.mat-background-accent>.mat-tab-header .mat-tab-label,.mat-tab-nav-bar.mat-background-accent>.mat-tab-link-container .mat-tab-link{color:#000000de}.mat-tab-group.mat-background-accent>.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-group.mat-background-accent>.mat-tab-link-container .mat-tab-link.mat-tab-disabled,.mat-tab-nav-bar.mat-background-accent>.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-nav-bar.mat-background-accent>.mat-tab-link-container .mat-tab-link.mat-tab-disabled{color:#0006}.mat-tab-group.mat-background-accent>.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-accent>.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-accent>.mat-tab-link-container .mat-focus-indicator:before,.mat-tab-group.mat-background-accent>.mat-tab-header .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-accent>.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent>.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent>.mat-tab-link-container .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-accent>.mat-tab-header .mat-focus-indicator:before{border-color:#000000de}.mat-tab-group.mat-background-accent>.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-accent>.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent>.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent>.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#000;opacity:.4}.mat-tab-group.mat-background-accent>.mat-tab-header .mat-ripple-element,.mat-tab-group.mat-background-accent>.mat-tab-link-container .mat-ripple-element,.mat-tab-group.mat-background-accent>.mat-tab-header-pagination .mat-ripple-element,.mat-tab-nav-bar.mat-background-accent>.mat-tab-header .mat-ripple-element,.mat-tab-nav-bar.mat-background-accent>.mat-tab-link-container .mat-ripple-element,.mat-tab-nav-bar.mat-background-accent>.mat-tab-header-pagination .mat-ripple-element{background-color:#000;opacity:.12}.mat-tab-group.mat-background-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ffcdd24d}.mat-tab-group.mat-background-warn>.mat-tab-header,.mat-tab-group.mat-background-warn>.mat-tab-link-container,.mat-tab-group.mat-background-warn>.mat-tab-header-pagination,.mat-tab-nav-bar.mat-background-warn>.mat-tab-header,.mat-tab-nav-bar.mat-background-warn>.mat-tab-link-container,.mat-tab-nav-bar.mat-background-warn>.mat-tab-header-pagination{background-color:#f44336}.mat-tab-group.mat-background-warn>.mat-tab-header .mat-tab-label,.mat-tab-group.mat-background-warn>.mat-tab-link-container .mat-tab-link,.mat-tab-nav-bar.mat-background-warn>.mat-tab-header .mat-tab-label,.mat-tab-nav-bar.mat-background-warn>.mat-tab-link-container .mat-tab-link{color:#fff}.mat-tab-group.mat-background-warn>.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-group.mat-background-warn>.mat-tab-link-container .mat-tab-link.mat-tab-disabled,.mat-tab-nav-bar.mat-background-warn>.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-nav-bar.mat-background-warn>.mat-tab-link-container .mat-tab-link.mat-tab-disabled{color:#fff6}.mat-tab-group.mat-background-warn>.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-warn>.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-warn>.mat-tab-link-container .mat-focus-indicator:before,.mat-tab-group.mat-background-warn>.mat-tab-header .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-warn>.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn>.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn>.mat-tab-link-container .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-warn>.mat-tab-header .mat-focus-indicator:before{border-color:#fff}.mat-tab-group.mat-background-warn>.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-warn>.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn>.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn>.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#fff;opacity:.4}.mat-tab-group.mat-background-warn>.mat-tab-header .mat-ripple-element,.mat-tab-group.mat-background-warn>.mat-tab-link-container .mat-ripple-element,.mat-tab-group.mat-background-warn>.mat-tab-header-pagination .mat-ripple-element,.mat-tab-nav-bar.mat-background-warn>.mat-tab-header .mat-ripple-element,.mat-tab-nav-bar.mat-background-warn>.mat-tab-link-container .mat-ripple-element,.mat-tab-nav-bar.mat-background-warn>.mat-tab-header-pagination .mat-ripple-element{background-color:#fff;opacity:.12}.mat-toolbar{background:#f5f5f5;color:#000000de}.mat-toolbar.mat-primary{background:#673ab7;color:#fff}.mat-toolbar.mat-accent{background:#ffd740;color:#000000de}.mat-toolbar.mat-warn{background:#f44336;color:#fff}.mat-toolbar .mat-form-field-underline,.mat-toolbar .mat-form-field-ripple,.mat-toolbar .mat-focused .mat-form-field-ripple{background-color:currentColor}.mat-toolbar .mat-form-field-label,.mat-toolbar .mat-focused .mat-form-field-label,.mat-toolbar .mat-select-value,.mat-toolbar .mat-select-arrow,.mat-toolbar .mat-form-field.mat-focused .mat-select-arrow{color:inherit}.mat-toolbar .mat-input-element{caret-color:currentColor}.mat-toolbar-multiple-rows{min-height:64px}.mat-toolbar-row,.mat-toolbar-single-row{height:64px}@media (max-width: 599px){.mat-toolbar-multiple-rows{min-height:56px}.mat-toolbar-row,.mat-toolbar-single-row{height:56px}}.mat-tooltip{background:rgba(97,97,97,.9)}.mat-tree{background:#fff}.mat-tree-node,.mat-nested-tree-node{color:#000000de}.mat-tree-node{min-height:48px}.mat-snack-bar-container{color:#ffffffb3;background:#323232;box-shadow:0 3px 5px -1px #0003,0 6px 10px #00000024,0 1px 18px #0000001f}.mat-simple-snackbar-action{color:#ffd740}html,body{height:100%}body{margin:0;font-family:Roboto,Helvetica Neue,sans-serif}\n"], encapsulation: 3 }), t })(), bL = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Ot({ type: t }), t.\u0275inj = At({ imports: [bc, xw, _R, cP, em, dO, dL.forRoot()] }), t })(); const Ne = !1; function LD(t) { return new P(3e3, Ne) } function XL() { return typeof window < "u" && typeof window.document < "u" } function fm() { return typeof process < "u" && "[object process]" === {}.toString.call(process) } function _i(t) { switch (t.length) { case 0: return new Ma; case 1: return t[0]; default: return new cD(t) } } function VD(t, e, n, r, i = new Map, o = new Map) { const s = [], a = []; let l = -1, c = null; if (r.forEach(u => { const d = u.get("offset"), f = d == l, h = f && c || new Map; u.forEach((m, b) => { let w = b, C = m; if ("offset" !== b) switch (w = e.normalizePropertyName(w, s), C) { case "!": C = i.get(b); break; case Xr: C = o.get(b); break; default: C = e.normalizeStyleValue(b, w, C, s) }h.set(w, C) }), f || a.push(h), c = h, l = d }), s.length) throw function HL(t) { return new P(3502, Ne) }(); return a } function hm(t, e, n, r) { switch (e) { case "start": t.onStart(() => r(n && mm(n, "start", t))); break; case "done": t.onDone(() => r(n && mm(n, "done", t))); break; case "destroy": t.onDestroy(() => r(n && mm(n, "destroy", t))) } } function mm(t, e, n) { const o = pm(t.element, t.triggerName, t.fromState, t.toState, e || t.phaseName, n.totalTime ?? t.totalTime, !!n.disabled), s = t._data; return null != s && (o._data = s), o } function pm(t, e, n, r, i = "", o = 0, s) { return { element: t, triggerName: e, fromState: n, toState: r, phaseName: i, totalTime: o, disabled: !!s } } function Rn(t, e, n) { let r = t.get(e); return r || t.set(e, r = n), r } function BD(t) { const e = t.indexOf(":"); return [t.substring(1, e), t.slice(e + 1)] } let gm = (t, e) => !1, HD = (t, e, n) => [], jD = null; function bm(t) { const e = t.parentNode || t.host; return e === jD ? null : e } (fm() || typeof Element < "u") && (XL() ? (jD = (() => document.documentElement)(), gm = (t, e) => { for (; e;) { if (e === t) return !0; e = bm(e) } return !1 }) : gm = (t, e) => t.contains(e), HD = (t, e, n) => { if (n) return Array.from(t.querySelectorAll(e)); const r = t.querySelector(e); return r ? [r] : [] }); let Yi = null, $D = !1; const zD = gm, UD = HD; let GD = (() => { class t { validateStyleProperty(n) { return function eV(t) { Yi || (Yi = function tV() { return typeof document < "u" ? document.body : null }() || {}, $D = !!Yi.style && "WebkitAppearance" in Yi.style); let e = !0; return Yi.style && !function JL(t) { return "ebkit" == t.substring(1, 6) }(t) && (e = t in Yi.style, !e && $D && (e = "Webkit" + t.charAt(0).toUpperCase() + t.slice(1) in Yi.style)), e }(n) } matchesElement(n, r) { return !1 } containsElement(n, r) { return zD(n, r) } getParentElement(n) { return bm(n) } query(n, r, i) { return UD(n, r, i) } computeStyle(n, r, i) { return i || "" } animate(n, r, i, o, s, a = [], l) { return new Ma(i, o) } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac }), t })(), ym = (() => { class t { } return t.NOOP = new GD, t })(); const _m = "ng-enter", tu = "ng-leave", nu = "ng-trigger", ru = ".ng-trigger", WD = "ng-animating", vm = ".ng-animating"; function vi(t) { if ("number" == typeof t) return t; const e = t.match(/^(-?[\.\d]+)(m?s)/); return !e || e.length < 2 ? 0 : wm(parseFloat(e[1]), e[2]) } function wm(t, e) { return "s" === e ? 1e3 * t : t } function iu(t, e, n) { return t.hasOwnProperty("duration") ? t : function iV(t, e, n) { let i, o = 0, s = ""; if ("string" == typeof t) { const a = t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i); if (null === a) return e.push(LD()), { duration: 0, delay: 0, easing: "" }; i = wm(parseFloat(a[1]), a[2]); const l = a[3]; null != l && (o = wm(parseFloat(l), a[4])); const c = a[5]; c && (s = c) } else i = t; if (!n) { let a = !1, l = e.length; i < 0 && (e.push(function yL() { return new P(3100, Ne) }()), a = !0), o < 0 && (e.push(function _L() { return new P(3101, Ne) }()), a = !0), a && e.splice(l, 0, LD()) } return { duration: i, delay: o, easing: s } }(t, e, n) } function Fa(t, e = {}) { return Object.keys(t).forEach(n => { e[n] = t[n] }), e } function ZD(t) { const e = new Map; return Object.keys(t).forEach(n => { e.set(n, t[n]) }), e } function wi(t, e = new Map, n) { if (n) for (let [r, i] of n) e.set(r, i); for (let [r, i] of t) e.set(r, i); return e } function QD(t, e, n) { return n ? e + ":" + n + ";" : "" } function YD(t) { let e = ""; for (let n = 0; n < t.style.length; n++) { const r = t.style.item(n); e += QD(0, r, t.style.getPropertyValue(r)) } for (const n in t.style) t.style.hasOwnProperty(n) && !n.startsWith("_") && (e += QD(0, lV(n), t.style[n])); t.setAttribute("style", e) } function Nr(t, e, n) { t.style && (e.forEach((r, i) => { const o = Em(i); n && !n.has(i) && n.set(i, t.style[o]), t.style[o] = r }), fm() && YD(t)) } function Xi(t, e) { t.style && (e.forEach((n, r) => { const i = Em(r); t.style[i] = "" }), fm() && YD(t)) } function Na(t) { return Array.isArray(t) ? 1 == t.length ? t[0] : aD(t) : t } const Dm = new RegExp("{{\\s*(.+?)\\s*}}", "g"); function XD(t) { let e = []; if ("string" == typeof t) { let n; for (; n = Dm.exec(t);)e.push(n[1]); Dm.lastIndex = 0 } return e } function ou(t, e, n) { const r = t.toString(), i = r.replace(Dm, (o, s) => { let a = e[s]; return null == a && (n.push(function wL(t) { return new P(3003, Ne) }()), a = ""), a.toString() }); return i == r ? t : i } function su(t) { const e = []; let n = t.next(); for (; !n.done;)e.push(n.value), n = t.next(); return e } const aV = /-+([a-z0-9])/g; function Em(t) { return t.replace(aV, (...e) => e[1].toUpperCase()) } function lV(t) { return t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() } function Pn(t, e, n) { switch (e.type) { case 7: return t.visitTrigger(e, n); case 0: return t.visitState(e, n); case 1: return t.visitTransition(e, n); case 2: return t.visitSequence(e, n); case 3: return t.visitGroup(e, n); case 4: return t.visitAnimate(e, n); case 5: return t.visitKeyframes(e, n); case 6: return t.visitStyle(e, n); case 8: return t.visitReference(e, n); case 9: return t.visitAnimateChild(e, n); case 10: return t.visitAnimateRef(e, n); case 11: return t.visitQuery(e, n); case 12: return t.visitStagger(e, n); default: throw function DL(t) { return new P(3004, Ne) }() } } function JD(t, e) { return window.getComputedStyle(t)[e] } function mV(t, e) { const n = []; return "string" == typeof t ? t.split(/\s*,\s*/).forEach(r => function pV(t, e, n) { if (":" == t[0]) { const l = function gV(t, e) { switch (t) { case ":enter": return "void => *"; case ":leave": return "* => void"; case ":increment": return (n, r) => parseFloat(r) > parseFloat(n); case ":decrement": return (n, r) => parseFloat(r) < parseFloat(n); default: return e.push(function PL(t) { return new P(3016, Ne) }()), "* => *" } }(t, n); if ("function" == typeof l) return void e.push(l); t = l } const r = t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/); if (null == r || r.length < 4) return n.push(function RL(t) { return new P(3015, Ne) }()), e; const i = r[1], o = r[2], s = r[3]; e.push(eE(i, s)); "<" == o[0] && !("*" == i && "*" == s) && e.push(eE(s, i)) }(r, n, e)) : n.push(t), n } const uu = new Set(["true", "1"]), du = new Set(["false", "0"]); function eE(t, e) { const n = uu.has(t) || du.has(t), r = uu.has(e) || du.has(e); return (i, o) => { let s = "*" == t || t == i, a = "*" == e || e == o; return !s && n && "boolean" == typeof i && (s = i ? uu.has(t) : du.has(t)), !a && r && "boolean" == typeof o && (a = o ? uu.has(e) : du.has(e)), s && a } } const bV = new RegExp("s*:selfs*,?", "g"); function Cm(t, e, n, r) { return new yV(t).build(e, n, r) } class yV { constructor(e) { this._driver = e } build(e, n, r) { const i = new wV(n); return this._resetContextStyleTimingState(i), Pn(this, Na(e), i) } _resetContextStyleTimingState(e) { e.currentQuerySelector = "", e.collectedStyles = new Map, e.collectedStyles.set("", new Map), e.currentTime = 0 } visitTrigger(e, n) { let r = n.queryCount = 0, i = n.depCount = 0; const o = [], s = []; return "@" == e.name.charAt(0) && n.errors.push(function CL() { return new P(3006, Ne) }()), e.definitions.forEach(a => { if (this._resetContextStyleTimingState(n), 0 == a.type) { const l = a, c = l.name; c.toString().split(/\s*,\s*/).forEach(u => { l.name = u, o.push(this.visitState(l, n)) }), l.name = c } else if (1 == a.type) { const l = this.visitTransition(a, n); r += l.queryCount, i += l.depCount, s.push(l) } else n.errors.push(function ML() { return new P(3007, Ne) }()) }), { type: 7, name: e.name, states: o, transitions: s, queryCount: r, depCount: i, options: null } } visitState(e, n) { const r = this.visitStyle(e.styles, n), i = e.options && e.options.params || null; if (r.containsDynamicStyles) { const o = new Set, s = i || {}; r.styles.forEach(a => { a instanceof Map && a.forEach(l => { XD(l).forEach(c => { s.hasOwnProperty(c) || o.add(c) }) }) }), o.size && (su(o.values()), n.errors.push(function TL(t, e) { return new P(3008, Ne) }())) } return { type: 0, name: e.name, style: r, options: i ? { params: i } : null } } visitTransition(e, n) { n.queryCount = 0, n.depCount = 0; const r = Pn(this, Na(e.animation), n); return { type: 1, matchers: mV(e.expr, n.errors), animation: r, queryCount: n.queryCount, depCount: n.depCount, options: Ji(e.options) } } visitSequence(e, n) { return { type: 2, steps: e.steps.map(r => Pn(this, r, n)), options: Ji(e.options) } } visitGroup(e, n) { const r = n.currentTime; let i = 0; const o = e.steps.map(s => { n.currentTime = r; const a = Pn(this, s, n); return i = Math.max(i, n.currentTime), a }); return n.currentTime = i, { type: 3, steps: o, options: Ji(e.options) } } visitAnimate(e, n) { const r = function EV(t, e) { if (t.hasOwnProperty("duration")) return t; if ("number" == typeof t) return Mm(iu(t, e).duration, 0, ""); const n = t; if (n.split(/\s+/).some(o => "{" == o.charAt(0) && "{" == o.charAt(1))) { const o = Mm(0, 0, ""); return o.dynamic = !0, o.strValue = n, o } const i = iu(n, e); return Mm(i.duration, i.delay, i.easing) }(e.timings, n.errors); n.currentAnimateTimings = r; let i, o = e.styles ? e.styles : yi({}); if (5 == o.type) i = this.visitKeyframes(o, n); else { let s = e.styles, a = !1; if (!s) { a = !0; const c = {}; r.easing && (c.easing = r.easing), s = yi(c) } n.currentTime += r.duration + r.delay; const l = this.visitStyle(s, n); l.isEmptyStep = a, i = l } return n.currentAnimateTimings = null, { type: 4, timings: r, style: i, options: null } } visitStyle(e, n) { const r = this._makeStyleAst(e, n); return this._validateStyleAst(r, n), r } _makeStyleAst(e, n) { const r = [], i = Array.isArray(e.styles) ? e.styles : [e.styles]; for (let a of i) "string" == typeof a ? a === Xr ? r.push(a) : n.errors.push(new P(3002, Ne)) : r.push(ZD(a)); let o = !1, s = null; return r.forEach(a => { if (a instanceof Map && (a.has("easing") && (s = a.get("easing"), a.delete("easing")), !o)) for (let l of a.values()) if (l.toString().indexOf("{{") >= 0) { o = !0; break } }), { type: 6, styles: r, easing: s, offset: e.offset, containsDynamicStyles: o, options: null } } _validateStyleAst(e, n) { const r = n.currentAnimateTimings; let i = n.currentTime, o = n.currentTime; r && o > 0 && (o -= r.duration + r.delay), e.styles.forEach(s => { "string" != typeof s && s.forEach((a, l) => { const c = n.collectedStyles.get(n.currentQuerySelector), u = c.get(l); let d = !0; u && (o != i && o >= u.startTime && i <= u.endTime && (n.errors.push(function kL(t, e, n, r, i) { return new P(3010, Ne) }()), d = !1), o = u.startTime), d && c.set(l, { startTime: o, endTime: i }), n.options && function sV(t, e, n) { const r = e.params || {}, i = XD(t); i.length && i.forEach(o => { r.hasOwnProperty(o) || n.push(function vL(t) { return new P(3001, Ne) }()) }) }(a, n.options, n.errors) }) }) } visitKeyframes(e, n) { const r = { type: 5, styles: [], options: null }; if (!n.currentAnimateTimings) return n.errors.push(function AL() { return new P(3011, Ne) }()), r; let o = 0; const s = []; let a = !1, l = !1, c = 0; const u = e.steps.map(C => { const I = this._makeStyleAst(C, n); let E = null != I.offset ? I.offset : function DV(t) { if ("string" == typeof t) return null; let e = null; if (Array.isArray(t)) t.forEach(n => { if (n instanceof Map && n.has("offset")) { const r = n; e = parseFloat(r.get("offset")), r.delete("offset") } }); else if (t instanceof Map && t.has("offset")) { const n = t; e = parseFloat(n.get("offset")), n.delete("offset") } return e }(I.styles), R = 0; return null != E && (o++, R = I.offset = E), l = l || R < 0 || R > 1, a = a || R < c, c = R, s.push(R), I }); l && n.errors.push(function SL() { return new P(3012, Ne) }()), a && n.errors.push(function IL() { return new P(3200, Ne) }()); const d = e.steps.length; let f = 0; o > 0 && o < d ? n.errors.push(function FL() { return new P(3202, Ne) }()) : 0 == o && (f = 1 / (d - 1)); const h = d - 1, m = n.currentTime, b = n.currentAnimateTimings, w = b.duration; return u.forEach((C, I) => { const E = f > 0 ? I == h ? 1 : f * I : s[I], R = E * w; n.currentTime = m + b.delay + R, b.duration = R, this._validateStyleAst(C, n), C.offset = E, r.styles.push(C) }), r } visitReference(e, n) { return { type: 8, animation: Pn(this, Na(e.animation), n), options: Ji(e.options) } } visitAnimateChild(e, n) { return n.depCount++, { type: 9, options: Ji(e.options) } } visitAnimateRef(e, n) { return { type: 10, animation: this.visitReference(e.animation, n), options: Ji(e.options) } } visitQuery(e, n) { const r = n.currentQuerySelector, i = e.options || {}; n.queryCount++, n.currentQuery = e; const [o, s] = function _V(t) { const e = !!t.split(/\s*,\s*/).find(n => ":self" == n); return e && (t = t.replace(bV, "")), t = t.replace(/@\*/g, ru).replace(/@\w+/g, n => ru + "-" + n.slice(1)).replace(/:animating/g, vm), [t, e] }(e.selector); n.currentQuerySelector = r.length ? r + " " + o : o, Rn(n.collectedStyles, n.currentQuerySelector, new Map); const a = Pn(this, Na(e.animation), n); return n.currentQuery = null, n.currentQuerySelector = r, { type: 11, selector: o, limit: i.limit || 0, optional: !!i.optional, includeSelf: s, animation: a, originalSelector: e.selector, options: Ji(e.options) } } visitStagger(e, n) { n.currentQuery || n.errors.push(function NL() { return new P(3013, Ne) }()); const r = "full" === e.timings ? { duration: 0, delay: 0, easing: "full" } : iu(e.timings, n.errors, !0); return { type: 12, animation: Pn(this, Na(e.animation), n), timings: r, options: null } } } class wV { constructor(e) { this.errors = e, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = new Map, this.options = null, this.unsupportedCSSPropertiesFound = new Set, this.nonAnimatableCSSPropertiesFound = new Set } } function Ji(t) { return t ? (t = Fa(t)).params && (t.params = function vV(t) { return t ? Fa(t) : null }(t.params)) : t = {}, t } function Mm(t, e, n) { return { duration: t, delay: e, easing: n } } function Tm(t, e, n, r, i, o, s = null, a = !1) { return { type: 1, element: t, keyframes: e, preStyleProps: n, postStyleProps: r, duration: i, delay: o, totalTime: i + o, easing: s, subTimeline: a } } class fu { constructor() { this._map = new Map } get(e) { return this._map.get(e) || [] } append(e, n) { let r = this._map.get(e); r || this._map.set(e, r = []), r.push(...n) } has(e) { return this._map.has(e) } clear() { this._map.clear() } } const TV = new RegExp(":enter", "g"), kV = new RegExp(":leave", "g"); function xm(t, e, n, r, i, o = new Map, s = new Map, a, l, c = []) { return (new AV).buildKeyframes(t, e, n, r, i, o, s, a, l, c) } class AV { buildKeyframes(e, n, r, i, o, s, a, l, c, u = []) { c = c || new fu; const d = new km(e, n, c, i, o, u, []); d.options = l; const f = l.delay ? vi(l.delay) : 0; d.currentTimeline.delayNextStep(f), d.currentTimeline.setStyles([s], null, d.errors, l), Pn(this, r, d); const h = d.timelines.filter(m => m.containsAnimation()); if (h.length && a.size) { let m; for (let b = h.length - 1; b >= 0; b--) { const w = h[b]; if (w.element === n) { m = w; break } } m && !m.allowOnlyTimelineStyles() && m.setStyles([a], null, d.errors, l) } return h.length ? h.map(m => m.buildKeyframes()) : [Tm(n, [], [], [], 0, f, "", !1)] } visitTrigger(e, n) { } visitState(e, n) { } visitTransition(e, n) { } visitAnimateChild(e, n) { const r = n.subInstructions.get(n.element); if (r) { const i = n.createSubContext(e.options), o = n.currentTimeline.currentTime, s = this._visitSubInstructions(r, i, i.options); o != s && n.transformIntoNewTimeline(s) } n.previousNode = e } visitAnimateRef(e, n) { const r = n.createSubContext(e.options); r.transformIntoNewTimeline(), this.visitReference(e.animation, r), n.transformIntoNewTimeline(r.currentTimeline.currentTime), n.previousNode = e } _visitSubInstructions(e, n, r) { let o = n.currentTimeline.currentTime; const s = null != r.duration ? vi(r.duration) : null, a = null != r.delay ? vi(r.delay) : null; return 0 !== s && e.forEach(l => { const c = n.appendInstructionToTimeline(l, s, a); o = Math.max(o, c.duration + c.delay) }), o } visitReference(e, n) { n.updateOptions(e.options, !0), Pn(this, e.animation, n), n.previousNode = e } visitSequence(e, n) { const r = n.subContextCount; let i = n; const o = e.options; if (o && (o.params || o.delay) && (i = n.createSubContext(o), i.transformIntoNewTimeline(), null != o.delay)) { 6 == i.previousNode.type && (i.currentTimeline.snapshotCurrentStyles(), i.previousNode = hu); const s = vi(o.delay); i.delayNextStep(s) } e.steps.length && (e.steps.forEach(s => Pn(this, s, i)), i.currentTimeline.applyStylesToKeyframe(), i.subContextCount > r && i.transformIntoNewTimeline()), n.previousNode = e } visitGroup(e, n) { const r = []; let i = n.currentTimeline.currentTime; const o = e.options && e.options.delay ? vi(e.options.delay) : 0; e.steps.forEach(s => { const a = n.createSubContext(e.options); o && a.delayNextStep(o), Pn(this, s, a), i = Math.max(i, a.currentTimeline.currentTime), r.push(a.currentTimeline) }), r.forEach(s => n.currentTimeline.mergeTimelineCollectedStyles(s)), n.transformIntoNewTimeline(i), n.previousNode = e } _visitTiming(e, n) { if (e.dynamic) { const r = e.strValue; return iu(n.params ? ou(r, n.params, n.errors) : r, n.errors) } return { duration: e.duration, delay: e.delay, easing: e.easing } } visitAnimate(e, n) { const r = n.currentAnimateTimings = this._visitTiming(e.timings, n), i = n.currentTimeline; r.delay && (n.incrementTime(r.delay), i.snapshotCurrentStyles()); const o = e.style; 5 == o.type ? this.visitKeyframes(o, n) : (n.incrementTime(r.duration), this.visitStyle(o, n), i.applyStylesToKeyframe()), n.currentAnimateTimings = null, n.previousNode = e } visitStyle(e, n) { const r = n.currentTimeline, i = n.currentAnimateTimings; !i && r.hasCurrentStyleProperties() && r.forwardFrame(); const o = i && i.easing || e.easing; e.isEmptyStep ? r.applyEmptyStep(o) : r.setStyles(e.styles, o, n.errors, n.options), n.previousNode = e } visitKeyframes(e, n) { const r = n.currentAnimateTimings, i = n.currentTimeline.duration, o = r.duration, a = n.createSubContext().currentTimeline; a.easing = r.easing, e.styles.forEach(l => { a.forwardTime((l.offset || 0) * o), a.setStyles(l.styles, l.easing, n.errors, n.options), a.applyStylesToKeyframe() }), n.currentTimeline.mergeTimelineCollectedStyles(a), n.transformIntoNewTimeline(i + o), n.previousNode = e } visitQuery(e, n) { const r = n.currentTimeline.currentTime, i = e.options || {}, o = i.delay ? vi(i.delay) : 0; o && (6 === n.previousNode.type || 0 == r && n.currentTimeline.hasCurrentStyleProperties()) && (n.currentTimeline.snapshotCurrentStyles(), n.previousNode = hu); let s = r; const a = n.invokeQuery(e.selector, e.originalSelector, e.limit, e.includeSelf, !!i.optional, n.errors); n.currentQueryTotal = a.length; let l = null; a.forEach((c, u) => { n.currentQueryIndex = u; const d = n.createSubContext(e.options, c); o && d.delayNextStep(o), c === n.element && (l = d.currentTimeline), Pn(this, e.animation, d), d.currentTimeline.applyStylesToKeyframe(), s = Math.max(s, d.currentTimeline.currentTime) }), n.currentQueryIndex = 0, n.currentQueryTotal = 0, n.transformIntoNewTimeline(s), l && (n.currentTimeline.mergeTimelineCollectedStyles(l), n.currentTimeline.snapshotCurrentStyles()), n.previousNode = e } visitStagger(e, n) { const r = n.parentContext, i = n.currentTimeline, o = e.timings, s = Math.abs(o.duration), a = s * (n.currentQueryTotal - 1); let l = s * n.currentQueryIndex; switch (o.duration < 0 ? "reverse" : o.easing) { case "reverse": l = a - l; break; case "full": l = r.currentStaggerTime }const u = n.currentTimeline; l && u.delayNextStep(l); const d = u.currentTime; Pn(this, e.animation, n), n.previousNode = e, r.currentStaggerTime = i.currentTime - d + (i.startTime - r.currentTimeline.startTime) } } const hu = {}; class km { constructor(e, n, r, i, o, s, a, l) { this._driver = e, this.element = n, this.subInstructions = r, this._enterClassName = i, this._leaveClassName = o, this.errors = s, this.timelines = a, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = hu, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = l || new mu(this._driver, n, 0), a.push(this.currentTimeline) } get params() { return this.options.params } updateOptions(e, n) { if (!e) return; const r = e; let i = this.options; null != r.duration && (i.duration = vi(r.duration)), null != r.delay && (i.delay = vi(r.delay)); const o = r.params; if (o) { let s = i.params; s || (s = this.options.params = {}), Object.keys(o).forEach(a => { (!n || !s.hasOwnProperty(a)) && (s[a] = ou(o[a], s, this.errors)) }) } } _copyOptions() { const e = {}; if (this.options) { const n = this.options.params; if (n) { const r = e.params = {}; Object.keys(n).forEach(i => { r[i] = n[i] }) } } return e } createSubContext(e = null, n, r) { const i = n || this.element, o = new km(this._driver, i, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(i, r || 0)); return o.previousNode = this.previousNode, o.currentAnimateTimings = this.currentAnimateTimings, o.options = this._copyOptions(), o.updateOptions(e), o.currentQueryIndex = this.currentQueryIndex, o.currentQueryTotal = this.currentQueryTotal, o.parentContext = this, this.subContextCount++, o } transformIntoNewTimeline(e) { return this.previousNode = hu, this.currentTimeline = this.currentTimeline.fork(this.element, e), this.timelines.push(this.currentTimeline), this.currentTimeline } appendInstructionToTimeline(e, n, r) { const i = { duration: n ?? e.duration, delay: this.currentTimeline.currentTime + (r ?? 0) + e.delay, easing: "" }, o = new SV(this._driver, e.element, e.keyframes, e.preStyleProps, e.postStyleProps, i, e.stretchStartingKeyframe); return this.timelines.push(o), i } incrementTime(e) { this.currentTimeline.forwardTime(this.currentTimeline.duration + e) } delayNextStep(e) { e > 0 && this.currentTimeline.delayNextStep(e) } invokeQuery(e, n, r, i, o, s) { let a = []; if (i && a.push(this.element), e.length > 0) { e = (e = e.replace(TV, "." + this._enterClassName)).replace(kV, "." + this._leaveClassName); let c = this._driver.query(this.element, e, 1 != r); 0 !== r && (c = r < 0 ? c.slice(c.length + r, c.length) : c.slice(0, r)), a.push(...c) } return !o && 0 == a.length && s.push(function OL(t) { return new P(3014, Ne) }()), a } } class mu { constructor(e, n, r, i) { this._driver = e, this.element = n, this.startTime = r, this._elementTimelineStylesLookup = i, this.duration = 0, this._previousKeyframe = new Map, this._currentKeyframe = new Map, this._keyframes = new Map, this._styleSummary = new Map, this._localTimelineStyles = new Map, this._pendingStyles = new Map, this._backFill = new Map, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(n), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(n, this._localTimelineStyles)), this._loadKeyframe() } containsAnimation() { switch (this._keyframes.size) { case 0: return !1; case 1: return this.hasCurrentStyleProperties(); default: return !0 } } hasCurrentStyleProperties() { return this._currentKeyframe.size > 0 } get currentTime() { return this.startTime + this.duration } delayNextStep(e) { const n = 1 === this._keyframes.size && this._pendingStyles.size; this.duration || n ? (this.forwardTime(this.currentTime + e), n && this.snapshotCurrentStyles()) : this.startTime += e } fork(e, n) { return this.applyStylesToKeyframe(), new mu(this._driver, e, n || this.currentTime, this._elementTimelineStylesLookup) } _loadKeyframe() { this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = new Map, this._keyframes.set(this.duration, this._currentKeyframe)) } forwardFrame() { this.duration += 1, this._loadKeyframe() } forwardTime(e) { this.applyStylesToKeyframe(), this.duration = e, this._loadKeyframe() } _updateStyle(e, n) { this._localTimelineStyles.set(e, n), this._globalTimelineStyles.set(e, n), this._styleSummary.set(e, { time: this.currentTime, value: n }) } allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe } applyEmptyStep(e) { e && this._previousKeyframe.set("easing", e); for (let [n, r] of this._globalTimelineStyles) this._backFill.set(n, r || Xr), this._currentKeyframe.set(n, Xr); this._currentEmptyStepKeyframe = this._currentKeyframe } setStyles(e, n, r, i) { n && this._previousKeyframe.set("easing", n); const o = i && i.params || {}, s = function IV(t, e) { const n = new Map; let r; return t.forEach(i => { if ("*" === i) { r = r || e.keys(); for (let o of r) n.set(o, Xr) } else wi(i, n) }), n }(e, this._globalTimelineStyles); for (let [a, l] of s) { const c = ou(l, o, r); this._pendingStyles.set(a, c), this._localTimelineStyles.has(a) || this._backFill.set(a, this._globalTimelineStyles.get(a) || Xr), this._updateStyle(a, c) } } applyStylesToKeyframe() { 0 != this._pendingStyles.size && (this._pendingStyles.forEach((e, n) => { this._currentKeyframe.set(n, e) }), this._pendingStyles.clear(), this._localTimelineStyles.forEach((e, n) => { this._currentKeyframe.has(n) || this._currentKeyframe.set(n, e) })) } snapshotCurrentStyles() { for (let [e, n] of this._localTimelineStyles) this._pendingStyles.set(e, n), this._updateStyle(e, n) } getFinalKeyframe() { return this._keyframes.get(this.duration) } get properties() { const e = []; for (let n in this._currentKeyframe) e.push(n); return e } mergeTimelineCollectedStyles(e) { e._styleSummary.forEach((n, r) => { const i = this._styleSummary.get(r); (!i || n.time > i.time) && this._updateStyle(r, n.value) }) } buildKeyframes() { this.applyStylesToKeyframe(); const e = new Set, n = new Set, r = 1 === this._keyframes.size && 0 === this.duration; let i = []; this._keyframes.forEach((a, l) => { const c = wi(a, new Map, this._backFill); c.forEach((u, d) => { "!" === u ? e.add(d) : u === Xr && n.add(d) }), r || c.set("offset", l / this.duration), i.push(c) }); const o = e.size ? su(e.values()) : [], s = n.size ? su(n.values()) : []; if (r) { const a = i[0], l = new Map(a); a.set("offset", 0), l.set("offset", 1), i = [a, l] } return Tm(this.element, i, o, s, this.duration, this.startTime, this.easing, !1) } } class SV extends mu { constructor(e, n, r, i, o, s, a = !1) { super(e, n, s.delay), this.keyframes = r, this.preStyleProps = i, this.postStyleProps = o, this._stretchStartingKeyframe = a, this.timings = { duration: s.duration, delay: s.delay, easing: s.easing } } containsAnimation() { return this.keyframes.length > 1 } buildKeyframes() { let e = this.keyframes, { delay: n, duration: r, easing: i } = this.timings; if (this._stretchStartingKeyframe && n) { const o = [], s = r + n, a = n / s, l = wi(e[0]); l.set("offset", 0), o.push(l); const c = wi(e[0]); c.set("offset", rE(a)), o.push(c); const u = e.length - 1; for (let d = 1; d <= u; d++) { let f = wi(e[d]); const h = f.get("offset"); f.set("offset", rE((n + h * r) / s)), o.push(f) } r = s, n = 0, i = "", e = o } return Tm(this.element, e, this.preStyleProps, this.postStyleProps, r, n, i, !0) } } function rE(t, e = 3) { const n = Math.pow(10, e - 1); return Math.round(t * n) / n } class Am { } const FV = new Set(["width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "left", "top", "bottom", "right", "fontSize", "outlineWidth", "outlineOffset", "paddingTop", "paddingLeft", "paddingBottom", "paddingRight", "marginTop", "marginLeft", "marginBottom", "marginRight", "borderRadius", "borderWidth", "borderTopWidth", "borderLeftWidth", "borderRightWidth", "borderBottomWidth", "textIndent", "perspective"]); class NV extends Am { normalizePropertyName(e, n) { return Em(e) } normalizeStyleValue(e, n, r, i) { let o = ""; const s = r.toString().trim(); if (FV.has(n) && 0 !== r && "0" !== r) if ("number" == typeof r) o = "px"; else { const a = r.match(/^[+-]?[\d\.]+([a-z]*)$/); a && 0 == a[1].length && i.push(function EL(t, e) { return new P(3005, Ne) }()) } return s + o } } function iE(t, e, n, r, i, o, s, a, l, c, u, d, f) { return { type: 0, element: t, triggerName: e, isRemovalTransition: i, fromState: n, fromStyles: o, toState: r, toStyles: s, timelines: a, queriedElements: l, preStyleProps: c, postStyleProps: u, totalTime: d, errors: f } } const Sm = {}; class oE { constructor(e, n, r) { this._triggerName = e, this.ast = n, this._stateStyles = r } match(e, n, r, i) { return function OV(t, e, n, r, i) { return t.some(o => o(e, n, r, i)) }(this.ast.matchers, e, n, r, i) } buildStyles(e, n, r) { let i = this._stateStyles.get("*"); return void 0 !== e && (i = this._stateStyles.get(e?.toString()) || i), i ? i.buildStyles(n, r) : new Map } build(e, n, r, i, o, s, a, l, c, u) { const d = [], f = this.ast.options && this.ast.options.params || Sm, m = this.buildStyles(r, a && a.params || Sm, d), b = l && l.params || Sm, w = this.buildStyles(i, b, d), C = new Set, I = new Map, E = new Map, R = "void" === i, be = { params: RV(b, f), delay: this.ast.options?.delay }, Oe = u ? [] : xm(e, n, this.ast.animation, o, s, m, w, be, c, d); let vt = 0; if (Oe.forEach(Vn => { vt = Math.max(Vn.duration + Vn.delay, vt) }), d.length) return iE(n, this._triggerName, r, i, R, m, w, [], [], I, E, vt, d); Oe.forEach(Vn => { const Bn = Vn.element, as = Rn(I, Bn, new Set); Vn.preStyleProps.forEach(gr => as.add(gr)); const Jr = Rn(E, Bn, new Set); Vn.postStyleProps.forEach(gr => Jr.add(gr)), Bn !== n && C.add(Bn) }); const Ln = su(C.values()); return iE(n, this._triggerName, r, i, R, m, w, Oe, Ln, I, E, vt) } } function RV(t, e) { const n = Fa(e); for (const r in t) t.hasOwnProperty(r) && null != t[r] && (n[r] = t[r]); return n } class PV { constructor(e, n, r) { this.styles = e, this.defaultParams = n, this.normalizer = r } buildStyles(e, n) { const r = new Map, i = Fa(this.defaultParams); return Object.keys(e).forEach(o => { const s = e[o]; null !== s && (i[o] = s) }), this.styles.styles.forEach(o => { "string" != typeof o && o.forEach((s, a) => { s && (s = ou(s, i, n)); const l = this.normalizer.normalizePropertyName(a, n); s = this.normalizer.normalizeStyleValue(a, l, s, n), r.set(l, s) }) }), r } } class VV { constructor(e, n, r) { this.name = e, this.ast = n, this._normalizer = r, this.transitionFactories = [], this.states = new Map, n.states.forEach(i => { this.states.set(i.name, new PV(i.style, i.options && i.options.params || {}, r)) }), sE(this.states, "true", "1"), sE(this.states, "false", "0"), n.transitions.forEach(i => { this.transitionFactories.push(new oE(e, i, this.states)) }), this.fallbackTransition = function BV(t, e, n) { return new oE(t, { type: 1, animation: { type: 2, steps: [], options: null }, matchers: [(s, a) => !0], options: null, queryCount: 0, depCount: 0 }, e) }(e, this.states) } get containsQueries() { return this.ast.queryCount > 0 } matchTransition(e, n, r, i) { return this.transitionFactories.find(s => s.match(e, n, r, i)) || null } matchStyles(e, n, r) { return this.fallbackTransition.buildStyles(e, n, r) } } function sE(t, e, n) { t.has(e) ? t.has(n) || t.set(n, t.get(e)) : t.has(n) && t.set(e, t.get(n)) } const HV = new fu; class jV { constructor(e, n, r) { this.bodyNode = e, this._driver = n, this._normalizer = r, this._animations = new Map, this._playersById = new Map, this.players = [] } register(e, n) { const r = [], o = Cm(this._driver, n, r, []); if (r.length) throw function jL(t) { return new P(3503, Ne) }(); this._animations.set(e, o) } _buildPlayer(e, n, r) { const i = e.element, o = VD(0, this._normalizer, 0, e.keyframes, n, r); return this._driver.animate(i, o, e.duration, e.delay, e.easing, [], !0) } create(e, n, r = {}) { const i = [], o = this._animations.get(e); let s; const a = new Map; if (o ? (s = xm(this._driver, n, o, _m, tu, new Map, new Map, r, HV, i), s.forEach(u => { const d = Rn(a, u.element, new Map); u.postStyleProps.forEach(f => d.set(f, null)) })) : (i.push(function $L() { return new P(3300, Ne) }()), s = []), i.length) throw function zL(t) { return new P(3504, Ne) }(); a.forEach((u, d) => { u.forEach((f, h) => { u.set(h, this._driver.computeStyle(d, h, Xr)) }) }); const c = _i(s.map(u => { const d = a.get(u.element); return this._buildPlayer(u, new Map, d) })); return this._playersById.set(e, c), c.onDestroy(() => this.destroy(e)), this.players.push(c), c } destroy(e) { const n = this._getPlayer(e); n.destroy(), this._playersById.delete(e); const r = this.players.indexOf(n); r >= 0 && this.players.splice(r, 1) } _getPlayer(e) { const n = this._playersById.get(e); if (!n) throw function UL(t) { return new P(3301, Ne) }(); return n } listen(e, n, r, i) { const o = pm(n, "", "", ""); return hm(this._getPlayer(e), r, o, i), () => { } } command(e, n, r, i) { if ("register" == r) return void this.register(e, i[0]); if ("create" == r) return void this.create(e, n, i[0] || {}); const o = this._getPlayer(e); switch (r) { case "play": o.play(); break; case "pause": o.pause(); break; case "reset": o.reset(); break; case "restart": o.restart(); break; case "finish": o.finish(); break; case "init": o.init(); break; case "setPosition": o.setPosition(parseFloat(i[0])); break; case "destroy": this.destroy(e) } } } const aE = "ng-animate-queued", Im = "ng-animate-disabled", qV = [], lE = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 }, WV = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 }, Qn = "__ng_removed"; class Fm { constructor(e, n = "") { this.namespaceId = n; const r = e && e.hasOwnProperty("value"); if (this.value = function YV(t) { return t ?? null }(r ? e.value : e), r) { const o = Fa(e); delete o.value, this.options = o } else this.options = {}; this.options.params || (this.options.params = {}) } get params() { return this.options.params } absorbOptions(e) { const n = e.params; if (n) { const r = this.options.params; Object.keys(n).forEach(i => { null == r[i] && (r[i] = n[i]) }) } } } const Oa = "void", Nm = new Fm(Oa); class ZV { constructor(e, n, r) { this.id = e, this.hostElement = n, this._engine = r, this.players = [], this._triggers = new Map, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + e, Yn(n, this._hostClassName) } listen(e, n, r, i) { if (!this._triggers.has(n)) throw function GL(t, e) { return new P(3302, Ne) }(); if (null == r || 0 == r.length) throw function qL(t) { return new P(3303, Ne) }(); if (!function XV(t) { return "start" == t || "done" == t }(r)) throw function WL(t, e) { return new P(3400, Ne) }(); const o = Rn(this._elementListeners, e, []), s = { name: n, phase: r, callback: i }; o.push(s); const a = Rn(this._engine.statesByElement, e, new Map); return a.has(n) || (Yn(e, nu), Yn(e, nu + "-" + n), a.set(n, Nm)), () => { this._engine.afterFlush(() => { const l = o.indexOf(s); l >= 0 && o.splice(l, 1), this._triggers.has(n) || a.delete(n) }) } } register(e, n) { return !this._triggers.has(e) && (this._triggers.set(e, n), !0) } _getTrigger(e) { const n = this._triggers.get(e); if (!n) throw function ZL(t) { return new P(3401, Ne) }(); return n } trigger(e, n, r, i = !0) { const o = this._getTrigger(n), s = new Om(this.id, n, e); let a = this._engine.statesByElement.get(e); a || (Yn(e, nu), Yn(e, nu + "-" + n), this._engine.statesByElement.set(e, a = new Map)); let l = a.get(n); const c = new Fm(r, this.id); if (!(r && r.hasOwnProperty("value")) && l && c.absorbOptions(l.options), a.set(n, c), l || (l = Nm), c.value !== Oa && l.value === c.value) { if (!function t2(t, e) { const n = Object.keys(t), r = Object.keys(e); if (n.length != r.length) return !1; for (let i = 0; i < n.length; i++) { const o = n[i]; if (!e.hasOwnProperty(o) || t[o] !== e[o]) return !1 } return !0 }(l.params, c.params)) { const b = [], w = o.matchStyles(l.value, l.params, b), C = o.matchStyles(c.value, c.params, b); b.length ? this._engine.reportError(b) : this._engine.afterFlush(() => { Xi(e, w), Nr(e, C) }) } return } const f = Rn(this._engine.playersByElement, e, []); f.forEach(b => { b.namespaceId == this.id && b.triggerName == n && b.queued && b.destroy() }); let h = o.matchTransition(l.value, c.value, e, c.params), m = !1; if (!h) { if (!i) return; h = o.fallbackTransition, m = !0 } return this._engine.totalQueuedPlayers++, this._queue.push({ element: e, triggerName: n, transition: h, fromState: l, toState: c, player: s, isFallbackTransition: m }), m || (Yn(e, aE), s.onStart(() => { ss(e, aE) })), s.onDone(() => { let b = this.players.indexOf(s); b >= 0 && this.players.splice(b, 1); const w = this._engine.playersByElement.get(e); if (w) { let C = w.indexOf(s); C >= 0 && w.splice(C, 1) } }), this.players.push(s), f.push(s), s } deregister(e) { this._triggers.delete(e), this._engine.statesByElement.forEach(n => n.delete(e)), this._elementListeners.forEach((n, r) => { this._elementListeners.set(r, n.filter(i => i.name != e)) }) } clearElementCache(e) { this._engine.statesByElement.delete(e), this._elementListeners.delete(e); const n = this._engine.playersByElement.get(e); n && (n.forEach(r => r.destroy()), this._engine.playersByElement.delete(e)) } _signalRemovalForInnerTriggers(e, n) { const r = this._engine.driver.query(e, ru, !0); r.forEach(i => { if (i[Qn]) return; const o = this._engine.fetchNamespacesByElement(i); o.size ? o.forEach(s => s.triggerLeaveAnimation(i, n, !1, !0)) : this.clearElementCache(i) }), this._engine.afterFlushAnimationsDone(() => r.forEach(i => this.clearElementCache(i))) } triggerLeaveAnimation(e, n, r, i) { const o = this._engine.statesByElement.get(e), s = new Map; if (o) { const a = []; if (o.forEach((l, c) => { if (s.set(c, l.value), this._triggers.has(c)) { const u = this.trigger(e, c, Oa, i); u && a.push(u) } }), a.length) return this._engine.markElementAsRemoved(this.id, e, !0, n, s), r && _i(a).onDone(() => this._engine.processLeaveNode(e)), !0 } return !1 } prepareLeaveAnimationListeners(e) { const n = this._elementListeners.get(e), r = this._engine.statesByElement.get(e); if (n && r) { const i = new Set; n.forEach(o => { const s = o.name; if (i.has(s)) return; i.add(s); const l = this._triggers.get(s).fallbackTransition, c = r.get(s) || Nm, u = new Fm(Oa), d = new Om(this.id, s, e); this._engine.totalQueuedPlayers++, this._queue.push({ element: e, triggerName: s, transition: l, fromState: c, toState: u, player: d, isFallbackTransition: !0 }) }) } } removeNode(e, n) { const r = this._engine; if (e.childElementCount && this._signalRemovalForInnerTriggers(e, n), this.triggerLeaveAnimation(e, n, !0)) return; let i = !1; if (r.totalAnimations) { const o = r.players.length ? r.playersByQueriedElement.get(e) : []; if (o && o.length) i = !0; else { let s = e; for (; s = s.parentNode;)if (r.statesByElement.get(s)) { i = !0; break } } } if (this.prepareLeaveAnimationListeners(e), i) r.markElementAsRemoved(this.id, e, !1, n); else { const o = e[Qn]; (!o || o === lE) && (r.afterFlush(() => this.clearElementCache(e)), r.destroyInnerAnimations(e), r._onRemovalComplete(e, n)) } } insertNode(e, n) { Yn(e, this._hostClassName) } drainQueuedTransitions(e) { const n = []; return this._queue.forEach(r => { const i = r.player; if (i.destroyed) return; const o = r.element, s = this._elementListeners.get(o); s && s.forEach(a => { if (a.name == r.triggerName) { const l = pm(o, r.triggerName, r.fromState.value, r.toState.value); l._data = e, hm(r.player, a.phase, l, a.callback) } }), i.markedForDestroy ? this._engine.afterFlush(() => { i.destroy() }) : n.push(r) }), this._queue = [], n.sort((r, i) => { const o = r.transition.ast.depCount, s = i.transition.ast.depCount; return 0 == o || 0 == s ? o - s : this._engine.driver.containsElement(r.element, i.element) ? 1 : -1 }) } destroy(e) { this.players.forEach(n => n.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, e) } elementContainsData(e) { let n = !1; return this._elementListeners.has(e) && (n = !0), n = !!this._queue.find(r => r.element === e) || n, n } } class KV { constructor(e, n, r) { this.bodyNode = e, this.driver = n, this._normalizer = r, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (i, o) => { } } _onRemovalComplete(e, n) { this.onRemovalComplete(e, n) } get queuedPlayers() { const e = []; return this._namespaceList.forEach(n => { n.players.forEach(r => { r.queued && e.push(r) }) }), e } createNamespace(e, n) { const r = new ZV(e, n, this); return this.bodyNode && this.driver.containsElement(this.bodyNode, n) ? this._balanceNamespaceList(r, n) : (this.newHostElements.set(n, r), this.collectEnterElement(n)), this._namespaceLookup[e] = r } _balanceNamespaceList(e, n) { const r = this._namespaceList, i = this.namespacesByHostElement; if (r.length - 1 >= 0) { let s = !1, a = this.driver.getParentElement(n); for (; a;) { const l = i.get(a); if (l) { const c = r.indexOf(l); r.splice(c + 1, 0, e), s = !0; break } a = this.driver.getParentElement(a) } s || r.unshift(e) } else r.push(e); return i.set(n, e), e } register(e, n) { let r = this._namespaceLookup[e]; return r || (r = this.createNamespace(e, n)), r } registerTrigger(e, n, r) { let i = this._namespaceLookup[e]; i && i.register(n, r) && this.totalAnimations++ } destroy(e, n) { if (!e) return; const r = this._fetchNamespace(e); this.afterFlush(() => { this.namespacesByHostElement.delete(r.hostElement), delete this._namespaceLookup[e]; const i = this._namespaceList.indexOf(r); i >= 0 && this._namespaceList.splice(i, 1) }), this.afterFlushAnimationsDone(() => r.destroy(n)) } _fetchNamespace(e) { return this._namespaceLookup[e] } fetchNamespacesByElement(e) { const n = new Set, r = this.statesByElement.get(e); if (r) for (let i of r.values()) if (i.namespaceId) { const o = this._fetchNamespace(i.namespaceId); o && n.add(o) } return n } trigger(e, n, r, i) { if (pu(n)) { const o = this._fetchNamespace(e); if (o) return o.trigger(n, r, i), !0 } return !1 } insertNode(e, n, r, i) { if (!pu(n)) return; const o = n[Qn]; if (o && o.setForRemoval) { o.setForRemoval = !1, o.setForMove = !0; const s = this.collectedLeaveElements.indexOf(n); s >= 0 && this.collectedLeaveElements.splice(s, 1) } if (e) { const s = this._fetchNamespace(e); s && s.insertNode(n, r) } i && this.collectEnterElement(n) } collectEnterElement(e) { this.collectedEnterElements.push(e) } markElementAsDisabled(e, n) { n ? this.disabledNodes.has(e) || (this.disabledNodes.add(e), Yn(e, Im)) : this.disabledNodes.has(e) && (this.disabledNodes.delete(e), ss(e, Im)) } removeNode(e, n, r, i) { if (pu(n)) { const o = e ? this._fetchNamespace(e) : null; if (o ? o.removeNode(n, i) : this.markElementAsRemoved(e, n, !1, i), r) { const s = this.namespacesByHostElement.get(n); s && s.id !== e && s.removeNode(n, i) } } else this._onRemovalComplete(n, i) } markElementAsRemoved(e, n, r, i, o) { this.collectedLeaveElements.push(n), n[Qn] = { namespaceId: e, setForRemoval: i, hasAnimation: r, removedBeforeQueried: !1, previousTriggersValues: o } } listen(e, n, r, i, o) { return pu(n) ? this._fetchNamespace(e).listen(n, r, i, o) : () => { } } _buildInstruction(e, n, r, i, o) { return e.transition.build(this.driver, e.element, e.fromState.value, e.toState.value, r, i, e.fromState.options, e.toState.options, n, o) } destroyInnerAnimations(e) { let n = this.driver.query(e, ru, !0); n.forEach(r => this.destroyActiveAnimationsForElement(r)), 0 != this.playersByQueriedElement.size && (n = this.driver.query(e, vm, !0), n.forEach(r => this.finishActiveQueriedAnimationOnElement(r))) } destroyActiveAnimationsForElement(e) { const n = this.playersByElement.get(e); n && n.forEach(r => { r.queued ? r.markedForDestroy = !0 : r.destroy() }) } finishActiveQueriedAnimationOnElement(e) { const n = this.playersByQueriedElement.get(e); n && n.forEach(r => r.finish()) } whenRenderingDone() { return new Promise(e => { if (this.players.length) return _i(this.players).onDone(() => e()); e() }) } processLeaveNode(e) { const n = e[Qn]; if (n && n.setForRemoval) { if (e[Qn] = lE, n.namespaceId) { this.destroyInnerAnimations(e); const r = this._fetchNamespace(n.namespaceId); r && r.clearElementCache(e) } this._onRemovalComplete(e, n.setForRemoval) } e.classList?.contains(Im) && this.markElementAsDisabled(e, !1), this.driver.query(e, ".ng-animate-disabled", !0).forEach(r => { this.markElementAsDisabled(r, !1) }) } flush(e = -1) { let n = []; if (this.newHostElements.size && (this.newHostElements.forEach((r, i) => this._balanceNamespaceList(r, i)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let r = 0; r < this.collectedEnterElements.length; r++)Yn(this.collectedEnterElements[r], "ng-star-inserted"); if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) { const r = []; try { n = this._flushAnimations(r, e) } finally { for (let i = 0; i < r.length; i++)r[i]() } } else for (let r = 0; r < this.collectedLeaveElements.length; r++)this.processLeaveNode(this.collectedLeaveElements[r]); if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(r => r()), this._flushFns = [], this._whenQuietFns.length) { const r = this._whenQuietFns; this._whenQuietFns = [], n.length ? _i(n).onDone(() => { r.forEach(i => i()) }) : r.forEach(i => i()) } } reportError(e) { throw function KL(t) { return new P(3402, Ne) }() } _flushAnimations(e, n) { const r = new fu, i = [], o = new Map, s = [], a = new Map, l = new Map, c = new Map, u = new Set; this.disabledNodes.forEach(H => { u.add(H); const ee = this.driver.query(H, ".ng-animate-queued", !0); for (let ae = 0; ae < ee.length; ae++)u.add(ee[ae]) }); const d = this.bodyNode, f = Array.from(this.statesByElement.keys()), h = dE(f, this.collectedEnterElements), m = new Map; let b = 0; h.forEach((H, ee) => { const ae = _m + b++; m.set(ee, ae), H.forEach(Ve => Yn(Ve, ae)) }); const w = [], C = new Set, I = new Set; for (let H = 0; H < this.collectedLeaveElements.length; H++) { const ee = this.collectedLeaveElements[H], ae = ee[Qn]; ae && ae.setForRemoval && (w.push(ee), C.add(ee), ae.hasAnimation ? this.driver.query(ee, ".ng-star-inserted", !0).forEach(Ve => C.add(Ve)) : I.add(ee)) } const E = new Map, R = dE(f, Array.from(C)); R.forEach((H, ee) => { const ae = tu + b++; E.set(ee, ae), H.forEach(Ve => Yn(Ve, ae)) }), e.push(() => { h.forEach((H, ee) => { const ae = m.get(ee); H.forEach(Ve => ss(Ve, ae)) }), R.forEach((H, ee) => { const ae = E.get(ee); H.forEach(Ve => ss(Ve, ae)) }), w.forEach(H => { this.processLeaveNode(H) }) }); const be = [], Oe = []; for (let H = this._namespaceList.length - 1; H >= 0; H--)this._namespaceList[H].drainQueuedTransitions(n).forEach(ae => { const Ve = ae.player, qt = ae.element; if (be.push(Ve), this.collectedEnterElements.length) { const an = qt[Qn]; if (an && an.setForMove) { if (an.previousTriggersValues && an.previousTriggersValues.has(ae.triggerName)) { const eo = an.previousTriggersValues.get(ae.triggerName), Xn = this.statesByElement.get(ae.element); if (Xn && Xn.has(ae.triggerName)) { const yu = Xn.get(ae.triggerName); yu.value = eo, Xn.set(ae.triggerName, yu) } } return void Ve.destroy() } } const Or = !d || !this.driver.containsElement(d, qt), Hn = E.get(qt), Di = m.get(qt), wt = this._buildInstruction(ae, r, Di, Hn, Or); if (wt.errors && wt.errors.length) return void Oe.push(wt); if (Or) return Ve.onStart(() => Xi(qt, wt.fromStyles)), Ve.onDestroy(() => Nr(qt, wt.toStyles)), void i.push(Ve); if (ae.isFallbackTransition) return Ve.onStart(() => Xi(qt, wt.fromStyles)), Ve.onDestroy(() => Nr(qt, wt.toStyles)), void i.push(Ve); const vE = []; wt.timelines.forEach(an => { an.stretchStartingKeyframe = !0, this.disabledNodes.has(an.element) || vE.push(an) }), wt.timelines = vE, r.append(qt, wt.timelines), s.push({ instruction: wt, player: Ve, element: qt }), wt.queriedElements.forEach(an => Rn(a, an, []).push(Ve)), wt.preStyleProps.forEach((an, eo) => { if (an.size) { let Xn = l.get(eo); Xn || l.set(eo, Xn = new Set), an.forEach((yu, Pm) => Xn.add(Pm)) } }), wt.postStyleProps.forEach((an, eo) => { let Xn = c.get(eo); Xn || c.set(eo, Xn = new Set), an.forEach((yu, Pm) => Xn.add(Pm)) }) }); if (Oe.length) { const H = []; Oe.forEach(ee => { H.push(function QL(t, e) { return new P(3505, Ne) }()) }), be.forEach(ee => ee.destroy()), this.reportError(H) } const vt = new Map, Ln = new Map; s.forEach(H => { const ee = H.element; r.has(ee) && (Ln.set(ee, ee), this._beforeAnimationBuild(H.player.namespaceId, H.instruction, vt)) }), i.forEach(H => { const ee = H.element; this._getPreviousPlayers(ee, !1, H.namespaceId, H.triggerName, null).forEach(Ve => { Rn(vt, ee, []).push(Ve), Ve.destroy() }) }); const Vn = w.filter(H => hE(H, l, c)), Bn = new Map; uE(Bn, this.driver, I, c, Xr).forEach(H => { hE(H, l, c) && Vn.push(H) }); const Jr = new Map; h.forEach((H, ee) => { uE(Jr, this.driver, new Set(H), l, "!") }), Vn.forEach(H => { const ee = Bn.get(H), ae = Jr.get(H); Bn.set(H, new Map([...Array.from(ee?.entries() ?? []), ...Array.from(ae?.entries() ?? [])])) }); const gr = [], ls = [], cs = {}; s.forEach(H => { const { element: ee, player: ae, instruction: Ve } = H; if (r.has(ee)) { if (u.has(ee)) return ae.onDestroy(() => Nr(ee, Ve.toStyles)), ae.disabled = !0, ae.overrideTotalTime(Ve.totalTime), void i.push(ae); let qt = cs; if (Ln.size > 1) { let Hn = ee; const Di = []; for (; Hn = Hn.parentNode;) { const wt = Ln.get(Hn); if (wt) { qt = wt; break } Di.push(Hn) } Di.forEach(wt => Ln.set(wt, qt)) } const Or = this._buildAnimation(ae.namespaceId, Ve, vt, o, Jr, Bn); if (ae.setRealPlayer(Or), qt === cs) gr.push(ae); else { const Hn = this.playersByElement.get(qt); Hn && Hn.length && (ae.parentPlayer = _i(Hn)), i.push(ae) } } else Xi(ee, Ve.fromStyles), ae.onDestroy(() => Nr(ee, Ve.toStyles)), ls.push(ae), u.has(ee) && i.push(ae) }), ls.forEach(H => { const ee = o.get(H.element); if (ee && ee.length) { const ae = _i(ee); H.setRealPlayer(ae) } }), i.forEach(H => { H.parentPlayer ? H.syncPlayerEvents(H.parentPlayer) : H.destroy() }); for (let H = 0; H < w.length; H++) { const ee = w[H], ae = ee[Qn]; if (ss(ee, tu), ae && ae.hasAnimation) continue; let Ve = []; if (a.size) { let Or = a.get(ee); Or && Or.length && Ve.push(...Or); let Hn = this.driver.query(ee, vm, !0); for (let Di = 0; Di < Hn.length; Di++) { let wt = a.get(Hn[Di]); wt && wt.length && Ve.push(...wt) } } const qt = Ve.filter(Or => !Or.destroyed); qt.length ? JV(this, ee, qt) : this.processLeaveNode(ee) } return w.length = 0, gr.forEach(H => { this.players.push(H), H.onDone(() => { H.destroy(); const ee = this.players.indexOf(H); this.players.splice(ee, 1) }), H.play() }), gr } elementContainsData(e, n) { let r = !1; const i = n[Qn]; return i && i.setForRemoval && (r = !0), this.playersByElement.has(n) && (r = !0), this.playersByQueriedElement.has(n) && (r = !0), this.statesByElement.has(n) && (r = !0), this._fetchNamespace(e).elementContainsData(n) || r } afterFlush(e) { this._flushFns.push(e) } afterFlushAnimationsDone(e) { this._whenQuietFns.push(e) } _getPreviousPlayers(e, n, r, i, o) { let s = []; if (n) { const a = this.playersByQueriedElement.get(e); a && (s = a) } else { const a = this.playersByElement.get(e); if (a) { const l = !o || o == Oa; a.forEach(c => { c.queued || !l && c.triggerName != i || s.push(c) }) } } return (r || i) && (s = s.filter(a => !(r && r != a.namespaceId || i && i != a.triggerName))), s } _beforeAnimationBuild(e, n, r) { const o = n.element, s = n.isRemovalTransition ? void 0 : e, a = n.isRemovalTransition ? void 0 : n.triggerName; for (const l of n.timelines) { const c = l.element, u = c !== o, d = Rn(r, c, []); this._getPreviousPlayers(c, u, s, a, n.toState).forEach(h => { const m = h.getRealPlayer(); m.beforeDestroy && m.beforeDestroy(), h.destroy(), d.push(h) }) } Xi(o, n.fromStyles) } _buildAnimation(e, n, r, i, o, s) { const a = n.triggerName, l = n.element, c = [], u = new Set, d = new Set, f = n.timelines.map(m => { const b = m.element; u.add(b); const w = b[Qn]; if (w && w.removedBeforeQueried) return new Ma(m.duration, m.delay); const C = b !== l, I = function e2(t) { const e = []; return fE(t, e), e }((r.get(b) || qV).map(vt => vt.getRealPlayer())).filter(vt => !!vt.element && vt.element === b), E = o.get(b), R = s.get(b), be = VD(0, this._normalizer, 0, m.keyframes, E, R), Oe = this._buildPlayer(m, be, I); if (m.subTimeline && i && d.add(b), C) { const vt = new Om(e, a, b); vt.setRealPlayer(Oe), c.push(vt) } return Oe }); c.forEach(m => { Rn(this.playersByQueriedElement, m.element, []).push(m), m.onDone(() => function QV(t, e, n) { let r = t.get(e); if (r) { if (r.length) { const i = r.indexOf(n); r.splice(i, 1) } 0 == r.length && t.delete(e) } return r }(this.playersByQueriedElement, m.element, m)) }), u.forEach(m => Yn(m, WD)); const h = _i(f); return h.onDestroy(() => { u.forEach(m => ss(m, WD)), Nr(l, n.toStyles) }), d.forEach(m => { Rn(i, m, []).push(h) }), h } _buildPlayer(e, n, r) { return n.length > 0 ? this.driver.animate(e.element, n, e.duration, e.delay, e.easing, r) : new Ma(e.duration, e.delay) } } class Om { constructor(e, n, r) { this.namespaceId = e, this.triggerName = n, this.element = r, this._player = new Ma, this._containsRealPlayer = !1, this._queuedCallbacks = new Map, this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0 } setRealPlayer(e) { this._containsRealPlayer || (this._player = e, this._queuedCallbacks.forEach((n, r) => { n.forEach(i => hm(e, r, void 0, i)) }), this._queuedCallbacks.clear(), this._containsRealPlayer = !0, this.overrideTotalTime(e.totalTime), this.queued = !1) } getRealPlayer() { return this._player } overrideTotalTime(e) { this.totalTime = e } syncPlayerEvents(e) { const n = this._player; n.triggerCallback && e.onStart(() => n.triggerCallback("start")), e.onDone(() => this.finish()), e.onDestroy(() => this.destroy()) } _queueEvent(e, n) { Rn(this._queuedCallbacks, e, []).push(n) } onDone(e) { this.queued && this._queueEvent("done", e), this._player.onDone(e) } onStart(e) { this.queued && this._queueEvent("start", e), this._player.onStart(e) } onDestroy(e) { this.queued && this._queueEvent("destroy", e), this._player.onDestroy(e) } init() { this._player.init() } hasStarted() { return !this.queued && this._player.hasStarted() } play() { !this.queued && this._player.play() } pause() { !this.queued && this._player.pause() } restart() { !this.queued && this._player.restart() } finish() { this._player.finish() } destroy() { this.destroyed = !0, this._player.destroy() } reset() { !this.queued && this._player.reset() } setPosition(e) { this.queued || this._player.setPosition(e) } getPosition() { return this.queued ? 0 : this._player.getPosition() } triggerCallback(e) { const n = this._player; n.triggerCallback && n.triggerCallback(e) } } function pu(t) { return t && 1 === t.nodeType } function cE(t, e) { const n = t.style.display; return t.style.display = e ?? "none", n } function uE(t, e, n, r, i) { const o = []; n.forEach(l => o.push(cE(l))); const s = []; r.forEach((l, c) => { const u = new Map; l.forEach(d => { const f = e.computeStyle(c, d, i); u.set(d, f), (!f || 0 == f.length) && (c[Qn] = WV, s.push(c)) }), t.set(c, u) }); let a = 0; return n.forEach(l => cE(l, o[a++])), s } function dE(t, e) { const n = new Map; if (t.forEach(a => n.set(a, [])), 0 == e.length) return n; const i = new Set(e), o = new Map; function s(a) { if (!a) return 1; let l = o.get(a); if (l) return l; const c = a.parentNode; return l = n.has(c) ? c : i.has(c) ? 1 : s(c), o.set(a, l), l } return e.forEach(a => { const l = s(a); 1 !== l && n.get(l).push(a) }), n } function Yn(t, e) { t.classList?.add(e) } function ss(t, e) { t.classList?.remove(e) } function JV(t, e, n) { _i(n).onDone(() => t.processLeaveNode(e)) } function fE(t, e) { for (let n = 0; n < t.length; n++) { const r = t[n]; r instanceof cD ? fE(r.players, e) : e.push(r) } } function hE(t, e, n) { const r = n.get(t); if (!r) return !1; let i = e.get(t); return i ? r.forEach(o => i.add(o)) : e.set(t, r), n.delete(t), !0 } class gu { constructor(e, n, r) { this.bodyNode = e, this._driver = n, this._normalizer = r, this._triggerCache = {}, this.onRemovalComplete = (i, o) => { }, this._transitionEngine = new KV(e, n, r), this._timelineEngine = new jV(e, n, r), this._transitionEngine.onRemovalComplete = (i, o) => this.onRemovalComplete(i, o) } registerTrigger(e, n, r, i, o) { const s = e + "-" + i; let a = this._triggerCache[s]; if (!a) { const l = [], u = Cm(this._driver, o, l, []); if (l.length) throw function BL(t, e) { return new P(3404, Ne) }(); a = function LV(t, e, n) { return new VV(t, e, n) }(i, u, this._normalizer), this._triggerCache[s] = a } this._transitionEngine.registerTrigger(n, i, a) } register(e, n) { this._transitionEngine.register(e, n) } destroy(e, n) { this._transitionEngine.destroy(e, n) } onInsert(e, n, r, i) { this._transitionEngine.insertNode(e, n, r, i) } onRemove(e, n, r, i) { this._transitionEngine.removeNode(e, n, i || !1, r) } disableAnimations(e, n) { this._transitionEngine.markElementAsDisabled(e, n) } process(e, n, r, i) { if ("@" == r.charAt(0)) { const [o, s] = BD(r); this._timelineEngine.command(o, n, s, i) } else this._transitionEngine.trigger(e, n, r, i) } listen(e, n, r, i, o) { if ("@" == r.charAt(0)) { const [s, a] = BD(r); return this._timelineEngine.listen(s, n, a, o) } return this._transitionEngine.listen(e, n, r, i, o) } flush(e = -1) { this._transitionEngine.flush(e) } get players() { return this._transitionEngine.players.concat(this._timelineEngine.players) } whenRenderingDone() { return this._transitionEngine.whenRenderingDone() } } let r2 = (() => { class t { constructor(n, r, i) { this._element = n, this._startStyles = r, this._endStyles = i, this._state = 0; let o = t.initialStylesByElement.get(n); o || t.initialStylesByElement.set(n, o = new Map), this._initialStyles = o } start() { this._state < 1 && (this._startStyles && Nr(this._element, this._startStyles, this._initialStyles), this._state = 1) } finish() { this.start(), this._state < 2 && (Nr(this._element, this._initialStyles), this._endStyles && (Nr(this._element, this._endStyles), this._endStyles = null), this._state = 1) } destroy() { this.finish(), this._state < 3 && (t.initialStylesByElement.delete(this._element), this._startStyles && (Xi(this._element, this._startStyles), this._endStyles = null), this._endStyles && (Xi(this._element, this._endStyles), this._endStyles = null), Nr(this._element, this._initialStyles), this._state = 3) } } return t.initialStylesByElement = new WeakMap, t })(); function Rm(t) { let e = null; return t.forEach((n, r) => { (function o2(t) { return "display" === t || "position" === t })(r) && (e = e || new Map, e.set(r, n)) }), e } class mE { constructor(e, n, r, i) { this.element = e, this.keyframes = n, this.options = r, this._specialStyles = i, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this.time = 0, this.parentPlayer = null, this.currentSnapshot = new Map, this._duration = r.duration, this._delay = r.delay || 0, this.time = this._duration + this._delay } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = []) } init() { this._buildPlayer(), this._preparePlayerBeforeStart() } _buildPlayer() { if (this._initialized) return; this._initialized = !0; const e = this.keyframes; this.domPlayer = this._triggerWebAnimation(this.element, e, this.options), this._finalKeyframe = e.length ? e[e.length - 1] : new Map, this.domPlayer.addEventListener("finish", () => this._onFinish()) } _preparePlayerBeforeStart() { this._delay ? this._resetDomPlayerState() : this.domPlayer.pause() } _convertKeyframesToObject(e) { const n = []; return e.forEach(r => { n.push(Object.fromEntries(r)) }), n } _triggerWebAnimation(e, n, r) { return e.animate(this._convertKeyframesToObject(n), r) } onStart(e) { this._onStartFns.push(e) } onDone(e) { this._onDoneFns.push(e) } onDestroy(e) { this._onDestroyFns.push(e) } play() { this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(e => e()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play() } pause() { this.init(), this.domPlayer.pause() } finish() { this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish() } reset() { this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1 } _resetDomPlayerState() { this.domPlayer && this.domPlayer.cancel() } restart() { this.reset(), this.play() } hasStarted() { return this._started } destroy() { this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = []) } setPosition(e) { void 0 === this.domPlayer && this.init(), this.domPlayer.currentTime = e * this.time } getPosition() { return this.domPlayer.currentTime / this.time } get totalTime() { return this._delay + this._duration } beforeDestroy() { const e = new Map; this.hasStarted() && this._finalKeyframe.forEach((r, i) => { "offset" !== i && e.set(i, this._finished ? r : JD(this.element, i)) }), this.currentSnapshot = e } triggerCallback(e) { const n = "start" === e ? this._onStartFns : this._onDoneFns; n.forEach(r => r()), n.length = 0 } } class s2 { validateStyleProperty(e) { return !0 } validateAnimatableStyleProperty(e) { return !0 } matchesElement(e, n) { return !1 } containsElement(e, n) { return zD(e, n) } getParentElement(e) { return bm(e) } query(e, n, r) { return UD(e, n, r) } computeStyle(e, n, r) { return window.getComputedStyle(e)[n] } animate(e, n, r, i, o, s = []) { const l = { duration: r, delay: i, fill: 0 == i ? "both" : "forwards" }; o && (l.easing = o); const c = new Map, u = s.filter(h => h instanceof mE); (function cV(t, e) { return 0 === t || 0 === e })(r, i) && u.forEach(h => { h.currentSnapshot.forEach((m, b) => c.set(b, m)) }); let d = function oV(t) { return t.length ? t[0] instanceof Map ? t : t.map(e => ZD(e)) : [] }(n).map(h => wi(h)); d = function uV(t, e, n) { if (n.size && e.length) { let r = e[0], i = []; if (n.forEach((o, s) => { r.has(s) || i.push(s), r.set(s, o) }), i.length) for (let o = 1; o < e.length; o++) { let s = e[o]; i.forEach(a => s.set(a, JD(t, a))) } } return e }(e, d, c); const f = function n2(t, e) { let n = null, r = null; return Array.isArray(e) && e.length ? (n = Rm(e[0]), e.length > 1 && (r = Rm(e[e.length - 1]))) : e instanceof Map && (n = Rm(e)), n || r ? new r2(t, n, r) : null }(e, d); return new mE(e, d, l, f) } } let a2 = (() => { class t extends oD { constructor(n, r) { super(), this._nextAnimationId = 0, this._renderer = n.createRenderer(r.body, { id: "0", encapsulation: rr.None, styles: [], data: { animation: [] } }) } build(n) { const r = this._nextAnimationId.toString(); this._nextAnimationId++; const i = Array.isArray(n) ? aD(n) : n; return pE(this._renderer, null, r, "register", [i]), new l2(r, this._renderer) } } return t.\u0275fac = function (n) { return new (n || t)(B(Xo), B(Gt)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac }), t })(); class l2 extends class AR { }{ constructor(e, n) { super(), this._id = e, this._renderer = n } create(e, n) { return new c2(this._id, e, n || {}, this._renderer) } } class c2 { constructor(e, n, r, i) { this.id = e, this.element = n, this._renderer = i, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", r) } _listen(e, n) { return this._renderer.listen(this.element, `@@${this.id}:${e}`, n) } _command(e, ...n) { return pE(this._renderer, this.element, this.id, e, n) } onDone(e) { this._listen("done", e) } onStart(e) { this._listen("start", e) } onDestroy(e) { this._listen("destroy", e) } init() { this._command("init") } hasStarted() { return this._started } play() { this._command("play"), this._started = !0 } pause() { this._command("pause") } restart() { this._command("restart") } finish() { this._command("finish") } destroy() { this._command("destroy") } reset() { this._command("reset"), this._started = !1 } setPosition(e) { this._command("setPosition", e) } getPosition() { return this._renderer.engine.players[+this.id]?.getPosition() ?? 0 } } function pE(t, e, n, r, i) { return t.setProperty(e, `@@${n}:${r}`, i) } const gE = "@.disabled"; let u2 = (() => { class t { constructor(n, r, i) { this.delegate = n, this.engine = r, this._zone = i, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, this.promise = Promise.resolve(0), r.onRemovalComplete = (o, s) => { const a = s?.parentNode(o); a && s.removeChild(a, o) } } createRenderer(n, r) { const o = this.delegate.createRenderer(n, r); if (!(n && r && r.data && r.data.animation)) { let u = this._rendererCache.get(o); return u || (u = new bE("", o, this.engine), this._rendererCache.set(o, u)), u } const s = r.id, a = r.id + "-" + this._currentId; this._currentId++, this.engine.register(a, n); const l = u => { Array.isArray(u) ? u.forEach(l) : this.engine.registerTrigger(s, a, n, u.name, u) }; return r.data.animation.forEach(l), new d2(this, a, o, this.engine) } begin() { this._cdRecurDepth++, this.delegate.begin && this.delegate.begin() } _scheduleCountTask() { this.promise.then(() => { this._microtaskId++ }) } scheduleListenerCallback(n, r, i) { n >= 0 && n < this._microtaskId ? this._zone.run(() => r(i)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => { this._zone.run(() => { this._animationCallbacksBuffer.forEach(o => { const [s, a] = o; s(a) }), this._animationCallbacksBuffer = [] }) }), this._animationCallbacksBuffer.push([r, i])) } end() { this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => { this._scheduleCountTask(), this.engine.flush(this._microtaskId) }), this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.engine.whenRenderingDone() } } return t.\u0275fac = function (n) { return new (n || t)(B(Xo), B(gu), B(Xe)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac }), t })(); class bE { constructor(e, n, r) { this.namespaceId = e, this.delegate = n, this.engine = r, this.destroyNode = this.delegate.destroyNode ? i => n.destroyNode(i) : null } get data() { return this.delegate.data } destroy() { this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy() } createElement(e, n) { return this.delegate.createElement(e, n) } createComment(e) { return this.delegate.createComment(e) } createText(e) { return this.delegate.createText(e) } appendChild(e, n) { this.delegate.appendChild(e, n), this.engine.onInsert(this.namespaceId, n, e, !1) } insertBefore(e, n, r, i = !0) { this.delegate.insertBefore(e, n, r), this.engine.onInsert(this.namespaceId, n, e, i) } removeChild(e, n, r) { this.engine.onRemove(this.namespaceId, n, this.delegate, r) } selectRootElement(e, n) { return this.delegate.selectRootElement(e, n) } parentNode(e) { return this.delegate.parentNode(e) } nextSibling(e) { return this.delegate.nextSibling(e) } setAttribute(e, n, r, i) { this.delegate.setAttribute(e, n, r, i) } removeAttribute(e, n, r) { this.delegate.removeAttribute(e, n, r) } addClass(e, n) { this.delegate.addClass(e, n) } removeClass(e, n) { this.delegate.removeClass(e, n) } setStyle(e, n, r, i) { this.delegate.setStyle(e, n, r, i) } removeStyle(e, n, r) { this.delegate.removeStyle(e, n, r) } setProperty(e, n, r) { "@" == n.charAt(0) && n == gE ? this.disableAnimations(e, !!r) : this.delegate.setProperty(e, n, r) } setValue(e, n) { this.delegate.setValue(e, n) } listen(e, n, r) { return this.delegate.listen(e, n, r) } disableAnimations(e, n) { this.engine.disableAnimations(e, n) } } class d2 extends bE { constructor(e, n, r, i) { super(n, r, i), this.factory = e, this.namespaceId = n } setProperty(e, n, r) { "@" == n.charAt(0) ? "." == n.charAt(1) && n == gE ? this.disableAnimations(e, r = void 0 === r || !!r) : this.engine.process(this.namespaceId, e, n.slice(1), r) : this.delegate.setProperty(e, n, r) } listen(e, n, r) { if ("@" == n.charAt(0)) { const i = function f2(t) { switch (t) { case "body": return document.body; case "document": return document; case "window": return window; default: return t } }(e); let o = n.slice(1), s = ""; return "@" != o.charAt(0) && ([o, s] = function h2(t) { const e = t.indexOf("."); return [t.substring(0, e), t.slice(e + 1)] }(o)), this.engine.listen(this.namespaceId, i, o, s, a => { this.factory.scheduleListenerCallback(a._data || -1, r, a) }) } return this.delegate.listen(e, n, r) } } const yE = [{ provide: oD, useClass: a2 }, { provide: Am, useFactory: function p2() { return new NV } }, { provide: gu, useClass: (() => { class t extends gu { constructor(n, r, i) { super(n.body, r, i) } ngOnDestroy() { this.flush() } } return t.\u0275fac = function (n) { return new (n || t)(B(Gt), B(ym), B(Am)) }, t.\u0275prov = pe({ token: t, factory: t.\u0275fac }), t })() }, { provide: Xo, useFactory: function g2(t, e, n) { return new u2(t, e, n) }, deps: [Dc, gu, Xe] }], _E = [{ provide: ym, useFactory: () => new s2 }, { provide: sa, useValue: "BrowserAnimations" }, ...yE], b2 = [{ provide: ym, useClass: GD }, { provide: sa, useValue: "NoopAnimations" }, ...yE]; let y2 = (() => { class t { static withConfig(n) { return { ngModule: t, providers: n.disableAnimations ? b2 : _E } } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Ot({ type: t }), t.\u0275inj = At({ providers: _E, imports: [mv] }), t })(), _2 = (() => { class t { constructor(n) { this.injector = n } ngDoBootstrap(n) { if (!customElements.get("login-provider")) { const r = function lN(t, e) { const n = function tN(t, e) { return e.get(Vi).resolveComponentFactory(t).inputs }(t, e.injector), r = e.strategyFactory || new oN(t, e.injector), i = function eN(t) { const e = {}; return t.forEach(({ propName: n, templateName: r }) => { e[function KF(t) { return t.replace(/[A-Z]/g, e => `-${e.toLowerCase()}`) }(r)] = n }), e }(n); class o extends aN { constructor(a) { super(), this.injector = a } get ngElementStrategy() { if (!this._ngElementStrategy) { const a = this._ngElementStrategy = r.create(this.injector || e.injector); n.forEach(({ propName: l }) => { if (!this.hasOwnProperty(l)) return; const c = this[l]; delete this[l], a.setInputValue(l, c) }) } return this._ngElementStrategy } attributeChangedCallback(a, l, c, u) { this.ngElementStrategy.setInputValue(i[a], c) } connectedCallback() { let a = !1; this.ngElementStrategy.events && (this.subscribeToEvents(), a = !0), this.ngElementStrategy.connect(this), a || this.subscribeToEvents() } disconnectedCallback() { this._ngElementStrategy && this._ngElementStrategy.disconnect(), this.ngElementEventsSubscription && (this.ngElementEventsSubscription.unsubscribe(), this.ngElementEventsSubscription = null) } subscribeToEvents() { this.ngElementEventsSubscription = this.ngElementStrategy.events.subscribe(a => { const l = new CustomEvent(a.name, { detail: a.value }); this.dispatchEvent(l) }) } } return o.observedAttributes = Object.keys(i), n.forEach(({ propName: s }) => { Object.defineProperty(o.prototype, s, { get() { return this.ngElementStrategy.getInputValue(s) }, set(a) { this.ngElementStrategy.setInputValue(s, a) }, configurable: !0, enumerable: !0 }) }), o }(gL, { injector: this.injector }); customElements.define("login-provider", r) } } } return t.\u0275fac = function (n) { return new (n || t)(B(tn)) }, t.\u0275mod = Ot({ type: t }), t.\u0275inj = At({ imports: [mv, bL, y2] }), t })(); Vm(583), function xI() { D0 = !1 }(), LF().bootstrapModule(_2).catch(t => console.error(t)) })() })();
